/**
 * name: @tresjs/cientos
 * version: v4.0.3
 * (c) 2024
 * description: Collection of useful helpers and fully functional, ready-made abstractions for Tres
 * author: Alvaro Saburido <hola@alvarosaburido.dev> (https://github.com/alvarosabu/)
 */
var bl = Object.defineProperty;
var El = (o, e, t) => e in o ? bl(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t;
var ce = (o, e, t) => El(o, typeof e != "symbol" ? e + "" : e, t);
import * as Yr from "three";
import { TextureLoader as fi, DoubleSide as tn, AudioListener as sa, Audio as Ml, AudioLoader as ia, Mesh as he, MeshBasicMaterial as Qt, Vector3 as $, FramebufferTexture as Xr, RawShaderMaterial as _i, Color as Pe, Vector2 as ge, AdditiveBlending as wr, Box2 as ra, Vector4 as it, UnsignedByteType as nr, BufferGeometry as pt, InterleavedBuffer as Tr, InterleavedBufferAttribute as Jt, MathUtils as Ze, Line as Le, BufferAttribute as mt, LineBasicMaterial as ws, Box3 as Mt, REVISION as di, CompressedTexture as xi, Texture as es, RGBAFormat as oa, PropertyBinding as nn, InterpolateDiscrete as aa, Matrix4 as Re, Scene as Ts, PlaneGeometry as zt, ShaderMaterial as Lt, Uniform as Me, PerspectiveCamera as At, WebGLRenderer as Sl, InterpolateLinear as br, NearestFilter as la, NearestMipmapNearestFilter as ca, NearestMipmapLinearFilter as ua, LinearFilter as vt, LinearMipmapNearestFilter as ha, LinearMipmapLinearFilter as Er, ClampToEdgeWrapping as ts, RepeatWrapping as kn, MirroredRepeatWrapping as fa, Plane as pi, WebGLRenderTarget as jt, HalfFloatType as Vt, UniformsUtils as ns, NoToneMapping as Al, FrontSide as Ss, UniformsLib as qn, BackSide as Pl, BoxGeometry as Kt, Triangle as Cl, Object3D as Pt, Raycaster as da, Quaternion as ze, Euler as Tn, CylinderGeometry as Ct, Float32BufferAttribute as dt, OctahedronGeometry as Cn, TorusGeometry as Bs, SphereGeometry as Rl, EventDispatcher as pa, Ray as Il, MOUSE as _n, TOUCH as Ht, OrthographicCamera as en, Spherical as oi, ExtrudeGeometry as Ol, Curve as Dl, Loader as As, LoaderUtils as Qn, FileLoader as Bn, MeshPhongMaterial as wi, MeshLambertMaterial as Ll, EquirectangularReflectionMapping as sr, Group as Sn, Bone as ir, PointLight as rr, SpotLight as ma, DirectionalLight as ga, SkinnedMesh as ya, Skeleton as va, AmbientLight as Fl, Uint16BufferAttribute as kl, Matrix3 as Ln, AnimationClip as _a, VectorKeyframeTrack as or, QuaternionKeyframeTrack as ar, NumberKeyframeTrack as lr, ShapePath as gn, DataTextureLoader as Bl, FloatType as si, DataUtils as Ns, ShapeUtils as Nl, Shape as Ul, Path as Ti, AnimationMixer as zl, DepthTexture as xa, CubeTextureLoader as Hl, CubeReflectionMapping as Gl, Sphere as mi, ShapeGeometry as jl, TrianglesDrawMode as Vl, TriangleFanDrawMode as cr, TriangleStripDrawMode as wa, LinearSRGBColorSpace as sn, SRGBColorSpace as bs, MeshPhysicalMaterial as Yt, InstancedMesh as Yl, InstancedBufferAttribute as Xl, ImageBitmapLoader as Wl, PointsMaterial as $l, Material as bi, MeshStandardMaterial as Ps, LineSegments as Zl, LineLoop as Kl, Points as Ta, ColorManagement as Wr, Interpolant as ql, DefaultLoadingManager as Us, VideoTexture as Ql, Clock as Jl, NoBlending as ec, Camera as tc, TangentSpaceNormalMap as nc, InstancedBufferGeometry as sc, InstancedInterleavedBuffer as ur, WireframeGeometry as ic, ShaderLib as ii, Line3 as rc, CatmullRomCurve3 as oc, QuadraticBezierCurve3 as ac, MeshDepthMaterial as $r, DataTexture as ba, UVMapping as lc, IcosahedronGeometry as cc, WebGLCubeRenderTarget as uc, CubeCamera as hc } from "three";
import { defineComponent as me, watch as ee, ref as fe, shallowRef as ye, withAsyncContext as Pn, onUnmounted as rt, openBlock as ue, createElementBlock as de, createElementVNode as _e, unref as U, renderSlot as je, getCurrentScope as fc, onScopeDispose as dc, onMounted as Un, nextTick as Mr, isRef as ai, getCurrentInstance as Ea, computed as Fe, reactive as Es, watchEffect as Ft, mergeProps as Xe, toRefs as De, shallowReactive as Ma, onBeforeUnmount as Sr, useSlots as Ar, toValue as hn, createCommentVNode as rn, isReactive as pc, createBlock as Pr, Fragment as Sa, renderList as Aa, useAttrs as mc, createVNode as zs, render as gc, triggerRef as yc, toRaw as vc } from "vue";
import { useLogger as yt, useLoader as Nn, useTresContext as ve, useLoop as Ke, normalizeVectorFlexibleParam as Pa, normalizeColor as xn, useTexture as li } from "@tresjs/core";
function _c(o) {
  const e = xc(o), t = [];
  for (const { startFrame: n, endFrame: s, duration: i } of e)
    if (!(i <= 0))
      if (s < 0 || n === s) {
        for (let r = 0; r < i; r++)
          t.push(n);
        continue;
      } else {
        const r = Math.sign(s - n);
        for (let a = n; a !== s + r; a += r)
          for (let l = 0; l < i; l++)
            t.push(a);
      }
  return t;
}
function xc(o) {
  let e = "START_FRAME_IN";
  const t = [];
  for (const { name: n, value: s, startI: i } of wc(o))
    e === "START_FRAME_IN" ? n === "NUMBER" ? (t.push({
      startFrame: s,
      endFrame: s,
      duration: 1
    }), e = "START_FRAME_OUT") : Rn(
      "number",
      n,
      o,
      i
    ) : e === "START_FRAME_OUT" ? n === "COMMA" ? e = "START_FRAME_IN" : n === "HYPHEN" ? e = "END_FRAME_IN" : n === "OPEN_PAREN" ? e = "DURATION_IN" : Rn(
      '",", "-", "("',
      n,
      o,
      i
    ) : e === "END_FRAME_IN" ? n === "NUMBER" ? (t[t.length - 1].endFrame = s, e = "END_FRAME_OUT") : Rn(
      "number",
      n,
      o,
      i
    ) : e === "END_FRAME_OUT" ? n === "COMMA" ? e = "START_FRAME_IN" : n === "OPEN_PAREN" ? e = "DURATION_IN" : Rn(
      "',' or '('",
      n,
      o,
      i
    ) : e === "DURATION_IN" ? n === "NUMBER" ? (t[t.length - 1].duration = s, e = "DURATION_OUT") : Rn(
      "number",
      n,
      o,
      i
    ) : e === "DURATION_OUT" ? n === "CLOSE_PAREN" ? e = "NEXT_OR_DONE" : Rn('"("', n, o, i) : e === "NEXT_OR_DONE" && (n === "COMMA" ? e = "START_FRAME_IN" : Rn('","', n, o, i));
  return t;
}
function wc(o) {
  const e = [];
  for (let t = 0; t < o.length; t++) {
    const n = o[t];
    if ("0123456789".includes(n))
      e.length && e[e.length - 1].name === "NUMBER" ? (e[e.length - 1].value *= 10, e[e.length - 1].value += Number.parseInt(n)) : e.push({ name: "NUMBER", value: Number.parseInt(n), startI: t });
    else {
      if (n === " ")
        continue;
      n === "," ? e.push({ name: "COMMA", value: -1, startI: t }) : n === "(" ? e.push({ name: "OPEN_PAREN", value: -1, startI: t }) : n === ")" ? e.push({ name: "CLOSE_PAREN", value: -1, startI: t }) : n === "-" ? e.push({ name: "HYPHEN", value: -1, startI: t }) : Tc("0123456789,-()", n, o, t);
    }
  }
  return e;
}
function Tc(o, e, t, n) {
  yt().logError(
    `Cientos AnimationDefinitionParser: Unexpected character while processing animation definition: expected ${o}, got ${e}.
${t}
${Array.from({ length: n + 1 }).join(" ")}^`
  );
}
function Rn(o, e, t, n) {
  yt().logError(
    `Cientos AnimationDefinitionParser: Syntax error while processing animation definition: expected ${o}, got ${e}.
${t}
${Array.from({ length: n + 1 }).join(" ")}^`
  );
}
const bc = /\d*$/, Ec = /_*\d*$/;
function Mc(o) {
  return o.replace(Ec, "");
}
function Sc(o) {
  const e = o.match(bc);
  return e ? Number.parseInt(e[e.length - 1]) : null;
}
async function Ac(o, e) {
  const t = Nn(
    fi,
    o
  ), n = typeof e != "string" ? new Promise((s) => s(e)) : fetch(e).then((s) => s.json()).catch((s) => yt().logError(`Cientos Atlas - ${s}`));
  return Promise.all([t, n]).then(
    ([s, i]) => {
      const r = Pc(
        i,
        s.image.width,
        s.image.height
      );
      return [s, r];
    }
  );
}
function Pc(o, e, t) {
  const n = typeof o == "number" || Array.isArray(o) ? Oc(o, e, t) : Cc(
    o,
    e,
    t
  );
  return { frames: n, animations: Ca(n) };
}
function ys(o, e, t) {
  let n;
  return typeof e == "string" ? n = Lc(o, e) : typeof e == "number" ? n = Zr(
    o,
    e,
    e
  ) : n = Zr(
    o,
    e[0],
    e[1]
  ), t ? n.toReversed() : n;
}
function Cr() {
  return {
    name: "null",
    width: 0,
    height: 0,
    offsetX: 0,
    offsetY: 0,
    repeatX: 0,
    repeatY: 0
  };
}
function Cc(o, e, t) {
  return Array.isArray(o.frames) ? Rc(
    o,
    e,
    t
  ) : Ic(
    o,
    e,
    t
  );
}
function Rc(o, e, t) {
  const n = 1 / e, s = 1 / t;
  return o.frames.map((i) => ({
    name: i.filename,
    offsetX: i.frame.x * n,
    offsetY: 1 - (i.frame.y + i.frame.h) * s,
    repeatX: i.frame.w * n,
    repeatY: i.frame.h * s,
    width: i.frame.w,
    height: i.frame.h
  }));
}
function Ic(o, e, t) {
  const n = 1 / e, s = 1 / t;
  return Object.entries(o.frames).map(([i, r]) => ({
    name: i,
    offsetX: r.frame.x * n,
    offsetY: 1 - (r.frame.y + r.frame.h) * s,
    repeatX: r.frame.w * n,
    repeatY: r.frame.h * s,
    width: r.frame.w,
    height: r.frame.h
  }));
}
function Oc(o, e, t, n = "default") {
  const [s, i] = Array.isArray(o) ? o : [o, 1], r = e / s, a = t / i, l = (s * i).toString().length, c = 1 / s, h = 1 / i, u = [];
  let p = 0;
  for (let f = i - 1; f >= 0; f--)
    for (let g = 0; g < s; g++)
      p++, u.push({
        name: n + String(p).padStart(l, "0"),
        offsetX: g * c,
        offsetY: f * h,
        repeatX: c,
        repeatY: h,
        width: r,
        height: a
      });
  return u;
}
function Dc(o, e = {}) {
  const t = Ca(o.frames);
  for (const [n, s] of Object.entries(e)) {
    const i = ys(o, n, !1), r = _c(s);
    for (const a of r)
      (a < 0 || i.length <= a) && yt().logError(
        `Cientos Atlas: Attempting to access frame index ${a} in animation ${n}, but it does not exist.`
      );
    t[n] = r.map((a) => i[a]);
  }
  o.animations = t;
}
function Lc(o, e) {
  if (!(e in o.animations)) {
    const t = Object.keys(o.animations).map((n) => `* ${n}
`).join("");
    return yt().logError(
      `Cientos Atlas: getAtlasFramesByAnimationName
The animation name "${e}" does not exist in this atlas.
Available names:
${t}`
    ), [Cr()];
  }
  return o.animations[e];
}
function Zr(o, e, t) {
  if (e < 0 || o.frames.length <= e || t < 0 || o.frames.length <= t)
    return yt().logError(
      `Cientos Atlas: getFramesByIndex – [${e}, ${t}] is out of bounds.`
    ), [Cr()];
  const n = [], s = Math.sign(t - e);
  if (s === 0)
    return [o.frames[e]];
  for (let i = e; i !== t + s; i += s)
    n.push(o.frames[i]);
  return n;
}
function Ca(o) {
  const e = {};
  for (const t of o)
    if (Sc(t.name) !== null) {
      const n = Mc(t.name);
      Object.prototype.hasOwnProperty.call(e, n) ? e[n].push(t) : e[n] = [t];
    }
  for (const t of Object.values(e))
    t.sort((n, s) => n.name.localeCompare(s.name));
  return e;
}
const Fc = ["scale", "position"], kc = ["map", "alphaTest"], Bc = ["scale", "position"], Nc = ["side", "map", "alphaTest", "depthWrite", "depthTest"], Hs = 0.01, mg = /* @__PURE__ */ me({
  __name: "component",
  props: {
    image: {},
    atlas: {},
    definitions: {},
    fps: { default: 30 },
    loop: { type: Boolean, default: !0 },
    animation: { default: 0 },
    paused: { type: Boolean, default: !1 },
    reversed: { type: Boolean, default: !1 },
    flipX: { type: Boolean, default: !1 },
    resetOnEnd: { type: Boolean, default: !1 },
    asSprite: { type: Boolean, default: !0 },
    center: { default: () => [0.5, 0.5] },
    alphaTest: { default: 0 },
    depthTest: { type: Boolean, default: !0 },
    depthWrite: { type: Boolean, default: !0 }
  },
  emits: ["frame", "end", "loop"],
  async setup(o, { expose: e, emit: t }) {
    let n, s;
    const i = o, r = t, { invalidate: a } = ve();
    ee(i, () => {
      a();
    });
    const l = fe(0), c = fe(0), h = fe(0), u = fe(0), p = ye();
    e({ instance: p });
    const [f, g] = ([n, s] = Pn(() => Ac(i.image, i.atlas)), n = await n, s(), n);
    f.matrixAutoUpdate = !1;
    let m = ys(g, i.animation, i.reversed), y = 0.5, d = 0.5, w = 1, v = Cr(), E = null, P = 0, T = !1, b = !0;
    Ke().onBeforeRender(({ delta: M }) => {
      for (!i.paused && !T && (w -= M * i.fps); w <= 0; )
        w++, P++, i.loop ? (P >= m.length && r("loop", m[m.length - 1].name), P %= m.length) : P >= m.length && (T = !0, P = i.resetOnEnd ? 0 : m.length - 1, r("end", m[m.length - 1].name));
      m[P] !== v && (v = m[P], E = v.name, x()), b && (b = !1, f.offset.x = v.offsetX + (i.flipX ? v.repeatX : 0), f.offset.y = v.offsetY, f.repeat.x = v.repeatX * (i.flipX ? -1 : 1), f.repeat.y = v.repeatY, f.updateMatrix(), h.value = v.width * Hs, u.value = v.height * Hs, l.value = (0.5 - y) * v.width * Hs, c.value = (0.5 - d) * v.height * Hs), E && (r("frame", E), E = null);
    });
    function x() {
      b = !0;
    }
    return ee(() => i.animation, (M, _) => {
      JSON.stringify(M) !== JSON.stringify(_) && (m = ys(g, i.animation, i.reversed), P = 0, w = 1, T = !1, x());
    }, { immediate: !0 }), ee(() => i.reversed, () => {
      P = (m.length - P - 1) % m.length, m = ys(g, i.animation, i.reversed), T && (P = i.resetOnEnd ? 0 : m.length - 1), x();
    }), ee(() => i.paused, () => {
      T = !1;
    }), ee(() => i.loop, () => {
      T && i.loop && (T = !1);
    }), ee(() => i.resetOnEnd, () => {
      T && (P = i.resetOnEnd ? 0 : m.length - 1, x());
    }), ee(() => i.flipX, x), ee(() => [i.center], () => {
      [y, d] = Pa(i.center), x();
    }, { immediate: !0 }), ee(() => [i.definitions], () => {
      Dc(g, i.definitions), m = ys(g, i.animation, i.reversed), w = 1, P = 0, x();
    }, { immediate: !0 }), rt(() => {
      f.dispose();
    }), (M, _) => (ue(), de("TresGroup", {
      ref_key: "groupRef",
      ref: p
    }, [
      i.asSprite ? (ue(), de("TresSprite", {
        key: 0,
        scale: [h.value, u.value, 1],
        position: [l.value, c.value, 0]
      }, [
        _e("TresSpriteMaterial", {
          toneMapped: !1,
          map: U(f),
          transparent: !0,
          alphaTest: i.alphaTest
        }, null, 8, kc)
      ], 8, Fc)) : (ue(), de("TresMesh", {
        key: 1,
        scale: [h.value, u.value, 1],
        position: [l.value, c.value, 0]
      }, [
        _[0] || (_[0] = _e("TresPlaneGeometry", { args: [1, 1] }, null, -1)),
        _e("TresMeshBasicMaterial", {
          toneMapped: !1,
          side: U(tn),
          map: U(f),
          transparent: !0,
          alphaTest: i.alphaTest,
          depthWrite: i.depthWrite,
          depthTest: i.depthTest
        }, null, 8, Nc)
      ], 8, Bc)),
      je(M.$slots, "default")
    ], 512));
  }
});
function Rr(o) {
  return fc() ? (dc(o), !0) : !1;
}
function lt(o) {
  return typeof o == "function" ? o() : U(o);
}
const Uc = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const zc = Object.prototype.toString, Hc = (o) => zc.call(o) === "[object Object]", An = () => {
};
function Ir(o, e) {
  function t(...n) {
    return new Promise((s, i) => {
      Promise.resolve(o(() => e.apply(this, n), { fn: e, thisArg: this, args: n })).then(s).catch(i);
    });
  }
  return t;
}
const Gc = (o) => o();
function jc(o, e = {}) {
  let t, n, s = An;
  const i = (a) => {
    clearTimeout(a), s(), s = An;
  };
  return (a) => {
    const l = lt(o), c = lt(e.maxWait);
    return t && i(t), l <= 0 || c !== void 0 && c <= 0 ? (n && (i(n), n = null), Promise.resolve(a())) : new Promise((h, u) => {
      s = e.rejectOnCancel ? u : h, c && !n && (n = setTimeout(() => {
        t && i(t), n = null, h(a());
      }, c)), t = setTimeout(() => {
        n && i(n), n = null, h(a());
      }, l);
    });
  };
}
function Ra(...o) {
  let e = 0, t, n = !0, s = An, i, r, a, l, c;
  !ai(o[0]) && typeof o[0] == "object" ? { delay: r, trailing: a = !0, leading: l = !0, rejectOnCancel: c = !1 } = o[0] : [r, a = !0, l = !0, c = !1] = o;
  const h = () => {
    t && (clearTimeout(t), t = void 0, s(), s = An);
  };
  return (p) => {
    const f = lt(r), g = Date.now() - e, m = () => i = p();
    return h(), f <= 0 ? (e = Date.now(), m()) : (g > f && (l || !n) ? (e = Date.now(), m()) : a && (i = new Promise((y, d) => {
      s = c ? d : y, t = setTimeout(() => {
        e = Date.now(), n = !0, y(m()), h();
      }, Math.max(0, f - g));
    })), !l && !t && (t = setTimeout(() => n = !0, f)), n = !1, i);
  };
}
function Vc(o) {
  return Ea();
}
function Yc(o, e = 200, t = {}) {
  return Ir(
    jc(e, t),
    o
  );
}
function Xc(o, e = 200, t = !1, n = !0, s = !1) {
  return Ir(
    Ra(e, t, n, s),
    o
  );
}
function Wc(o, e, t = {}) {
  const {
    eventFilter: n = Gc,
    ...s
  } = t;
  return ee(
    o,
    Ir(
      n,
      e
    ),
    s
  );
}
function Or(o, e = !0, t) {
  Vc() ? Un(o, t) : e ? o() : Mr(o);
}
function $c(o, e, t = {}) {
  const {
    throttle: n = 0,
    trailing: s = !0,
    leading: i = !0,
    ...r
  } = t;
  return Wc(
    o,
    e,
    {
      ...r,
      eventFilter: Ra(n, s, i)
    }
  );
}
function bn(o) {
  var e;
  const t = lt(o);
  return (e = t == null ? void 0 : t.$el) != null ? e : t;
}
const on = Uc ? window : void 0;
function He(...o) {
  let e, t, n, s;
  if (typeof o[0] == "string" || Array.isArray(o[0]) ? ([t, n, s] = o, e = on) : [e, t, n, s] = o, !e)
    return An;
  Array.isArray(t) || (t = [t]), Array.isArray(n) || (n = [n]);
  const i = [], r = () => {
    i.forEach((h) => h()), i.length = 0;
  }, a = (h, u, p, f) => (h.addEventListener(u, p, f), () => h.removeEventListener(u, p, f)), l = ee(
    () => [bn(e), lt(s)],
    ([h, u]) => {
      if (r(), !h)
        return;
      const p = Hc(u) ? { ...u } : u;
      i.push(
        ...t.flatMap((f) => n.map((g) => a(h, f, g, p)))
      );
    },
    { immediate: !0, flush: "post" }
  ), c = () => {
    l(), r();
  };
  return Rr(c), c;
}
function Zc() {
  const o = fe(!1), e = Ea();
  return e && Un(() => {
    o.value = !0;
  }, e), o;
}
function Ia(o) {
  const e = Zc();
  return Fe(() => (e.value, !!o()));
}
function Kc(o, e = {}) {
  const { window: t = on } = e, n = Ia(() => t && "matchMedia" in t && typeof t.matchMedia == "function");
  let s;
  const i = fe(!1), r = (c) => {
    i.value = c.matches;
  }, a = () => {
    s && ("removeEventListener" in s ? s.removeEventListener("change", r) : s.removeListener(r));
  }, l = Ft(() => {
    n.value && (a(), s = t.matchMedia(lt(o)), "addEventListener" in s ? s.addEventListener("change", r) : s.addListener(r), i.value = s.matches);
  });
  return Rr(() => {
    l(), a(), s = void 0;
  }), i;
}
function qc(o, e, t = {}) {
  const { window: n = on, ...s } = t;
  let i;
  const r = Ia(() => n && "ResizeObserver" in n), a = () => {
    i && (i.disconnect(), i = void 0);
  }, l = Fe(() => {
    const u = lt(o);
    return Array.isArray(u) ? u.map((p) => bn(p)) : [bn(u)];
  }), c = ee(
    l,
    (u) => {
      if (a(), r.value && n) {
        i = new ResizeObserver(e);
        for (const p of u)
          p && i.observe(p, s);
      }
    },
    { immediate: !0, flush: "post" }
  ), h = () => {
    a(), c();
  };
  return Rr(h), {
    isSupported: r,
    stop: h
  };
}
function Qc(o, e = { width: 0, height: 0 }, t = {}) {
  const { window: n = on, box: s = "content-box" } = t, i = Fe(() => {
    var u, p;
    return (p = (u = bn(o)) == null ? void 0 : u.namespaceURI) == null ? void 0 : p.includes("svg");
  }), r = fe(e.width), a = fe(e.height), { stop: l } = qc(
    o,
    ([u]) => {
      const p = s === "border-box" ? u.borderBoxSize : s === "content-box" ? u.contentBoxSize : u.devicePixelContentBoxSize;
      if (n && i.value) {
        const f = bn(o);
        if (f) {
          const g = f.getBoundingClientRect();
          r.value = g.width, a.value = g.height;
        }
      } else if (p) {
        const f = Array.isArray(p) ? p : [p];
        r.value = f.reduce((g, { inlineSize: m }) => g + m, 0), a.value = f.reduce((g, { blockSize: m }) => g + m, 0);
      } else
        r.value = u.contentRect.width, a.value = u.contentRect.height;
    },
    t
  );
  Or(() => {
    const u = bn(o);
    u && (r.value = "offsetWidth" in u ? u.offsetWidth : e.width, a.value = "offsetHeight" in u ? u.offsetHeight : e.height);
  });
  const c = ee(
    () => bn(o),
    (u) => {
      r.value = u ? e.width : 0, a.value = u ? e.height : 0;
    }
  );
  function h() {
    l(), c();
  }
  return {
    width: r,
    height: a,
    stop: h
  };
}
const Kr = 1;
function Jc(o, e = {}) {
  const {
    throttle: t = 0,
    idle: n = 200,
    onStop: s = An,
    onScroll: i = An,
    offset: r = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    },
    eventListenerOptions: a = {
      capture: !1,
      passive: !0
    },
    behavior: l = "auto",
    window: c = on,
    onError: h = (b) => {
      console.error(b);
    }
  } = e, u = fe(0), p = fe(0), f = Fe({
    get() {
      return u.value;
    },
    set(b) {
      m(b, void 0);
    }
  }), g = Fe({
    get() {
      return p.value;
    },
    set(b) {
      m(void 0, b);
    }
  });
  function m(b, x) {
    var M, _, C, R;
    if (!c)
      return;
    const B = lt(o);
    if (!B)
      return;
    (C = B instanceof Document ? c.document.body : B) == null || C.scrollTo({
      top: (M = lt(x)) != null ? M : g.value,
      left: (_ = lt(b)) != null ? _ : f.value,
      behavior: lt(l)
    });
    const N = ((R = B == null ? void 0 : B.document) == null ? void 0 : R.documentElement) || (B == null ? void 0 : B.documentElement) || B;
    f != null && (u.value = N.scrollLeft), g != null && (p.value = N.scrollTop);
  }
  const y = fe(!1), d = Es({
    left: !0,
    right: !1,
    top: !0,
    bottom: !1
  }), w = Es({
    left: !1,
    right: !1,
    top: !1,
    bottom: !1
  }), v = (b) => {
    y.value && (y.value = !1, w.left = !1, w.right = !1, w.top = !1, w.bottom = !1, s(b));
  }, E = Yc(v, t + n), P = (b) => {
    var x;
    if (!c)
      return;
    const M = ((x = b == null ? void 0 : b.document) == null ? void 0 : x.documentElement) || (b == null ? void 0 : b.documentElement) || bn(b), { display: _, flexDirection: C } = getComputedStyle(M), R = M.scrollLeft;
    w.left = R < u.value, w.right = R > u.value;
    const B = Math.abs(R) <= (r.left || 0), N = Math.abs(R) + M.clientWidth >= M.scrollWidth - (r.right || 0) - Kr;
    _ === "flex" && C === "row-reverse" ? (d.left = N, d.right = B) : (d.left = B, d.right = N), u.value = R;
    let j = M.scrollTop;
    b === c.document && !j && (j = c.document.body.scrollTop), w.top = j < p.value, w.bottom = j > p.value;
    const V = Math.abs(j) <= (r.top || 0), Q = Math.abs(j) + M.clientHeight >= M.scrollHeight - (r.bottom || 0) - Kr;
    _ === "flex" && C === "column-reverse" ? (d.top = Q, d.bottom = V) : (d.top = V, d.bottom = Q), p.value = j;
  }, T = (b) => {
    var x;
    if (!c)
      return;
    const M = (x = b.target.documentElement) != null ? x : b.target;
    P(M), y.value = !0, E(b), i(b);
  };
  return He(
    o,
    "scroll",
    t ? Xc(T, t, !0, !1) : T,
    a
  ), Or(() => {
    try {
      const b = lt(o);
      if (!b)
        return;
      P(b);
    } catch (b) {
      h(b);
    }
  }), He(
    o,
    "scrollend",
    v,
    a
  ), {
    x: f,
    y: g,
    isScrolling: y,
    arrivedState: d,
    directions: w,
    measure() {
      const b = lt(o);
      c && b && P(b);
    }
  };
}
const eu = {
  ctrl: "control",
  command: "meta",
  cmd: "meta",
  option: "alt",
  up: "arrowup",
  down: "arrowdown",
  left: "arrowleft",
  right: "arrowright"
};
function tu(o = {}) {
  const {
    reactive: e = !1,
    target: t = on,
    aliasMap: n = eu,
    passive: s = !0,
    onEventFired: i = An
  } = o, r = Es(/* @__PURE__ */ new Set()), a = {
    toJSON() {
      return {};
    },
    current: r
  }, l = e ? Es(a) : a, c = /* @__PURE__ */ new Set(), h = /* @__PURE__ */ new Set();
  function u(m, y) {
    m in l && (e ? l[m] = y : l[m].value = y);
  }
  function p() {
    r.clear();
    for (const m of h)
      u(m, !1);
  }
  function f(m, y) {
    var d, w;
    const v = (d = m.key) == null ? void 0 : d.toLowerCase(), P = [(w = m.code) == null ? void 0 : w.toLowerCase(), v].filter(Boolean);
    v && (y ? r.add(v) : r.delete(v));
    for (const T of P)
      h.add(T), u(T, y);
    v === "meta" && !y ? (c.forEach((T) => {
      r.delete(T), u(T, !1);
    }), c.clear()) : typeof m.getModifierState == "function" && m.getModifierState("Meta") && y && [...r, ...P].forEach((T) => c.add(T));
  }
  He(t, "keydown", (m) => (f(m, !0), i(m)), { passive: s }), He(t, "keyup", (m) => (f(m, !1), i(m)), { passive: s }), He("blur", p, { passive: !0 }), He("focus", p, { passive: !0 });
  const g = new Proxy(
    l,
    {
      get(m, y, d) {
        if (typeof y != "string")
          return Reflect.get(m, y, d);
        if (y = y.toLowerCase(), y in n && (y = n[y]), !(y in l))
          if (/[+_-]/.test(y)) {
            const v = y.split(/[+_-]/g).map((E) => E.trim());
            l[y] = Fe(() => v.every((E) => lt(g[E])));
          } else
            l[y] = fe(!1);
        const w = Reflect.get(m, y, d);
        return e ? lt(w) : w;
      }
    }
  );
  return g;
}
const nu = {
  page: (o) => [o.pageX, o.pageY],
  client: (o) => [o.clientX, o.clientY],
  screen: (o) => [o.screenX, o.screenY],
  movement: (o) => o instanceof Touch ? null : [o.movementX, o.movementY]
};
function su(o = {}) {
  const {
    type: e = "page",
    touch: t = !0,
    resetOnTouchEnds: n = !1,
    initialValue: s = { x: 0, y: 0 },
    window: i = on,
    target: r = i,
    scroll: a = !0,
    eventFilter: l
  } = o;
  let c = null;
  const h = fe(s.x), u = fe(s.y), p = fe(null), f = typeof e == "function" ? e : nu[e], g = (P) => {
    const T = f(P);
    c = P, T && ([h.value, u.value] = T, p.value = "mouse");
  }, m = (P) => {
    if (P.touches.length > 0) {
      const T = f(P.touches[0]);
      T && ([h.value, u.value] = T, p.value = "touch");
    }
  }, y = () => {
    if (!c || !i)
      return;
    const P = f(c);
    c instanceof MouseEvent && P && (h.value = P[0] + i.scrollX, u.value = P[1] + i.scrollY);
  }, d = () => {
    h.value = s.x, u.value = s.y;
  }, w = l ? (P) => l(() => g(P), {}) : (P) => g(P), v = l ? (P) => l(() => m(P), {}) : (P) => m(P), E = l ? () => l(() => y(), {}) : () => y();
  if (r) {
    const P = { passive: !0 };
    He(r, ["mousemove", "dragover"], w, P), t && e !== "movement" && (He(r, ["touchstart", "touchmove"], v, P), n && He(r, "touchend", d, P)), a && e === "page" && He(i, "scroll", E, { passive: !0 });
  }
  return {
    x: h,
    y: u,
    sourceType: p
  };
}
function iu(o = {}) {
  const { window: e = on, behavior: t = "auto" } = o;
  if (!e)
    return {
      x: fe(0),
      y: fe(0)
    };
  const n = fe(e.scrollX), s = fe(e.scrollY), i = Fe({
    get() {
      return n.value;
    },
    set(a) {
      scrollTo({ left: a, behavior: t });
    }
  }), r = Fe({
    get() {
      return s.value;
    },
    set(a) {
      scrollTo({ top: a, behavior: t });
    }
  });
  return He(
    e,
    "scroll",
    () => {
      n.value = e.scrollX, s.value = e.scrollY;
    },
    {
      capture: !1,
      passive: !0
    }
  ), { x: i, y: r };
}
function Oa(o = {}) {
  const {
    window: e = on,
    initialWidth: t = Number.POSITIVE_INFINITY,
    initialHeight: n = Number.POSITIVE_INFINITY,
    listenOrientation: s = !0,
    includeScrollbar: i = !0,
    type: r = "inner"
  } = o, a = fe(t), l = fe(n), c = () => {
    e && (r === "outer" ? (a.value = e.outerWidth, l.value = e.outerHeight) : i ? (a.value = e.innerWidth, l.value = e.innerHeight) : (a.value = e.document.documentElement.clientWidth, l.value = e.document.documentElement.clientHeight));
  };
  if (c(), Or(c), He("resize", c, { passive: !0 }), s) {
    const h = Kc("(orientation: portrait)");
    ee(h, () => c());
  }
  return { width: a, height: l };
}
const gg = me({
  name: "GlobalAudio",
  props: [
    "src",
    "loop",
    "volume",
    "playbackRate",
    "playTrigger",
    "stopTrigger"
  ],
  async setup(o, { expose: e, emit: t }) {
    var u;
    const { camera: n, renderer: s } = ve(), i = new sa();
    (u = n.value) == null || u.add(i);
    const r = new Ml(i), a = new ia();
    e({ instance: r }), rt(() => {
      r && r.disconnect();
    }), ee(() => [o.playbackRate], () => r.setPlaybackRate(o.playbackRate ?? 1), { immediate: !0 }), ee(() => [o.volume], () => r.setVolume(o.volume ?? 0.5), { immediate: !0 }), ee(() => [o.loop], () => r.setLoop(o.loop ?? !1), { immediate: !0 }), ee(() => [o.src], async () => {
      const p = await a.loadAsync(o.src);
      r.setBuffer(p);
    }, { immediate: !0 });
    const c = document.getElementById(o.playTrigger ?? "") || s.value.domElement;
    He(c, "click", () => {
      r.isPlaying ? r.pause() : r.play(), t("isPlaying", r.isPlaying);
    });
    const h = document.getElementById(o.stopTrigger ?? "");
    return h && He(h, "click", () => {
      r.stop(), t("isPlaying", r.isPlaying);
    }), null;
  }
});
class Ms extends he {
  constructor() {
    super(Ms.Geometry, new Qt({ opacity: 0, transparent: !0 })), this.isLensflare = !0, this.type = "Lensflare", this.frustumCulled = !1, this.renderOrder = 1 / 0;
    const e = new $(), t = new $(), n = new Xr(16, 16), s = new Xr(16, 16);
    let i = nr;
    const r = Ms.Geometry, a = new _i({
      uniforms: {
        scale: { value: null },
        screenPosition: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				precision highp float;

				uniform vec3 screenPosition;
				uniform vec2 scale;

				attribute vec3 position;

				void main() {

					gl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );

				}`
      ),
      fragmentShader: (
        /* glsl */
        `

				precision highp float;

				void main() {

					gl_FragColor = vec4( 1.0, 0.0, 1.0, 1.0 );

				}`
      ),
      depthTest: !0,
      depthWrite: !1,
      transparent: !1
    }), l = new _i({
      uniforms: {
        map: { value: n },
        scale: { value: null },
        screenPosition: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				precision highp float;

				uniform vec3 screenPosition;
				uniform vec2 scale;

				attribute vec3 position;
				attribute vec2 uv;

				varying vec2 vUV;

				void main() {

					vUV = uv;

					gl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );

				}`
      ),
      fragmentShader: (
        /* glsl */
        `

				precision highp float;

				uniform sampler2D map;

				varying vec2 vUV;

				void main() {

					gl_FragColor = texture2D( map, vUV );

				}`
      ),
      depthTest: !1,
      depthWrite: !1,
      transparent: !1
    }), c = new he(r, a), h = [], u = Da.Shader, p = new _i({
      name: u.name,
      uniforms: {
        map: { value: null },
        occlusionMap: { value: s },
        color: { value: new Pe(16777215) },
        scale: { value: new ge() },
        screenPosition: { value: new $() }
      },
      vertexShader: u.vertexShader,
      fragmentShader: u.fragmentShader,
      blending: wr,
      transparent: !0,
      depthWrite: !1
    }), f = new he(r, p);
    this.addElement = function(w) {
      h.push(w);
    };
    const g = new ge(), m = new ge(), y = new ra(), d = new it();
    this.onBeforeRender = function(w, v, E) {
      w.getCurrentViewport(d);
      const P = w.getRenderTarget(), T = P !== null ? P.texture.type : nr;
      i !== T && (n.dispose(), s.dispose(), n.type = s.type = T, i = T);
      const b = d.w / d.z, x = d.z / 2, M = d.w / 2;
      let _ = 16 / d.w;
      if (g.set(_ * b, _), y.min.set(d.x, d.y), y.max.set(d.x + (d.z - 16), d.y + (d.w - 16)), t.setFromMatrixPosition(this.matrixWorld), t.applyMatrix4(E.matrixWorldInverse), !(t.z > 0) && (e.copy(t).applyMatrix4(E.projectionMatrix), m.x = d.x + e.x * x + x - 8, m.y = d.y + e.y * M + M - 8, y.containsPoint(m))) {
        w.copyFramebufferToTexture(n, m);
        let C = a.uniforms;
        C.scale.value = g, C.screenPosition.value = e, w.renderBufferDirect(E, null, r, a, c, null), w.copyFramebufferToTexture(s, m), C = l.uniforms, C.scale.value = g, C.screenPosition.value = e, w.renderBufferDirect(E, null, r, l, c, null);
        const R = -e.x * 2, B = -e.y * 2;
        for (let N = 0, j = h.length; N < j; N++) {
          const V = h[N], Q = p.uniforms;
          Q.color.value.copy(V.color), Q.map.value = V.texture, Q.screenPosition.value.x = e.x + R * V.distance, Q.screenPosition.value.y = e.y + B * V.distance, _ = V.size / d.w;
          const Z = d.w / d.z;
          Q.scale.value.set(_ * Z, _), p.uniformsNeedUpdate = !0, w.renderBufferDirect(E, null, r, p, f, null);
        }
      }
    }, this.dispose = function() {
      a.dispose(), l.dispose(), p.dispose(), n.dispose(), s.dispose();
      for (let w = 0, v = h.length; w < v; w++)
        h[w].texture.dispose();
    };
  }
}
class Da {
  constructor(e, t = 1, n = 0, s = new Pe(16777215)) {
    this.texture = e, this.size = t, this.distance = n, this.color = s;
  }
}
Da.Shader = {
  name: "LensflareElementShader",
  uniforms: {
    map: { value: null },
    occlusionMap: { value: null },
    color: { value: null },
    scale: { value: null },
    screenPosition: { value: null }
  },
  vertexShader: (
    /* glsl */
    `

		precision highp float;

		uniform vec3 screenPosition;
		uniform vec2 scale;

		uniform sampler2D occlusionMap;

		attribute vec3 position;
		attribute vec2 uv;

		varying vec2 vUV;
		varying float vVisibility;

		void main() {

			vUV = uv;

			vec2 pos = position.xy;

			vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );
			visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );
			visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );
			visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );
			visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );
			visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );
			visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );
			visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );
			visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );

			vVisibility =        visibility.r / 9.0;
			vVisibility *= 1.0 - visibility.g / 9.0;
			vVisibility *=       visibility.b / 9.0;

			gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		precision highp float;

		uniform sampler2D map;
		uniform vec3 color;

		varying vec2 vUV;
		varying float vVisibility;

		void main() {

			vec4 texture = texture2D( map, vUV );
			texture.a *= vVisibility;
			gl_FragColor = texture;
			gl_FragColor.rgb *= color;

		}`
  )
};
Ms.Geometry = function() {
  const o = new pt(), e = new Float32Array([
    -1,
    -1,
    0,
    0,
    0,
    1,
    -1,
    0,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    -1,
    1,
    0,
    0,
    1
  ]), t = new Tr(e, 5);
  return o.setIndex([0, 1, 2, 0, 2, 3]), o.setAttribute("position", new Jt(t, 3, 0, !1)), o.setAttribute("uv", new Jt(t, 2, 3, !1)), o;
}();
function ru(o) {
  return o;
}
function ou(o) {
  return o * o * o;
}
function au(o) {
  return o < 0.5 ? 4 * o * o * o : 1 - (-2 * o + 2) ** 3 / 2;
}
function lu(o) {
  return o * o * o * o;
}
function cu(o) {
  return o < 1 / 2.75 ? 7.5625 * o * o : o < 2 / 2.75 ? 7.5625 * (o -= 1.5 / 2.75) * o + 0.75 : o < 2.5 / 2.75 ? 7.5625 * (o -= 2.25 / 2.75) * o + 0.9375 : 7.5625 * (o -= 2.625 / 2.75) * o + 0.984375;
}
const an = "https://raw.githubusercontent.com/Tresjs/assets/93976c7d63ac83d4a254a41a10b2362bc17e90c9/textures/lensflare/", Dr = `${an}circle.png`, gi = `${an}circleBlur.png`, uu = `${an}circleRainbow.png`, hu = `${an}line.png`, La = `${an}poly6.png`, Fa = `${an}polyStroke6.png`, fu = `${an}rays.png`, yi = `${an}ring.png`, du = `${an}starThin6.png`, pu = {
  texture: [hu, yi],
  color: ["white"],
  distance: [0, 0],
  size: [750, 1024],
  length: [0, 2]
}, mu = {
  texture: [gi],
  color: ["white"],
  distance: [0, 0],
  size: [180, 512],
  length: [1, 1]
}, gu = {
  texture: [fu],
  color: ["white"],
  distance: [0, 0],
  size: [180, 512],
  length: [1, 1]
}, yu = {
  texture: [Dr, uu, yi, du],
  color: ["white"],
  distance: [0, 0],
  size: [180, 512],
  length: [2, 3]
}, [ka, Ba] = [3679071, 132442], vu = {
  texture: [gi, Dr, yi, La, Fa],
  color: ["dimgray", "gray", "darkgray", ka, Ba],
  distance: [0.5, 2.5],
  size: [20, 180],
  length: [5, 21]
}, _u = {
  texture: [gi, Dr, yi, La, Fa],
  color: ["dimgray", "gray", "darkgray", ka, Ba],
  distance: [-0.6, -0.1],
  size: [180, 360],
  length: [0, 5]
}, hr = [pu, mu, gu, yu, vu, _u], ci = {
  color: "white",
  distance: 0,
  size: 512,
  texture: gi
}, qr = Ze.clamp;
class Qr {
  /**
   * Create a new seeded pseudorandom number generator.
   * @param [seed] - the seed for the generator
   * @param [getSeededRandomGenerator] - a function that returns a pseudorandom number generator
   * @constructor
   */
  constructor(e = 0, t) {
    ce(this, "_getNext");
    ce(this, "_getGenerator");
    this._getGenerator = t ?? this.getMulberry32, this._getNext = this._getGenerator(e);
  }
  /**
   * Reseed the pseudorandom number generator
   */
  seed(e) {
    this._getNext = this._getGenerator(e);
  }
  /**
   * Return the next pseudorandom number in the interval [0, 1]
   */
  rand() {
    return this._getNext();
  }
  /**
   * Random float from <low, high> interval
   * @param low - Low value of the interval
   * @param high - High value of the interval
   */
  float(e, t) {
    return e + this._getNext() * (t - e);
  }
  /**
   * Random float from <-range/2, range/2> interval
   * @param range - Interval range
   */
  floatSpread(e) {
    return this.float(-0.5 * e, 0.5 * e);
  }
  /**
   * Random integer from <low, high> interval
   * @param low Low value of the interval
   * @param high High value of the interval
   */
  int(e, t) {
    return e + Math.floor(this._getNext() * (t - e + 1));
  }
  /**
   * Choose an element from an array.
   * @param array The array to choose from
   * @returns An element from the array or null if the array is empty
   */
  choice(e) {
    return e.length ? e[Math.floor(this._getNext() * e.length)] : null;
  }
  /**
   * Choose an element from an array or return defaultValue if array is empty.
   * @param array The array to choose from
   * @param defaultValue The value to return if the array is empty
   * @returns An element from the array or defaultValue if the array is empty
   */
  defaultChoice(e, t) {
    return e.length ? e[Math.floor(this._getNext() * e.length)] : t;
  }
  /**
   * Return n elements from an array.
   * @param array The array to sample
   * @param sampleSizeMin The minimum sample size
   * @param sampleSizeMax The maximum sample size
   */
  sample(e, t, n) {
    const s = e.length;
    t = qr(t, 0, s - 1), n = qr(n ?? s - 1, 0, s - 1);
    const i = this.int(t, n), r = this.shuffle(e.map((l, c) => c)), a = Math.min(e.length, i);
    return r.slice(0, a).sort().map((l) => e[l]);
  }
  /**
   * Shuffle an array. Not in-place.
   * @param array The array to shuffle
   */
  shuffle(e) {
    return e.map((t) => ({ value: t, sort: this._getNext() })).sort((t, n) => t.sort - n.sort).map(({ value: t }) => t);
  }
  /**
   * The default pseudorandom generator.
   */
  getMulberry32(e = 0) {
    return e > 0 && e < 1 && (e = Math.floor(e * 2 ** 16)), () => {
      e += 1831565813;
      let t = e;
      return t = Math.imul(t ^ t >>> 15, t | 1), t ^= t + Math.imul(t ^ t >>> 7, t | 61), ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
  }
}
const xu = [
  ru,
  ou,
  au,
  lu,
  cu
], Jr = Ze.lerp, eo = (o = 0, e = hr) => {
  const n = new Qr(o).choice(xu);
  return e.map((s, i) => {
    const r = new Qr(
      o * (i * 7907 + 1) + (typeof s.seed == "number" ? s.seed : 0)
    ), a = r.int(s.length[0], s.length[1]);
    return Array.from({ length: a }).fill(0).map(() => {
      const l = n(r.rand());
      return {
        texture: r.defaultChoice(
          s.texture,
          ci.texture
        ),
        size: Jr(s.size[0], s.size[1], n(1 - l)),
        distance: Jr(s.distance[0], s.distance[1], l),
        color: r.defaultChoice(
          s.color,
          ci.color
        )
      };
    });
  }).flat();
}, to = (o, e, t = void 0, n = void 0, s = ci) => {
  if (o !== void 0 && o.length > 0 && (typeof t == "number" || typeof n < "u")) {
    const a = eo(t ?? 0, n ?? hr), l = a.length, c = o.length;
    return l >= c ? a.map(
      (h, u) => Object.assign(h, e, u < c ? o[u] : {})
    ) : o.map(
      (h, u) => Object.assign({}, s, u < l ? a[u] : {}, e, h)
    );
  }
  if (o !== void 0 && o.length > 0) {
    const a = Object.assign({}, s, e);
    return o.map((l) => Object.assign({}, a, l));
  }
  const i = n === void 0 || n.length === 0 ? hr : n;
  return eo(t ?? 0, i).map((a) => Object.assign({}, a, e));
};
function wu(o) {
  return Tu(o, (e, t) => t in ci && e !== void 0);
}
function Tu(o, e) {
  const t = {};
  return Object.keys(o).forEach((n) => {
    e(o[n], n) && (t[n] = o[n]);
  }), t;
}
const yg = /* @__PURE__ */ me({
  __name: "component",
  props: {
    scale: { default: 1 },
    elements: { default: void 0 },
    seed: { default: void 0 },
    seedProps: { default: void 0 },
    color: { default: void 0 },
    distance: { default: void 0 },
    size: { default: void 0 },
    texture: { default: void 0 }
  },
  setup(o, { expose: e }) {
    const t = o, n = ye(), s = ye([]), i = ye(wu(t));
    e({
      instance: n
    });
    const r = new fi(), a = new Ms(), l = [], c = () => {
      var f, g, m;
      for (; l.length; )
        l.pop();
      (f = n.value) == null || f.children.forEach((y) => {
        "dispose" in y && y.dispose();
      }), (g = n.value) == null || g.remove(...n.value.children), (m = n.value) == null || m.dispose();
    }, h = (f) => {
      if (typeof f.texture == "string") {
        const g = f.texture;
        f.texture = r.load(g), f.texture.name = g;
      }
      return f.color = xn(f.color), f;
    }, u = () => {
      for (let f = s.value.length - 1; f < l.length; f++)
        l[f].size = 0;
      s.value.forEach((f, g) => {
        l[g].size = f.size * t.scale;
      });
    }, p = () => {
      for (; s.value.length > l.length; ) {
        const g = { ...h(s.value[l.length]) };
        l.push(g), a.addElement(g);
      }
      s.value.forEach((f, g) => {
        const m = l[g], { texture: y, size: d, distance: w, color: v } = f;
        if (typeof y == "string") {
          if (m.texture.name !== y) {
            m.texture.dispose();
            const E = y;
            m.texture = r.load(E), m.texture.name = E;
          }
        } else
          m.texture !== y && (m.texture.dispose(), m.texture = y);
        m.size = d, m.distance = w, m.color = xn(v);
      }), u();
    };
    return rt(() => {
      c();
    }), Un(() => {
      var f;
      (f = n.value) == null || f.add(a), s.value = to(t.elements, i.value, t.seed, t.seedProps);
    }), ee(() => [t.color, t.distance, t.size, t.texture], () => {
      i.value = {
        color: t.color,
        distance: t.distance,
        size: t.size,
        texture: t.texture
      };
    }), ee(() => [i.value, t.elements, t.seed, t.seedProps], () => {
      s.value = to(t.elements, i.value, t.seed, t.seedProps);
    }), ee(() => t.scale, () => {
      u();
    }), ee(() => s.value, () => {
      p();
    }), (f, g) => (ue(), de("TresGroup", {
      ref_key: "lensflareRef",
      ref: n
    }, null, 512));
  }
}), vg = /* @__PURE__ */ me({
  __name: "Levioso",
  props: {
    speed: { default: 1 },
    rotationFactor: { default: 1 },
    floatFactor: { default: 1 },
    range: { default: () => [-0.1, 0.1] }
  },
  setup(o, { expose: e }) {
    const t = o, n = ye();
    e({
      instance: n
    });
    {
      const l = Math.random() * 1e4, { onBeforeRender: c } = Ke();
      let h = l;
      c(({ delta: u, invalidate: p }) => {
        if (!n.value)
          return;
        h += u * t.speed;
        const f = h * 0.25, g = n.value;
        g.rotation.x = Math.cos(f) * 0.125 * t.rotationFactor, g.rotation.y = Math.sin(f) * 0.125 * t.rotationFactor, g.rotation.z = Math.sin(f) * 0.05 * t.rotationFactor, g.position.y = Ze.mapLinear(Math.sin(f), -1, 1, t.range[0], t.range[1]) * t.floatFactor, p();
      });
    }
    return (s, i) => (ue(), de("TresGroup", Xe(s.$attrs, {
      ref_key: "groupRef",
      ref: n
    }), [
      je(s.$slots, "default")
    ], 16));
  }
}), _g = /* @__PURE__ */ me({
  __name: "MouseParallax",
  props: {
    disabled: { type: Boolean, default: !1 },
    factor: { default: 2.5 },
    ease: { default: 0.1 },
    local: { type: Boolean, default: !1 }
  },
  setup(o) {
    const e = o, { camera: t, renderer: n } = ve(), { disabled: s, factor: i, ease: r, local: a } = De(e), l = {};
    a.value && (l.target = n.value.domElement, l.type = "client");
    const { x: c, y: h } = su(l), { width: u, height: p } = a.value ? Qc(n.value.domElement) : Oa(), f = ye(), g = fe(), m = fe();
    ee(
      [i, r],
      () => {
        g.value = Array.isArray(i.value) ? i.value : [i.value, i.value], m.value = Array.isArray(r.value) ? r.value : [r.value, r.value];
      },
      { immediate: !0 }
    );
    const y = Fe(() => (c.value / u.value - 0.5) * g.value[0]), d = Fe(() => -(h.value / p.value - 0.5) * g.value[1]), { onBeforeRender: w } = Ke();
    return w(({ delta: v, invalidate: E }) => {
      s.value || !f.value || Number.isNaN(y.value) || Number.isNaN(d.value) || (f.value.position.x += (y.value - f.value.position.x) * m.value[0] * v, f.value.position.y += (d.value - f.value.position.y) * m.value[1] * v, E());
    }), ee(
      () => f.value,
      (v) => v == null ? void 0 : v.add(t.value)
    ), (v, E) => (ue(), de("TresGroup", {
      ref_key: "cameraGroupRef",
      ref: f
    }, null, 512));
  }
});
class bu extends Le {
  constructor(e, t = 1, n = 16, s = 2) {
    const i = new pt(), r = n + s * 2, a = new Float32Array((r * 3 + 3) * 3);
    i.setAttribute("position", new mt(a, 3));
    const l = new ws({ color: 65280 }), c = new ws({ color: 16776960 });
    super(i, [c, l]), this.audio = e, this.range = t, this.divisionsInnerAngle = n, this.divisionsOuterAngle = s, this.type = "PositionalAudioHelper", this.update();
  }
  update() {
    const e = this.audio, t = this.range, n = this.divisionsInnerAngle, s = this.divisionsOuterAngle, i = Ze.degToRad(e.panner.coneInnerAngle), r = Ze.degToRad(e.panner.coneOuterAngle), a = i / 2, l = r / 2;
    let c = 0, h = 0, u, p;
    const f = this.geometry, g = f.attributes.position;
    f.clearGroups();
    function m(y, d, w, v) {
      const E = (d - y) / w;
      for (g.setXYZ(c, 0, 0, 0), h++, u = y; u < d; u += E)
        p = c + h, g.setXYZ(p, Math.sin(u) * t, 0, Math.cos(u) * t), g.setXYZ(p + 1, Math.sin(Math.min(u + E, d)) * t, 0, Math.cos(Math.min(u + E, d)) * t), g.setXYZ(p + 2, 0, 0, 0), h += 3;
      f.addGroup(c, h, v), c += h, h = 0;
    }
    m(-l, -a, s, 0), m(-a, a, n, 1), m(a, l, s, 0), g.needsUpdate = !0, i === r && (this.material[0].visible = !1);
  }
  dispose() {
    this.geometry.dispose(), this.material[0].dispose(), this.material[1].dispose();
  }
}
const Eu = ["args"], xg = /* @__PURE__ */ me({
  __name: "PositionalAudio",
  props: {
    ready: { type: Boolean, default: !1 },
    url: {},
    distance: { default: 2 },
    helper: { type: Boolean, default: !1 },
    loop: { type: Boolean, default: !1 },
    autoplay: { type: Boolean, default: !1 },
    innerAngle: { default: 360 },
    outerAngle: { default: 360 },
    outerGain: { default: 0 }
  },
  emits: ["isPlaying"],
  async setup(o, { expose: e, emit: t }) {
    let n, s;
    const i = o, r = t, { ready: a, url: l, distance: c, helper: h, loop: u, autoplay: p, innerAngle: f, outerAngle: g, outerGain: m } = De(i), { camera: y } = ve(), d = ye(null), w = ye(null), v = ye(null), E = Ma(new sa()), P = () => {
      var B, N, j;
      (B = d == null ? void 0 : d.value) != null && B.isPlaying || ((N = d == null ? void 0 : d.value) == null || N.play(), r("isPlaying", (j = d == null ? void 0 : d.value) == null ? void 0 : j.isPlaying));
    }, T = () => {
      var B, N;
      (B = d == null ? void 0 : d.value) != null && B.isPlaying && (d.value.pause(), r("isPlaying", (N = d == null ? void 0 : d.value) == null ? void 0 : N.isPlaying));
    }, b = () => {
      var B;
      d.value && (d.value.stop(), r("isPlaying", (B = d == null ? void 0 : d.value) == null ? void 0 : B.isPlaying));
    }, x = () => {
      if (!(d != null && d.value))
        return;
      b();
      const B = d.value;
      B.source && B.disconnect();
    }, M = () => {
      var B, N;
      !(d != null && d.value) || !(w != null && w.value) || ((B = w == null ? void 0 : w.value) == null || B.dispose(), (N = d == null ? void 0 : d.value) == null || N.remove(w == null ? void 0 : w.value));
    }, _ = () => {
      var B;
      if (d.value && (d.value.setBuffer(v.value), d.value.setRefDistance(c.value), d.value.setLoop(u.value), d.value.setDirectionalCone(f.value, g.value, m.value), (B = w == null ? void 0 : w.value) == null || B.update(), w != null && w.value)) {
        const N = w.value.material[0];
        !N.visible && g.value !== f.value && (N.visible = !0);
      }
    }, C = () => {
      var V, Q;
      _();
      const B = (V = d.value) == null ? void 0 : V.parent, N = new Mt().setFromObject(B), j = (N.max.z - N.min.z) * 2;
      w.value = new bu(d.value, j, 32, 16), (Q = d == null ? void 0 : d.value) == null || Q.add(w.value), w.value.update();
    }, R = () => {
      var B;
      (B = y == null ? void 0 : y.value) == null || B.remove(E), x(), M();
    };
    return e({
      root: d,
      play: P,
      stop: b,
      pause: T,
      dispose: R
    }), v.value = ([n, s] = Pn(() => Nn(ia, l.value)), n = await n, s(), n), ee(d, () => {
      d != null && d.value && (h.value && C(), a.value && p && P());
    }), ee(h, () => {
      h.value ? C() : M();
    }), ee(a, () => {
      a.value && _(), p.value && a.value && P(), !p.value && a.value && b();
    }), ee([c, u, v, f, g, m, p], () => {
      _();
    }), Un(() => {
      var B;
      (B = y == null ? void 0 : y.value) == null || B.add(E);
    }), Sr(() => {
      R();
    }), (B, N) => (ue(), de("TresPositionalAudio", Xe({
      ref_key: "positionalAudioRef",
      ref: d,
      args: [U(E)]
    }, B.$attrs), null, 16, Eu));
  }
}), vi = parseInt(di.replace(/\D+/g, "")), Mu = vi >= 125 ? "uv1" : "uv2";
var Su = Object.defineProperty, Au = (o, e, t) => e in o ? Su(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, Pu = (o, e, t) => (Au(o, e + "", t), t);
async function no(o) {
  const e = await o.arrayBuffer(), t = btoa(String.fromCharCode(...new Uint8Array(e)));
  return `data:${o.type || ""};base64,${t}`;
}
let Gs, Ei, zn, js;
function Mi(o, e = 1 / 0, t = null) {
  Ei || (Ei = new zt(2, 2, 1, 1)), zn || (zn = new Lt({
    uniforms: { blitTexture: new Me(o) },
    vertexShader: (
      /* glsl */
      `
        varying vec2 vUv;
        void main(){
            vUv = uv;
            gl_Position = vec4(position.xy * 1.0,0.,.999999);
        }
      `
    ),
    fragmentShader: (
      /* glsl */
      `
          uniform sampler2D blitTexture; 
          varying vec2 vUv;

          void main(){ 
              gl_FragColor = vec4(vUv.xy, 0, 1);
              
              #ifdef IS_SRGB
              gl_FragColor = LinearTosRGB( texture2D( blitTexture, vUv) );
              #else
              gl_FragColor = texture2D( blitTexture, vUv);
              #endif
          }
      `
    )
  })), zn.uniforms.blitTexture.value = o, zn.defines.IS_SRGB = "colorSpace" in o ? o.colorSpace === "srgb" : o.encoding === 3001, zn.needsUpdate = !0, js || (js = new he(Ei, zn), js.frustrumCulled = !1);
  const n = new At(), s = new Ts();
  s.add(js), t || (t = Gs = new Sl({ antialias: !1 })), t.setSize(Math.min(o.image.width, e), Math.min(o.image.height, e)), t.clear(), t.render(s, n);
  const i = new es(t.domElement);
  return i.minFilter = o.minFilter, i.magFilter = o.magFilter, i.wrapS = o.wrapS, i.wrapT = o.wrapT, i.name = o.name, Gs && (Gs.dispose(), Gs = null), i;
}
const so = {
  POSITION: [
    "byte",
    "byte normalized",
    "unsigned byte",
    "unsigned byte normalized",
    "short",
    "short normalized",
    "unsigned short",
    "unsigned short normalized"
  ],
  NORMAL: ["byte normalized", "short normalized"],
  TANGENT: ["byte normalized", "short normalized"],
  TEXCOORD: ["byte", "byte normalized", "unsigned byte", "short", "short normalized", "unsigned short"]
};
class Lr {
  constructor() {
    this.pluginCallbacks = [], this.register(function(e) {
      return new Nu(e);
    }), this.register(function(e) {
      return new Uu(e);
    }), this.register(function(e) {
      return new Gu(e);
    }), this.register(function(e) {
      return new ju(e);
    }), this.register(function(e) {
      return new Vu(e);
    }), this.register(function(e) {
      return new Yu(e);
    }), this.register(function(e) {
      return new zu(e);
    }), this.register(function(e) {
      return new Hu(e);
    }), this.register(function(e) {
      return new Xu(e);
    }), this.register(function(e) {
      return new Wu(e);
    }), this.register(function(e) {
      return new $u(e);
    });
  }
  register(e) {
    return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this;
  }
  unregister(e) {
    return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this;
  }
  /**
   * Parse scenes and generate GLTF output
   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes
   * @param  {Function} onDone  Callback on completed
   * @param  {Function} onError  Callback on errors
   * @param  {Object} options options
   */
  parse(e, t, n, s) {
    const i = new Bu(), r = [];
    for (let a = 0, l = this.pluginCallbacks.length; a < l; a++)
      r.push(this.pluginCallbacks[a](i));
    i.setPlugins(r), i.write(e, t, s).catch(n);
  }
  parseAsync(e, t) {
    const n = this;
    return new Promise(function(s, i) {
      n.parse(e, s, i, t);
    });
  }
}
Pu(Lr, "Utils", {
  insertKeyframe: function(o, e) {
    const n = o.getValueSize(), s = new o.TimeBufferType(o.times.length + 1), i = new o.ValueBufferType(o.values.length + n), r = o.createInterpolant(new o.ValueBufferType(n));
    let a;
    if (o.times.length === 0) {
      s[0] = e;
      for (let l = 0; l < n; l++)
        i[l] = 0;
      a = 0;
    } else if (e < o.times[0]) {
      if (Math.abs(o.times[0] - e) < 1e-3)
        return 0;
      s[0] = e, s.set(o.times, 1), i.set(r.evaluate(e), 0), i.set(o.values, n), a = 0;
    } else if (e > o.times[o.times.length - 1]) {
      if (Math.abs(o.times[o.times.length - 1] - e) < 1e-3)
        return o.times.length - 1;
      s[s.length - 1] = e, s.set(o.times, 0), i.set(o.values, 0), i.set(r.evaluate(e), o.values.length), a = s.length - 1;
    } else
      for (let l = 0; l < o.times.length; l++) {
        if (Math.abs(o.times[l] - e) < 1e-3)
          return l;
        if (o.times[l] < e && o.times[l + 1] > e) {
          s.set(o.times.slice(0, l + 1), 0), s[l + 1] = e, s.set(o.times.slice(l + 1), l + 2), i.set(o.values.slice(0, (l + 1) * n), 0), i.set(r.evaluate(e), (l + 1) * n), i.set(o.values.slice((l + 1) * n), (l + 2) * n), a = l + 1;
          break;
        }
      }
    return o.times = s, o.values = i, a;
  },
  mergeMorphTargetTracks: function(o, e) {
    const t = [], n = {}, s = o.tracks;
    for (let i = 0; i < s.length; ++i) {
      let r = s[i];
      const a = nn.parseTrackName(r.name), l = nn.findNode(e, a.nodeName);
      if (a.propertyName !== "morphTargetInfluences" || a.propertyIndex === void 0) {
        t.push(r);
        continue;
      }
      if (r.createInterpolant !== r.InterpolantFactoryMethodDiscrete && r.createInterpolant !== r.InterpolantFactoryMethodLinear) {
        if (r.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline)
          throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");
        console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."), r = r.clone(), r.setInterpolation(br);
      }
      const c = l.morphTargetInfluences.length, h = l.morphTargetDictionary[a.propertyIndex];
      if (h === void 0)
        throw new Error("THREE.GLTFExporter: Morph target name not found: " + a.propertyIndex);
      let u;
      if (n[l.uuid] === void 0) {
        u = r.clone();
        const f = new u.ValueBufferType(c * u.times.length);
        for (let g = 0; g < u.times.length; g++)
          f[g * c + h] = u.values[g];
        u.name = (a.nodeName || "") + ".morphTargetInfluences", u.values = f, n[l.uuid] = u, t.push(u);
        continue;
      }
      const p = r.createInterpolant(new r.ValueBufferType(1));
      u = n[l.uuid];
      for (let f = 0; f < u.times.length; f++)
        u.values[f * c + h] = p.evaluate(u.times[f]);
      for (let f = 0; f < r.times.length; f++) {
        const g = this.insertKeyframe(u, r.times[f]);
        u.values[g * c + h] = r.values[f];
      }
    }
    return o.tracks = t, o;
  }
});
const Oe = {
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6,
  BYTE: 5120,
  UNSIGNED_BYTE: 5121,
  SHORT: 5122,
  UNSIGNED_SHORT: 5123,
  INT: 5124,
  UNSIGNED_INT: 5125,
  FLOAT: 5126,
  ARRAY_BUFFER: 34962,
  ELEMENT_ARRAY_BUFFER: 34963,
  NEAREST: 9728,
  LINEAR: 9729,
  NEAREST_MIPMAP_NEAREST: 9984,
  LINEAR_MIPMAP_NEAREST: 9985,
  NEAREST_MIPMAP_LINEAR: 9986,
  LINEAR_MIPMAP_LINEAR: 9987,
  CLAMP_TO_EDGE: 33071,
  MIRRORED_REPEAT: 33648,
  REPEAT: 10497
}, Si = "KHR_mesh_quantization", _t = {};
_t[la] = Oe.NEAREST;
_t[ca] = Oe.NEAREST_MIPMAP_NEAREST;
_t[ua] = Oe.NEAREST_MIPMAP_LINEAR;
_t[vt] = Oe.LINEAR;
_t[ha] = Oe.LINEAR_MIPMAP_NEAREST;
_t[Er] = Oe.LINEAR_MIPMAP_LINEAR;
_t[ts] = Oe.CLAMP_TO_EDGE;
_t[kn] = Oe.REPEAT;
_t[fa] = Oe.MIRRORED_REPEAT;
const io = {
  scale: "scale",
  position: "translation",
  quaternion: "rotation",
  morphTargetInfluences: "weights"
}, Cu = new Pe(), ro = 12, Ru = 1179937895, Iu = 2, oo = 8, Ou = 1313821514, Du = 5130562;
function vs(o, e) {
  return o.length === e.length && o.every(function(t, n) {
    return t === e[n];
  });
}
function Lu(o) {
  return new TextEncoder().encode(o).buffer;
}
function Fu(o) {
  return vs(o.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
}
function ku(o, e, t) {
  const n = {
    min: new Array(o.itemSize).fill(Number.POSITIVE_INFINITY),
    max: new Array(o.itemSize).fill(Number.NEGATIVE_INFINITY)
  };
  for (let s = e; s < e + t; s++)
    for (let i = 0; i < o.itemSize; i++) {
      let r;
      o.itemSize > 4 ? r = o.array[s * o.itemSize + i] : (i === 0 ? r = o.getX(s) : i === 1 ? r = o.getY(s) : i === 2 ? r = o.getZ(s) : i === 3 && (r = o.getW(s)), o.normalized === !0 && (r = Ze.normalize(r, o.array))), n.min[i] = Math.min(n.min[i], r), n.max[i] = Math.max(n.max[i], r);
    }
  return n;
}
function Na(o) {
  return Math.ceil(o / 4) * 4;
}
function Ai(o, e = 0) {
  const t = Na(o.byteLength);
  if (t !== o.byteLength) {
    const n = new Uint8Array(t);
    if (n.set(new Uint8Array(o)), e !== 0)
      for (let s = o.byteLength; s < t; s++)
        n[s] = e;
    return n.buffer;
  }
  return o;
}
function ao() {
  return typeof document > "u" && typeof OffscreenCanvas < "u" ? new OffscreenCanvas(1, 1) : document.createElement("canvas");
}
function lo(o, e) {
  if (o.toBlob !== void 0)
    return new Promise((n) => o.toBlob(n, e));
  let t;
  return e === "image/jpeg" ? t = 0.92 : e === "image/webp" && (t = 0.8), o.convertToBlob({
    type: e,
    quality: t
  });
}
class Bu {
  constructor() {
    this.plugins = [], this.options = {}, this.pending = [], this.buffers = [], this.byteOffset = 0, this.buffers = [], this.nodeMap = /* @__PURE__ */ new Map(), this.skins = [], this.extensionsUsed = {}, this.extensionsRequired = {}, this.uids = /* @__PURE__ */ new Map(), this.uid = 0, this.json = {
      asset: {
        version: "2.0",
        generator: "THREE.GLTFExporter"
      }
    }, this.cache = {
      meshes: /* @__PURE__ */ new Map(),
      attributes: /* @__PURE__ */ new Map(),
      attributesNormalized: /* @__PURE__ */ new Map(),
      materials: /* @__PURE__ */ new Map(),
      textures: /* @__PURE__ */ new Map(),
      images: /* @__PURE__ */ new Map()
    };
  }
  setPlugins(e) {
    this.plugins = e;
  }
  /**
   * Parse scenes and generate GLTF output
   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes
   * @param  {Function} onDone  Callback on completed
   * @param  {Object} options options
   */
  async write(e, t, n = {}) {
    this.options = Object.assign(
      {
        // default options
        binary: !1,
        trs: !1,
        onlyVisible: !0,
        maxTextureSize: 1 / 0,
        animations: [],
        includeCustomExtensions: !1
      },
      n
    ), this.options.animations.length > 0 && (this.options.trs = !0), this.processInput(e), await Promise.all(this.pending);
    const s = this, i = s.buffers, r = s.json;
    n = s.options;
    const a = s.extensionsUsed, l = s.extensionsRequired, c = new Blob(i, { type: "application/octet-stream" }), h = Object.keys(a), u = Object.keys(l);
    h.length > 0 && (r.extensionsUsed = h), u.length > 0 && (r.extensionsRequired = u), r.buffers && r.buffers.length > 0 && (r.buffers[0].byteLength = c.size), n.binary === !0 ? c.arrayBuffer().then((p) => {
      const f = Ai(p), g = new DataView(new ArrayBuffer(oo));
      g.setUint32(0, f.byteLength, !0), g.setUint32(4, Du, !0);
      const m = Ai(Lu(JSON.stringify(r)), 32), y = new DataView(new ArrayBuffer(oo));
      y.setUint32(0, m.byteLength, !0), y.setUint32(4, Ou, !0);
      const d = new ArrayBuffer(ro), w = new DataView(d);
      w.setUint32(0, Ru, !0), w.setUint32(4, Iu, !0);
      const v = ro + y.byteLength + m.byteLength + g.byteLength + f.byteLength;
      w.setUint32(8, v, !0), new Blob([d, y, m, g, f], {
        type: "application/octet-stream"
      }).arrayBuffer().then(t);
    }) : r.buffers && r.buffers.length > 0 ? no(c).then((p) => {
      r.buffers[0].uri = p, t(r);
    }) : t(r);
  }
  /**
   * Serializes a userData.
   *
   * @param {THREE.Object3D|THREE.Material} object
   * @param {Object} objectDef
   */
  serializeUserData(e, t) {
    if (Object.keys(e.userData).length === 0)
      return;
    const n = this.options, s = this.extensionsUsed;
    try {
      const i = JSON.parse(JSON.stringify(e.userData));
      if (n.includeCustomExtensions && i.gltfExtensions) {
        t.extensions === void 0 && (t.extensions = {});
        for (const r in i.gltfExtensions)
          t.extensions[r] = i.gltfExtensions[r], s[r] = !0;
        delete i.gltfExtensions;
      }
      Object.keys(i).length > 0 && (t.extras = i);
    } catch (i) {
      console.warn(
        "THREE.GLTFExporter: userData of '" + e.name + "' won't be serialized because of JSON.stringify error - " + i.message
      );
    }
  }
  /**
   * Returns ids for buffer attributes.
   * @param  {Object} object
   * @return {Integer}
   */
  getUID(e, t = !1) {
    if (this.uids.has(e) === !1) {
      const s = /* @__PURE__ */ new Map();
      s.set(!0, this.uid++), s.set(!1, this.uid++), this.uids.set(e, s);
    }
    return this.uids.get(e).get(t);
  }
  /**
   * Checks if normal attribute values are normalized.
   *
   * @param {BufferAttribute} normal
   * @returns {Boolean}
   */
  isNormalizedNormalAttribute(e) {
    if (this.cache.attributesNormalized.has(e))
      return !1;
    const n = new $();
    for (let s = 0, i = e.count; s < i; s++)
      if (Math.abs(n.fromBufferAttribute(e, s).length() - 1) > 5e-4)
        return !1;
    return !0;
  }
  /**
   * Creates normalized normal buffer attribute.
   *
   * @param {BufferAttribute} normal
   * @returns {BufferAttribute}
   *
   */
  createNormalizedNormalAttribute(e) {
    const t = this.cache;
    if (t.attributesNormalized.has(e))
      return t.attributesNormalized.get(e);
    const n = e.clone(), s = new $();
    for (let i = 0, r = n.count; i < r; i++)
      s.fromBufferAttribute(n, i), s.x === 0 && s.y === 0 && s.z === 0 ? s.setX(1) : s.normalize(), n.setXYZ(i, s.x, s.y, s.z);
    return t.attributesNormalized.set(e, n), n;
  }
  /**
   * Applies a texture transform, if present, to the map definition. Requires
   * the KHR_texture_transform extension.
   *
   * @param {Object} mapDef
   * @param {THREE.Texture} texture
   */
  applyTextureTransform(e, t) {
    let n = !1;
    const s = {};
    (t.offset.x !== 0 || t.offset.y !== 0) && (s.offset = t.offset.toArray(), n = !0), t.rotation !== 0 && (s.rotation = t.rotation, n = !0), (t.repeat.x !== 1 || t.repeat.y !== 1) && (s.scale = t.repeat.toArray(), n = !0), n && (e.extensions = e.extensions || {}, e.extensions.KHR_texture_transform = s, this.extensionsUsed.KHR_texture_transform = !0);
  }
  buildMetalRoughTexture(e, t) {
    if (e === t)
      return e;
    function n(f) {
      return ("colorSpace" in f ? f.colorSpace === "srgb" : f.encoding === 3001) ? function(m) {
        return m < 0.04045 ? m * 0.0773993808 : Math.pow(m * 0.9478672986 + 0.0521327014, 2.4);
      } : function(m) {
        return m;
      };
    }
    console.warn("THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures."), e instanceof xi && (e = Mi(e)), t instanceof xi && (t = Mi(t));
    const s = e ? e.image : null, i = t ? t.image : null, r = Math.max(s ? s.width : 0, i ? i.width : 0), a = Math.max(s ? s.height : 0, i ? i.height : 0), l = ao();
    l.width = r, l.height = a;
    const c = l.getContext("2d");
    c.fillStyle = "#00ffff", c.fillRect(0, 0, r, a);
    const h = c.getImageData(0, 0, r, a);
    if (s) {
      c.drawImage(s, 0, 0, r, a);
      const f = n(e), g = c.getImageData(0, 0, r, a).data;
      for (let m = 2; m < g.length; m += 4)
        h.data[m] = f(g[m] / 256) * 256;
    }
    if (i) {
      c.drawImage(i, 0, 0, r, a);
      const f = n(t), g = c.getImageData(0, 0, r, a).data;
      for (let m = 1; m < g.length; m += 4)
        h.data[m] = f(g[m] / 256) * 256;
    }
    c.putImageData(h, 0, 0);
    const p = (e || t).clone();
    return p.source = new es(l).source, "colorSpace" in p ? p.colorSpace = "" : p.encoding = 3e3, p.channel = (e || t).channel, e && t && e.channel !== t.channel && console.warn("THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match."), p;
  }
  /**
   * Process a buffer to append to the default one.
   * @param  {ArrayBuffer} buffer
   * @return {Integer}
   */
  processBuffer(e) {
    const t = this.json, n = this.buffers;
    return t.buffers || (t.buffers = [{ byteLength: 0 }]), n.push(e), 0;
  }
  /**
   * Process and generate a BufferView
   * @param  {BufferAttribute} attribute
   * @param  {number} componentType
   * @param  {number} start
   * @param  {number} count
   * @param  {number} target (Optional) Target usage of the BufferView
   * @return {Object}
   */
  processBufferView(e, t, n, s, i) {
    const r = this.json;
    r.bufferViews || (r.bufferViews = []);
    let a;
    switch (t) {
      case Oe.BYTE:
      case Oe.UNSIGNED_BYTE:
        a = 1;
        break;
      case Oe.SHORT:
      case Oe.UNSIGNED_SHORT:
        a = 2;
        break;
      default:
        a = 4;
    }
    const l = Na(s * e.itemSize * a), c = new DataView(new ArrayBuffer(l));
    let h = 0;
    for (let f = n; f < n + s; f++)
      for (let g = 0; g < e.itemSize; g++) {
        let m;
        e.itemSize > 4 ? m = e.array[f * e.itemSize + g] : (g === 0 ? m = e.getX(f) : g === 1 ? m = e.getY(f) : g === 2 ? m = e.getZ(f) : g === 3 && (m = e.getW(f)), e.normalized === !0 && (m = Ze.normalize(m, e.array))), t === Oe.FLOAT ? c.setFloat32(h, m, !0) : t === Oe.INT ? c.setInt32(h, m, !0) : t === Oe.UNSIGNED_INT ? c.setUint32(h, m, !0) : t === Oe.SHORT ? c.setInt16(h, m, !0) : t === Oe.UNSIGNED_SHORT ? c.setUint16(h, m, !0) : t === Oe.BYTE ? c.setInt8(h, m) : t === Oe.UNSIGNED_BYTE && c.setUint8(h, m), h += a;
      }
    const u = {
      buffer: this.processBuffer(c.buffer),
      byteOffset: this.byteOffset,
      byteLength: l
    };
    return i !== void 0 && (u.target = i), i === Oe.ARRAY_BUFFER && (u.byteStride = e.itemSize * a), this.byteOffset += l, r.bufferViews.push(u), {
      id: r.bufferViews.length - 1,
      byteLength: 0
    };
  }
  /**
   * Process and generate a BufferView from an image Blob.
   * @param {Blob} blob
   * @return {Promise<Integer>}
   */
  processBufferViewImage(e) {
    const t = this, n = t.json;
    return n.bufferViews || (n.bufferViews = []), e.arrayBuffer().then((s) => {
      const i = Ai(s), r = {
        buffer: t.processBuffer(i),
        byteOffset: t.byteOffset,
        byteLength: i.byteLength
      };
      return t.byteOffset += i.byteLength, n.bufferViews.push(r) - 1;
    });
  }
  /**
   * Process attribute to generate an accessor
   * @param  {BufferAttribute} attribute Attribute to process
   * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range
   * @param  {Integer} start (Optional)
   * @param  {Integer} count (Optional)
   * @return {Integer|null} Index of the processed accessor on the "accessors" array
   */
  processAccessor(e, t, n, s) {
    const i = this.json, r = {
      1: "SCALAR",
      2: "VEC2",
      3: "VEC3",
      4: "VEC4",
      9: "MAT3",
      16: "MAT4"
    };
    let a;
    if (e.array.constructor === Float32Array)
      a = Oe.FLOAT;
    else if (e.array.constructor === Int32Array)
      a = Oe.INT;
    else if (e.array.constructor === Uint32Array)
      a = Oe.UNSIGNED_INT;
    else if (e.array.constructor === Int16Array)
      a = Oe.SHORT;
    else if (e.array.constructor === Uint16Array)
      a = Oe.UNSIGNED_SHORT;
    else if (e.array.constructor === Int8Array)
      a = Oe.BYTE;
    else if (e.array.constructor === Uint8Array)
      a = Oe.UNSIGNED_BYTE;
    else
      throw new Error(
        "THREE.GLTFExporter: Unsupported bufferAttribute component type: " + e.array.constructor.name
      );
    if (n === void 0 && (n = 0), s === void 0 && (s = e.count), s === 0)
      return null;
    const l = ku(e, n, s);
    let c;
    t !== void 0 && (c = e === t.index ? Oe.ELEMENT_ARRAY_BUFFER : Oe.ARRAY_BUFFER);
    const h = this.processBufferView(e, a, n, s, c), u = {
      bufferView: h.id,
      byteOffset: h.byteOffset,
      componentType: a,
      count: s,
      max: l.max,
      min: l.min,
      type: r[e.itemSize]
    };
    return e.normalized === !0 && (u.normalized = !0), i.accessors || (i.accessors = []), i.accessors.push(u) - 1;
  }
  /**
   * Process image
   * @param  {Image} image to process
   * @param  {Integer} format of the image (RGBAFormat)
   * @param  {Boolean} flipY before writing out the image
   * @param  {String} mimeType export format
   * @return {Integer}     Index of the processed texture in the "images" array
   */
  processImage(e, t, n, s = "image/png") {
    if (e !== null) {
      const i = this, r = i.cache, a = i.json, l = i.options, c = i.pending;
      r.images.has(e) || r.images.set(e, {});
      const h = r.images.get(e), u = s + ":flipY/" + n.toString();
      if (h[u] !== void 0)
        return h[u];
      a.images || (a.images = []);
      const p = { mimeType: s }, f = ao();
      f.width = Math.min(e.width, l.maxTextureSize), f.height = Math.min(e.height, l.maxTextureSize);
      const g = f.getContext("2d");
      if (n === !0 && (g.translate(0, f.height), g.scale(1, -1)), e.data !== void 0) {
        t !== oa && console.error("GLTFExporter: Only RGBAFormat is supported.", t), (e.width > l.maxTextureSize || e.height > l.maxTextureSize) && console.warn("GLTFExporter: Image size is bigger than maxTextureSize", e);
        const y = new Uint8ClampedArray(e.height * e.width * 4);
        for (let d = 0; d < y.length; d += 4)
          y[d + 0] = e.data[d + 0], y[d + 1] = e.data[d + 1], y[d + 2] = e.data[d + 2], y[d + 3] = e.data[d + 3];
        g.putImageData(new ImageData(y, e.width, e.height), 0, 0);
      } else
        g.drawImage(e, 0, 0, f.width, f.height);
      l.binary === !0 ? c.push(
        lo(f, s).then((y) => i.processBufferViewImage(y)).then((y) => {
          p.bufferView = y;
        })
      ) : f.toDataURL !== void 0 ? p.uri = f.toDataURL(s) : c.push(
        lo(f, s).then(no).then((y) => {
          p.uri = y;
        })
      );
      const m = a.images.push(p) - 1;
      return h[u] = m, m;
    } else
      throw new Error("THREE.GLTFExporter: No valid image data found. Unable to process texture.");
  }
  /**
   * Process sampler
   * @param  {Texture} map Texture to process
   * @return {Integer}     Index of the processed texture in the "samplers" array
   */
  processSampler(e) {
    const t = this.json;
    t.samplers || (t.samplers = []);
    const n = {
      magFilter: _t[e.magFilter],
      minFilter: _t[e.minFilter],
      wrapS: _t[e.wrapS],
      wrapT: _t[e.wrapT]
    };
    return t.samplers.push(n) - 1;
  }
  /**
   * Process texture
   * @param  {Texture} map Map to process
   * @return {Integer} Index of the processed texture in the "textures" array
   */
  processTexture(e) {
    const n = this.options, s = this.cache, i = this.json;
    if (s.textures.has(e))
      return s.textures.get(e);
    i.textures || (i.textures = []), e instanceof xi && (e = Mi(e, n.maxTextureSize));
    let r = e.userData.mimeType;
    r === "image/webp" && (r = "image/png");
    const a = {
      sampler: this.processSampler(e),
      source: this.processImage(e.image, e.format, e.flipY, r)
    };
    e.name && (a.name = e.name), this._invokeAll(function(c) {
      c.writeTexture && c.writeTexture(e, a);
    });
    const l = i.textures.push(a) - 1;
    return s.textures.set(e, l), l;
  }
  /**
   * Process material
   * @param  {THREE.Material} material Material to process
   * @return {Integer|null} Index of the processed material in the "materials" array
   */
  processMaterial(e) {
    const t = this.cache, n = this.json;
    if (t.materials.has(e))
      return t.materials.get(e);
    if (e.isShaderMaterial)
      return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."), null;
    n.materials || (n.materials = []);
    const s = { pbrMetallicRoughness: {} };
    e.isMeshStandardMaterial !== !0 && e.isMeshBasicMaterial !== !0 && console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");
    const i = e.color.toArray().concat([e.opacity]);
    if (vs(i, [1, 1, 1, 1]) || (s.pbrMetallicRoughness.baseColorFactor = i), e.isMeshStandardMaterial ? (s.pbrMetallicRoughness.metallicFactor = e.metalness, s.pbrMetallicRoughness.roughnessFactor = e.roughness) : (s.pbrMetallicRoughness.metallicFactor = 0.5, s.pbrMetallicRoughness.roughnessFactor = 0.5), e.metalnessMap || e.roughnessMap) {
      const a = this.buildMetalRoughTexture(e.metalnessMap, e.roughnessMap), l = {
        index: this.processTexture(a),
        channel: a.channel
      };
      this.applyTextureTransform(l, a), s.pbrMetallicRoughness.metallicRoughnessTexture = l;
    }
    if (e.map) {
      const a = {
        index: this.processTexture(e.map),
        texCoord: e.map.channel
      };
      this.applyTextureTransform(a, e.map), s.pbrMetallicRoughness.baseColorTexture = a;
    }
    if (e.emissive) {
      const a = e.emissive;
      if (Math.max(a.r, a.g, a.b) > 0 && (s.emissiveFactor = e.emissive.toArray()), e.emissiveMap) {
        const c = {
          index: this.processTexture(e.emissiveMap),
          texCoord: e.emissiveMap.channel
        };
        this.applyTextureTransform(c, e.emissiveMap), s.emissiveTexture = c;
      }
    }
    if (e.normalMap) {
      const a = {
        index: this.processTexture(e.normalMap),
        texCoord: e.normalMap.channel
      };
      e.normalScale && e.normalScale.x !== 1 && (a.scale = e.normalScale.x), this.applyTextureTransform(a, e.normalMap), s.normalTexture = a;
    }
    if (e.aoMap) {
      const a = {
        index: this.processTexture(e.aoMap),
        texCoord: e.aoMap.channel
      };
      e.aoMapIntensity !== 1 && (a.strength = e.aoMapIntensity), this.applyTextureTransform(a, e.aoMap), s.occlusionTexture = a;
    }
    e.transparent ? s.alphaMode = "BLEND" : e.alphaTest > 0 && (s.alphaMode = "MASK", s.alphaCutoff = e.alphaTest), e.side === tn && (s.doubleSided = !0), e.name !== "" && (s.name = e.name), this.serializeUserData(e, s), this._invokeAll(function(a) {
      a.writeMaterial && a.writeMaterial(e, s);
    });
    const r = n.materials.push(s) - 1;
    return t.materials.set(e, r), r;
  }
  /**
   * Process mesh
   * @param  {THREE.Mesh} mesh Mesh to process
   * @return {Integer|null} Index of the processed mesh in the "meshes" array
   */
  processMesh(e) {
    const t = this.cache, n = this.json, s = [e.geometry.uuid];
    if (Array.isArray(e.material))
      for (let v = 0, E = e.material.length; v < E; v++)
        s.push(e.material[v].uuid);
    else
      s.push(e.material.uuid);
    const i = s.join(":");
    if (t.meshes.has(i))
      return t.meshes.get(i);
    const r = e.geometry;
    let a;
    e.isLineSegments ? a = Oe.LINES : e.isLineLoop ? a = Oe.LINE_LOOP : e.isLine ? a = Oe.LINE_STRIP : e.isPoints ? a = Oe.POINTS : a = e.material.wireframe ? Oe.LINES : Oe.TRIANGLES;
    const l = {}, c = {}, h = [], u = [], p = {
      ...vi >= 152 ? {
        uv: "TEXCOORD_0",
        uv1: "TEXCOORD_1",
        uv2: "TEXCOORD_2",
        uv3: "TEXCOORD_3"
      } : {
        uv: "TEXCOORD_0",
        uv2: "TEXCOORD_1"
      },
      color: "COLOR_0",
      skinWeight: "WEIGHTS_0",
      skinIndex: "JOINTS_0"
    }, f = r.getAttribute("normal");
    f !== void 0 && !this.isNormalizedNormalAttribute(f) && (console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."), r.setAttribute("normal", this.createNormalizedNormalAttribute(f)));
    let g = null;
    for (let v in r.attributes) {
      if (v.slice(0, 5) === "morph")
        continue;
      const E = r.attributes[v];
      if (v = p[v] || v.toUpperCase(), /^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(v) || (v = "_" + v), t.attributes.has(this.getUID(E))) {
        c[v] = t.attributes.get(this.getUID(E));
        continue;
      }
      g = null;
      const T = E.array;
      v === "JOINTS_0" && !(T instanceof Uint16Array) && !(T instanceof Uint8Array) && (console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'), g = new mt(new Uint16Array(T), E.itemSize, E.normalized));
      const b = this.processAccessor(g || E, r);
      b !== null && (v.startsWith("_") || this.detectMeshQuantization(v, E), c[v] = b, t.attributes.set(this.getUID(E), b));
    }
    if (f !== void 0 && r.setAttribute("normal", f), Object.keys(c).length === 0)
      return null;
    if (e.morphTargetInfluences !== void 0 && e.morphTargetInfluences.length > 0) {
      const v = [], E = [], P = {};
      if (e.morphTargetDictionary !== void 0)
        for (const T in e.morphTargetDictionary)
          P[e.morphTargetDictionary[T]] = T;
      for (let T = 0; T < e.morphTargetInfluences.length; ++T) {
        const b = {};
        let x = !1;
        for (const M in r.morphAttributes) {
          if (M !== "position" && M !== "normal") {
            x || (console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."), x = !0);
            continue;
          }
          const _ = r.morphAttributes[M][T], C = M.toUpperCase(), R = r.attributes[M];
          if (t.attributes.has(this.getUID(_, !0))) {
            b[C] = t.attributes.get(this.getUID(_, !0));
            continue;
          }
          const B = _.clone();
          if (!r.morphTargetsRelative)
            for (let N = 0, j = _.count; N < j; N++)
              for (let V = 0; V < _.itemSize; V++)
                V === 0 && B.setX(N, _.getX(N) - R.getX(N)), V === 1 && B.setY(N, _.getY(N) - R.getY(N)), V === 2 && B.setZ(N, _.getZ(N) - R.getZ(N)), V === 3 && B.setW(N, _.getW(N) - R.getW(N));
          b[C] = this.processAccessor(B, r), t.attributes.set(this.getUID(R, !0), b[C]);
        }
        u.push(b), v.push(e.morphTargetInfluences[T]), e.morphTargetDictionary !== void 0 && E.push(P[T]);
      }
      l.weights = v, E.length > 0 && (l.extras = {}, l.extras.targetNames = E);
    }
    const m = Array.isArray(e.material);
    if (m && r.groups.length === 0)
      return null;
    const y = m ? e.material : [e.material], d = m ? r.groups : [{ materialIndex: 0, start: void 0, count: void 0 }];
    for (let v = 0, E = d.length; v < E; v++) {
      const P = {
        mode: a,
        attributes: c
      };
      if (this.serializeUserData(r, P), u.length > 0 && (P.targets = u), r.index !== null) {
        let b = this.getUID(r.index);
        (d[v].start !== void 0 || d[v].count !== void 0) && (b += ":" + d[v].start + ":" + d[v].count), t.attributes.has(b) ? P.indices = t.attributes.get(b) : (P.indices = this.processAccessor(r.index, r, d[v].start, d[v].count), t.attributes.set(b, P.indices)), P.indices === null && delete P.indices;
      }
      const T = this.processMaterial(y[d[v].materialIndex]);
      T !== null && (P.material = T), h.push(P);
    }
    l.primitives = h, n.meshes || (n.meshes = []), this._invokeAll(function(v) {
      v.writeMesh && v.writeMesh(e, l);
    });
    const w = n.meshes.push(l) - 1;
    return t.meshes.set(i, w), w;
  }
  /**
   * If a vertex attribute with a
   * [non-standard data type](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#meshes-overview)
   * is used, it is checked whether it is a valid data type according to the
   * [KHR_mesh_quantization](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md)
   * extension.
   * In this case the extension is automatically added to the list of used extensions.
   *
   * @param {string} attributeName
   * @param {THREE.BufferAttribute} attribute
   */
  detectMeshQuantization(e, t) {
    if (this.extensionsUsed[Si])
      return;
    let n;
    switch (t.array.constructor) {
      case Int8Array:
        n = "byte";
        break;
      case Uint8Array:
        n = "unsigned byte";
        break;
      case Int16Array:
        n = "short";
        break;
      case Uint16Array:
        n = "unsigned short";
        break;
      default:
        return;
    }
    t.normalized && (n += " normalized");
    const s = e.split("_", 1)[0];
    so[s] && so[s].includes(n) && (this.extensionsUsed[Si] = !0, this.extensionsRequired[Si] = !0);
  }
  /**
   * Process camera
   * @param  {THREE.Camera} camera Camera to process
   * @return {Integer}      Index of the processed mesh in the "camera" array
   */
  processCamera(e) {
    const t = this.json;
    t.cameras || (t.cameras = []);
    const n = e.isOrthographicCamera, s = {
      type: n ? "orthographic" : "perspective"
    };
    return n ? s.orthographic = {
      xmag: e.right * 2,
      ymag: e.top * 2,
      zfar: e.far <= 0 ? 1e-3 : e.far,
      znear: e.near < 0 ? 0 : e.near
    } : s.perspective = {
      aspectRatio: e.aspect,
      yfov: Ze.degToRad(e.fov),
      zfar: e.far <= 0 ? 1e-3 : e.far,
      znear: e.near < 0 ? 0 : e.near
    }, e.name !== "" && (s.name = e.type), t.cameras.push(s) - 1;
  }
  /**
   * Creates glTF animation entry from AnimationClip object.
   *
   * Status:
   * - Only properties listed in PATH_PROPERTIES may be animated.
   *
   * @param {THREE.AnimationClip} clip
   * @param {THREE.Object3D} root
   * @return {number|null}
   */
  processAnimation(e, t) {
    const n = this.json, s = this.nodeMap;
    n.animations || (n.animations = []), e = Lr.Utils.mergeMorphTargetTracks(e.clone(), t);
    const i = e.tracks, r = [], a = [];
    for (let l = 0; l < i.length; ++l) {
      const c = i[l], h = nn.parseTrackName(c.name);
      let u = nn.findNode(t, h.nodeName);
      const p = io[h.propertyName];
      if (h.objectName === "bones" && (u.isSkinnedMesh === !0 ? u = u.skeleton.getBoneByName(h.objectIndex) : u = void 0), !u || !p)
        return console.warn('THREE.GLTFExporter: Could not export animation track "%s".', c.name), null;
      const f = 1;
      let g = c.values.length / c.times.length;
      p === io.morphTargetInfluences && (g /= u.morphTargetInfluences.length);
      let m;
      c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === !0 ? (m = "CUBICSPLINE", g /= 3) : c.getInterpolation() === aa ? m = "STEP" : m = "LINEAR", a.push({
        input: this.processAccessor(new mt(c.times, f)),
        output: this.processAccessor(new mt(c.values, g)),
        interpolation: m
      }), r.push({
        sampler: a.length - 1,
        target: {
          node: s.get(u),
          path: p
        }
      });
    }
    return n.animations.push({
      name: e.name || "clip_" + n.animations.length,
      samplers: a,
      channels: r
    }), n.animations.length - 1;
  }
  /**
   * @param {THREE.Object3D} object
   * @return {number|null}
   */
  processSkin(e) {
    const t = this.json, n = this.nodeMap, s = t.nodes[n.get(e)], i = e.skeleton;
    if (i === void 0)
      return null;
    const r = e.skeleton.bones[0];
    if (r === void 0)
      return null;
    const a = [], l = new Float32Array(i.bones.length * 16), c = new Re();
    for (let u = 0; u < i.bones.length; ++u)
      a.push(n.get(i.bones[u])), c.copy(i.boneInverses[u]), c.multiply(e.bindMatrix).toArray(l, u * 16);
    return t.skins === void 0 && (t.skins = []), t.skins.push({
      inverseBindMatrices: this.processAccessor(new mt(l, 16)),
      joints: a,
      skeleton: n.get(r)
    }), s.skin = t.skins.length - 1;
  }
  /**
   * Process Object3D node
   * @param  {THREE.Object3D} node Object3D to processNode
   * @return {Integer} Index of the node in the nodes list
   */
  processNode(e) {
    const t = this.json, n = this.options, s = this.nodeMap;
    t.nodes || (t.nodes = []);
    const i = {};
    if (n.trs) {
      const a = e.quaternion.toArray(), l = e.position.toArray(), c = e.scale.toArray();
      vs(a, [0, 0, 0, 1]) || (i.rotation = a), vs(l, [0, 0, 0]) || (i.translation = l), vs(c, [1, 1, 1]) || (i.scale = c);
    } else
      e.matrixAutoUpdate && e.updateMatrix(), Fu(e.matrix) === !1 && (i.matrix = e.matrix.elements);
    if (e.name !== "" && (i.name = String(e.name)), this.serializeUserData(e, i), e.isMesh || e.isLine || e.isPoints) {
      const a = this.processMesh(e);
      a !== null && (i.mesh = a);
    } else e.isCamera && (i.camera = this.processCamera(e));
    if (e.isSkinnedMesh && this.skins.push(e), e.children.length > 0) {
      const a = [];
      for (let l = 0, c = e.children.length; l < c; l++) {
        const h = e.children[l];
        if (h.visible || n.onlyVisible === !1) {
          const u = this.processNode(h);
          u !== null && a.push(u);
        }
      }
      a.length > 0 && (i.children = a);
    }
    this._invokeAll(function(a) {
      a.writeNode && a.writeNode(e, i);
    });
    const r = t.nodes.push(i) - 1;
    return s.set(e, r), r;
  }
  /**
   * Process Scene
   * @param  {Scene} node Scene to process
   */
  processScene(e) {
    const t = this.json, n = this.options;
    t.scenes || (t.scenes = [], t.scene = 0);
    const s = {};
    e.name !== "" && (s.name = e.name), t.scenes.push(s);
    const i = [];
    for (let r = 0, a = e.children.length; r < a; r++) {
      const l = e.children[r];
      if (l.visible || n.onlyVisible === !1) {
        const c = this.processNode(l);
        c !== null && i.push(c);
      }
    }
    i.length > 0 && (s.nodes = i), this.serializeUserData(e, s);
  }
  /**
   * Creates a Scene to hold a list of objects and parse it
   * @param  {Array} objects List of objects to process
   */
  processObjects(e) {
    const t = new Ts();
    t.name = "AuxScene";
    for (let n = 0; n < e.length; n++)
      t.children.push(e[n]);
    this.processScene(t);
  }
  /**
   * @param {THREE.Object3D|Array<THREE.Object3D>} input
   */
  processInput(e) {
    const t = this.options;
    e = e instanceof Array ? e : [e], this._invokeAll(function(s) {
      s.beforeParse && s.beforeParse(e);
    });
    const n = [];
    for (let s = 0; s < e.length; s++)
      e[s] instanceof Ts ? this.processScene(e[s]) : n.push(e[s]);
    n.length > 0 && this.processObjects(n);
    for (let s = 0; s < this.skins.length; ++s)
      this.processSkin(this.skins[s]);
    for (let s = 0; s < t.animations.length; ++s)
      this.processAnimation(t.animations[s], e[0]);
    this._invokeAll(function(s) {
      s.afterParse && s.afterParse(e);
    });
  }
  _invokeAll(e) {
    for (let t = 0, n = this.plugins.length; t < n; t++)
      e(this.plugins[t]);
  }
}
class Nu {
  constructor(e) {
    this.writer = e, this.name = "KHR_lights_punctual";
  }
  writeNode(e, t) {
    if (!e.isLight)
      return;
    if (!e.isDirectionalLight && !e.isPointLight && !e.isSpotLight) {
      console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.", e);
      return;
    }
    const n = this.writer, s = n.json, i = n.extensionsUsed, r = {};
    e.name && (r.name = e.name), r.color = e.color.toArray(), r.intensity = e.intensity, e.isDirectionalLight ? r.type = "directional" : e.isPointLight ? (r.type = "point", e.distance > 0 && (r.range = e.distance)) : e.isSpotLight && (r.type = "spot", e.distance > 0 && (r.range = e.distance), r.spot = {}, r.spot.innerConeAngle = (e.penumbra - 1) * e.angle * -1, r.spot.outerConeAngle = e.angle), e.decay !== void 0 && e.decay !== 2 && console.warn(
      "THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."
    ), e.target && (e.target.parent !== e || e.target.position.x !== 0 || e.target.position.y !== 0 || e.target.position.z !== -1) && console.warn(
      "THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."
    ), i[this.name] || (s.extensions = s.extensions || {}, s.extensions[this.name] = { lights: [] }, i[this.name] = !0);
    const a = s.extensions[this.name].lights;
    a.push(r), t.extensions = t.extensions || {}, t.extensions[this.name] = { light: a.length - 1 };
  }
}
let Uu = class {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_unlit";
  }
  writeMaterial(e, t) {
    if (!e.isMeshBasicMaterial)
      return;
    const s = this.writer.extensionsUsed;
    t.extensions = t.extensions || {}, t.extensions[this.name] = {}, s[this.name] = !0, t.pbrMetallicRoughness.metallicFactor = 0, t.pbrMetallicRoughness.roughnessFactor = 0.9;
  }
}, zu = class {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_clearcoat";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.clearcoat === 0)
      return;
    const n = this.writer, s = n.extensionsUsed, i = {};
    if (i.clearcoatFactor = e.clearcoat, e.clearcoatMap) {
      const r = {
        index: n.processTexture(e.clearcoatMap),
        texCoord: e.clearcoatMap.channel
      };
      n.applyTextureTransform(r, e.clearcoatMap), i.clearcoatTexture = r;
    }
    if (i.clearcoatRoughnessFactor = e.clearcoatRoughness, e.clearcoatRoughnessMap) {
      const r = {
        index: n.processTexture(e.clearcoatRoughnessMap),
        texCoord: e.clearcoatRoughnessMap.channel
      };
      n.applyTextureTransform(r, e.clearcoatRoughnessMap), i.clearcoatRoughnessTexture = r;
    }
    if (e.clearcoatNormalMap) {
      const r = {
        index: n.processTexture(e.clearcoatNormalMap),
        texCoord: e.clearcoatNormalMap.channel
      };
      n.applyTextureTransform(r, e.clearcoatNormalMap), i.clearcoatNormalTexture = r;
    }
    t.extensions = t.extensions || {}, t.extensions[this.name] = i, s[this.name] = !0;
  }
}, Hu = class {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_iridescence";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.iridescence === 0)
      return;
    const n = this.writer, s = n.extensionsUsed, i = {};
    if (i.iridescenceFactor = e.iridescence, e.iridescenceMap) {
      const r = {
        index: n.processTexture(e.iridescenceMap),
        texCoord: e.iridescenceMap.channel
      };
      n.applyTextureTransform(r, e.iridescenceMap), i.iridescenceTexture = r;
    }
    if (i.iridescenceIor = e.iridescenceIOR, i.iridescenceThicknessMinimum = e.iridescenceThicknessRange[0], i.iridescenceThicknessMaximum = e.iridescenceThicknessRange[1], e.iridescenceThicknessMap) {
      const r = {
        index: n.processTexture(e.iridescenceThicknessMap),
        texCoord: e.iridescenceThicknessMap.channel
      };
      n.applyTextureTransform(r, e.iridescenceThicknessMap), i.iridescenceThicknessTexture = r;
    }
    t.extensions = t.extensions || {}, t.extensions[this.name] = i, s[this.name] = !0;
  }
}, Gu = class {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_transmission";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.transmission === 0)
      return;
    const n = this.writer, s = n.extensionsUsed, i = {};
    if (i.transmissionFactor = e.transmission, e.transmissionMap) {
      const r = {
        index: n.processTexture(e.transmissionMap),
        texCoord: e.transmissionMap.channel
      };
      n.applyTextureTransform(r, e.transmissionMap), i.transmissionTexture = r;
    }
    t.extensions = t.extensions || {}, t.extensions[this.name] = i, s[this.name] = !0;
  }
}, ju = class {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_volume";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.transmission === 0)
      return;
    const n = this.writer, s = n.extensionsUsed, i = {};
    if (i.thicknessFactor = e.thickness, e.thicknessMap) {
      const r = {
        index: n.processTexture(e.thicknessMap),
        texCoord: e.thicknessMap.channel
      };
      n.applyTextureTransform(r, e.thicknessMap), i.thicknessTexture = r;
    }
    i.attenuationDistance = e.attenuationDistance, i.attenuationColor = e.attenuationColor.toArray(), t.extensions = t.extensions || {}, t.extensions[this.name] = i, s[this.name] = !0;
  }
}, Vu = class {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_ior";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.ior === 1.5)
      return;
    const s = this.writer.extensionsUsed, i = {};
    i.ior = e.ior, t.extensions = t.extensions || {}, t.extensions[this.name] = i, s[this.name] = !0;
  }
}, Yu = class {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_specular";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.specularIntensity === 1 && e.specularColor.equals(Cu) && !e.specularIntensityMap && !e.specularColorTexture)
      return;
    const n = this.writer, s = n.extensionsUsed, i = {};
    if (e.specularIntensityMap) {
      const r = {
        index: n.processTexture(e.specularIntensityMap),
        texCoord: e.specularIntensityMap.channel
      };
      n.applyTextureTransform(r, e.specularIntensityMap), i.specularTexture = r;
    }
    if (e.specularColorMap) {
      const r = {
        index: n.processTexture(e.specularColorMap),
        texCoord: e.specularColorMap.channel
      };
      n.applyTextureTransform(r, e.specularColorMap), i.specularColorTexture = r;
    }
    i.specularFactor = e.specularIntensity, i.specularColorFactor = e.specularColor.toArray(), t.extensions = t.extensions || {}, t.extensions[this.name] = i, s[this.name] = !0;
  }
}, Xu = class {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_sheen";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.sheen == 0)
      return;
    const n = this.writer, s = n.extensionsUsed, i = {};
    if (e.sheenRoughnessMap) {
      const r = {
        index: n.processTexture(e.sheenRoughnessMap),
        texCoord: e.sheenRoughnessMap.channel
      };
      n.applyTextureTransform(r, e.sheenRoughnessMap), i.sheenRoughnessTexture = r;
    }
    if (e.sheenColorMap) {
      const r = {
        index: n.processTexture(e.sheenColorMap),
        texCoord: e.sheenColorMap.channel
      };
      n.applyTextureTransform(r, e.sheenColorMap), i.sheenColorTexture = r;
    }
    i.sheenRoughnessFactor = e.sheenRoughness, i.sheenColorFactor = e.sheenColor.toArray(), t.extensions = t.extensions || {}, t.extensions[this.name] = i, s[this.name] = !0;
  }
}, Wu = class {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_anisotropy";
  }
  writeMaterial(e, t) {
    if (!e.isMeshPhysicalMaterial || e.anisotropy == 0)
      return;
    const n = this.writer, s = n.extensionsUsed, i = {};
    if (e.anisotropyMap) {
      const r = { index: n.processTexture(e.anisotropyMap) };
      n.applyTextureTransform(r, e.anisotropyMap), i.anisotropyTexture = r;
    }
    i.anisotropyStrength = e.anisotropy, i.anisotropyRotation = e.anisotropyRotation, t.extensions = t.extensions || {}, t.extensions[this.name] = i, s[this.name] = !0;
  }
}, $u = class {
  constructor(e) {
    this.writer = e, this.name = "KHR_materials_emissive_strength";
  }
  writeMaterial(e, t) {
    if (!e.isMeshStandardMaterial || e.emissiveIntensity === 1)
      return;
    const s = this.writer.extensionsUsed, i = {};
    i.emissiveStrength = e.emissiveIntensity, t.extensions = t.extensions || {}, t.extensions[this.name] = i, s[this.name] = !0;
  }
};
var St = Uint8Array, En = Uint16Array, fr = Uint32Array, Ua = new St([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]), za = new St([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]), Zu = new St([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), Ha = function(o, e) {
  for (var t = new En(31), n = 0; n < 31; ++n)
    t[n] = e += 1 << o[n - 1];
  for (var s = new fr(t[30]), n = 1; n < 30; ++n)
    for (var i = t[n]; i < t[n + 1]; ++i)
      s[i] = i - t[n] << 5 | n;
  return [t, s];
}, Ga = Ha(Ua, 2), ja = Ga[0], Ku = Ga[1];
ja[28] = 258, Ku[258] = 28;
var qu = Ha(za, 0), Qu = qu[0], dr = new En(32768);
for (var Ye = 0; Ye < 32768; ++Ye) {
  var fn = (Ye & 43690) >>> 1 | (Ye & 21845) << 1;
  fn = (fn & 52428) >>> 2 | (fn & 13107) << 2, fn = (fn & 61680) >>> 4 | (fn & 3855) << 4, dr[Ye] = ((fn & 65280) >>> 8 | (fn & 255) << 8) >>> 1;
}
var _s = function(o, e, t) {
  for (var n = o.length, s = 0, i = new En(e); s < n; ++s)
    ++i[o[s] - 1];
  var r = new En(e);
  for (s = 0; s < e; ++s)
    r[s] = r[s - 1] + i[s - 1] << 1;
  var a;
  if (t) {
    a = new En(1 << e);
    var l = 15 - e;
    for (s = 0; s < n; ++s)
      if (o[s])
        for (var c = s << 4 | o[s], h = e - o[s], u = r[o[s] - 1]++ << h, p = u | (1 << h) - 1; u <= p; ++u)
          a[dr[u] >>> l] = c;
  } else
    for (a = new En(n), s = 0; s < n; ++s)
      o[s] && (a[s] = dr[r[o[s] - 1]++] >>> 15 - o[s]);
  return a;
}, Cs = new St(288);
for (var Ye = 0; Ye < 144; ++Ye)
  Cs[Ye] = 8;
for (var Ye = 144; Ye < 256; ++Ye)
  Cs[Ye] = 9;
for (var Ye = 256; Ye < 280; ++Ye)
  Cs[Ye] = 7;
for (var Ye = 280; Ye < 288; ++Ye)
  Cs[Ye] = 8;
var Va = new St(32);
for (var Ye = 0; Ye < 32; ++Ye)
  Va[Ye] = 5;
var Ju = /* @__PURE__ */ _s(Cs, 9, 1), eh = /* @__PURE__ */ _s(Va, 5, 1), Pi = function(o) {
  for (var e = o[0], t = 1; t < o.length; ++t)
    o[t] > e && (e = o[t]);
  return e;
}, Rt = function(o, e, t) {
  var n = e / 8 | 0;
  return (o[n] | o[n + 1] << 8) >> (e & 7) & t;
}, Ci = function(o, e) {
  var t = e / 8 | 0;
  return (o[t] | o[t + 1] << 8 | o[t + 2] << 16) >> (e & 7);
}, th = function(o) {
  return (o / 8 | 0) + (o & 7 && 1);
}, nh = function(o, e, t) {
  (t == null || t > o.length) && (t = o.length);
  var n = new (o instanceof En ? En : o instanceof fr ? fr : St)(t - e);
  return n.set(o.subarray(e, t)), n;
}, sh = function(o, e, t) {
  var n = o.length;
  if (!n || t && !t.l && n < 5)
    return e || new St(0);
  var s = !e || t, i = !t || t.i;
  t || (t = {}), e || (e = new St(n * 3));
  var r = function(D) {
    var O = e.length;
    if (D > O) {
      var z = new St(Math.max(O * 2, D));
      z.set(e), e = z;
    }
  }, a = t.f || 0, l = t.p || 0, c = t.b || 0, h = t.l, u = t.d, p = t.m, f = t.n, g = n * 8;
  do {
    if (!h) {
      t.f = a = Rt(o, l, 1);
      var m = Rt(o, l + 1, 3);
      if (l += 3, m)
        if (m == 1)
          h = Ju, u = eh, p = 9, f = 5;
        else if (m == 2) {
          var v = Rt(o, l, 31) + 257, E = Rt(o, l + 10, 15) + 4, P = v + Rt(o, l + 5, 31) + 1;
          l += 14;
          for (var T = new St(P), b = new St(19), x = 0; x < E; ++x)
            b[Zu[x]] = Rt(o, l + x * 3, 7);
          l += E * 3;
          for (var M = Pi(b), _ = (1 << M) - 1, C = _s(b, M, 1), x = 0; x < P; ) {
            var R = C[Rt(o, l, _)];
            l += R & 15;
            var y = R >>> 4;
            if (y < 16)
              T[x++] = y;
            else {
              var B = 0, N = 0;
              for (y == 16 ? (N = 3 + Rt(o, l, 3), l += 2, B = T[x - 1]) : y == 17 ? (N = 3 + Rt(o, l, 7), l += 3) : y == 18 && (N = 11 + Rt(o, l, 127), l += 7); N--; )
                T[x++] = B;
            }
          }
          var j = T.subarray(0, v), V = T.subarray(v);
          p = Pi(j), f = Pi(V), h = _s(j, p, 1), u = _s(V, f, 1);
        } else
          throw "invalid block type";
      else {
        var y = th(l) + 4, d = o[y - 4] | o[y - 3] << 8, w = y + d;
        if (w > n) {
          if (i)
            throw "unexpected EOF";
          break;
        }
        s && r(c + d), e.set(o.subarray(y, w), c), t.b = c += d, t.p = l = w * 8;
        continue;
      }
      if (l > g) {
        if (i)
          throw "unexpected EOF";
        break;
      }
    }
    s && r(c + 131072);
    for (var Q = (1 << p) - 1, Z = (1 << f) - 1, ne = l; ; ne = l) {
      var B = h[Ci(o, l) & Q], te = B >>> 4;
      if (l += B & 15, l > g) {
        if (i)
          throw "unexpected EOF";
        break;
      }
      if (!B)
        throw "invalid length/literal";
      if (te < 256)
        e[c++] = te;
      else if (te == 256) {
        ne = l, h = null;
        break;
      } else {
        var le = te - 254;
        if (te > 264) {
          var x = te - 257, ae = Ua[x];
          le = Rt(o, l, (1 << ae) - 1) + ja[x], l += ae;
        }
        var Te = u[Ci(o, l) & Z], I = Te >>> 4;
        if (!Te)
          throw "invalid distance";
        l += Te & 15;
        var V = Qu[I];
        if (I > 3) {
          var ae = za[I];
          V += Ci(o, l) & (1 << ae) - 1, l += ae;
        }
        if (l > g) {
          if (i)
            throw "unexpected EOF";
          break;
        }
        s && r(c + 131072);
        for (var k = c + le; c < k; c += 4)
          e[c] = e[c - V], e[c + 1] = e[c + 1 - V], e[c + 2] = e[c + 2 - V], e[c + 3] = e[c + 3 - V];
        c = k;
      }
    }
    t.l = h, t.p = ne, t.b = c, h && (a = 1, t.m = p, t.d = u, t.n = f);
  } while (!a);
  return c == e.length ? e : nh(e, 0, c);
}, ih = /* @__PURE__ */ new St(0), rh = function(o) {
  if ((o[0] & 15) != 8 || o[0] >>> 4 > 7 || (o[0] << 8 | o[1]) % 31)
    throw "invalid zlib data";
  if (o[1] & 32)
    throw "invalid zlib data: preset dictionaries not supported";
};
function oh(o, e) {
  return sh((rh(o), o.subarray(2, -4)), e);
}
var ah = typeof TextDecoder < "u" && /* @__PURE__ */ new TextDecoder(), lh = 0;
try {
  ah.decode(ih, { stream: !0 }), lh = 1;
} catch {
}
var ch = Object.defineProperty, uh = (o, e, t) => e in o ? ch(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, hh = (o, e, t) => (uh(o, e + "", t), t);
const Ya = class extends he {
  constructor(o, e = {}) {
    super(o), this.isReflector = !0, this.type = "Reflector", this.camera = new At();
    const t = this, n = e.color !== void 0 ? new Pe(e.color) : new Pe(8355711), s = e.textureWidth || 512, i = e.textureHeight || 512, r = e.clipBias || 0, a = e.shader || Ya.ReflectorShader, l = e.multisample !== void 0 ? e.multisample : 4, c = new pi(), h = new $(), u = new $(), p = new $(), f = new Re(), g = new $(0, 0, -1), m = new it(), y = new $(), d = new $(), w = new it(), v = new Re(), E = this.camera, P = new jt(s, i, {
      samples: l,
      type: Vt
    }), T = new Lt({
      uniforms: ns.clone(a.uniforms),
      fragmentShader: a.fragmentShader,
      vertexShader: a.vertexShader
    });
    T.uniforms.tDiffuse.value = P.texture, T.uniforms.color.value = n, T.uniforms.textureMatrix.value = v, this.material = T, this.onBeforeRender = function(b, x, M) {
      if (u.setFromMatrixPosition(t.matrixWorld), p.setFromMatrixPosition(M.matrixWorld), f.extractRotation(t.matrixWorld), h.set(0, 0, 1), h.applyMatrix4(f), y.subVectors(u, p), y.dot(h) > 0)
        return;
      y.reflect(h).negate(), y.add(u), f.extractRotation(M.matrixWorld), g.set(0, 0, -1), g.applyMatrix4(f), g.add(p), d.subVectors(u, g), d.reflect(h).negate(), d.add(u), E.position.copy(y), E.up.set(0, 1, 0), E.up.applyMatrix4(f), E.up.reflect(h), E.lookAt(d), E.far = M.far, E.updateMatrixWorld(), E.projectionMatrix.copy(M.projectionMatrix), v.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), v.multiply(E.projectionMatrix), v.multiply(E.matrixWorldInverse), v.multiply(t.matrixWorld), c.setFromNormalAndCoplanarPoint(h, u), c.applyMatrix4(E.matrixWorldInverse), m.set(c.normal.x, c.normal.y, c.normal.z, c.constant);
      const _ = E.projectionMatrix;
      w.x = (Math.sign(m.x) + _.elements[8]) / _.elements[0], w.y = (Math.sign(m.y) + _.elements[9]) / _.elements[5], w.z = -1, w.w = (1 + _.elements[10]) / _.elements[14], m.multiplyScalar(2 / m.dot(w)), _.elements[2] = m.x, _.elements[6] = m.y, _.elements[10] = m.z + 1 - r, _.elements[14] = m.w, t.visible = !1;
      const C = b.getRenderTarget(), R = b.xr.enabled, B = b.shadowMap.autoUpdate, N = b.toneMapping;
      let j = !1;
      "outputColorSpace" in b ? j = b.outputColorSpace === "srgb" : j = b.outputEncoding === 3001, b.xr.enabled = !1, b.shadowMap.autoUpdate = !1, "outputColorSpace" in b ? b.outputColorSpace = "srgb-linear" : b.outputEncoding = 3e3, b.toneMapping = Al, b.setRenderTarget(P), b.state.buffers.depth.setMask(!0), b.autoClear === !1 && b.clear(), b.render(x, E), b.xr.enabled = R, b.shadowMap.autoUpdate = B, b.toneMapping = N, "outputColorSpace" in b ? b.outputColorSpace = j ? "srgb" : "srgb-linear" : b.outputEncoding = j ? 3001 : 3e3, b.setRenderTarget(C);
      const V = M.viewport;
      V !== void 0 && b.state.viewport(V), t.visible = !0;
    }, this.getRenderTarget = function() {
      return P;
    }, this.dispose = function() {
      P.dispose(), t.material.dispose();
    };
  }
};
let pr = Ya;
hh(pr, "ReflectorShader", {
  uniforms: {
    color: {
      value: null
    },
    tDiffuse: {
      value: null
    },
    textureMatrix: {
      value: null
    }
  },
  vertexShader: (
    /* glsl */
    `
		uniform mat4 textureMatrix;
		varying vec4 vUv;

		#include <common>
		#include <logdepthbuf_pars_vertex>

		void main() {

			vUv = textureMatrix * vec4( position, 1.0 );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			#include <logdepthbuf_vertex>

		}`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform vec3 color;
		uniform sampler2D tDiffuse;
		varying vec4 vUv;

		#include <logdepthbuf_pars_fragment>

		float blendOverlay( float base, float blend ) {

			return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );

		}

		vec3 blendOverlay( vec3 base, vec3 blend ) {

			return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );

		}

		void main() {

			#include <logdepthbuf_fragment>

			vec4 base = texture2DProj( tDiffuse, vUv );
			gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );

			#include <tonemapping_fragment>
			#include <${vi >= 154 ? "colorspace_fragment" : "encodings_fragment"}>

		}`
  )
});
class fh extends he {
  constructor(e, t = {}) {
    super(e), this.isWater = !0;
    const n = this, s = t.textureWidth !== void 0 ? t.textureWidth : 512, i = t.textureHeight !== void 0 ? t.textureHeight : 512, r = t.clipBias !== void 0 ? t.clipBias : 0, a = t.alpha !== void 0 ? t.alpha : 1, l = t.time !== void 0 ? t.time : 0, c = t.waterNormals !== void 0 ? t.waterNormals : null, h = t.sunDirection !== void 0 ? t.sunDirection : new $(0.70707, 0.70707, 0), u = new Pe(t.sunColor !== void 0 ? t.sunColor : 16777215), p = new Pe(t.waterColor !== void 0 ? t.waterColor : 8355711), f = t.eye !== void 0 ? t.eye : new $(0, 0, 0), g = t.distortionScale !== void 0 ? t.distortionScale : 20, m = t.side !== void 0 ? t.side : Ss, y = t.fog !== void 0 ? t.fog : !1, d = new pi(), w = new $(), v = new $(), E = new $(), P = new Re(), T = new $(0, 0, -1), b = new it(), x = new $(), M = new $(), _ = new it(), C = new Re(), R = new At(), B = new jt(s, i), N = {
      uniforms: ns.merge([
        qn.fog,
        qn.lights,
        {
          normalSampler: { value: null },
          mirrorSampler: { value: null },
          alpha: { value: 1 },
          time: { value: 0 },
          size: { value: 1 },
          distortionScale: { value: 20 },
          textureMatrix: { value: new Re() },
          sunColor: { value: new Pe(8355711) },
          sunDirection: { value: new $(0.70707, 0.70707, 0) },
          eye: { value: new $() },
          waterColor: { value: new Pe(5592405) }
        }
      ]),
      vertexShader: (
        /* glsl */
        `
				uniform mat4 textureMatrix;
				uniform float time;

				varying vec4 mirrorCoord;
				varying vec4 worldPosition;

				#include <common>
				#include <fog_pars_vertex>
				#include <shadowmap_pars_vertex>
				#include <logdepthbuf_pars_vertex>

				void main() {
					mirrorCoord = modelMatrix * vec4( position, 1.0 );
					worldPosition = mirrorCoord.xyzw;
					mirrorCoord = textureMatrix * mirrorCoord;
					vec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );
					gl_Position = projectionMatrix * mvPosition;

				#include <beginnormal_vertex>
				#include <defaultnormal_vertex>
				#include <logdepthbuf_vertex>
				#include <fog_vertex>
				#include <shadowmap_vertex>
			}`
      ),
      fragmentShader: (
        /* glsl */
        `
				uniform sampler2D mirrorSampler;
				uniform float alpha;
				uniform float time;
				uniform float size;
				uniform float distortionScale;
				uniform sampler2D normalSampler;
				uniform vec3 sunColor;
				uniform vec3 sunDirection;
				uniform vec3 eye;
				uniform vec3 waterColor;

				varying vec4 mirrorCoord;
				varying vec4 worldPosition;

				vec4 getNoise( vec2 uv ) {
					vec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);
					vec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );
					vec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );
					vec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );
					vec4 noise = texture2D( normalSampler, uv0 ) +
						texture2D( normalSampler, uv1 ) +
						texture2D( normalSampler, uv2 ) +
						texture2D( normalSampler, uv3 );
					return noise * 0.5 - 1.0;
				}

				void sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {
					vec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );
					float direction = max( 0.0, dot( eyeDirection, reflection ) );
					specularColor += pow( direction, shiny ) * sunColor * spec;
					diffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;
				}

				#include <common>
				#include <packing>
				#include <bsdfs>
				#include <fog_pars_fragment>
				#include <logdepthbuf_pars_fragment>
				#include <lights_pars_begin>
				#include <shadowmap_pars_fragment>
				#include <shadowmask_pars_fragment>

				void main() {

					#include <logdepthbuf_fragment>
					vec4 noise = getNoise( worldPosition.xz * size );
					vec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );

					vec3 diffuseLight = vec3(0.0);
					vec3 specularLight = vec3(0.0);

					vec3 worldToEye = eye-worldPosition.xyz;
					vec3 eyeDirection = normalize( worldToEye );
					sunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );

					float distance = length(worldToEye);

					vec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;
					vec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );

					float theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );
					float rf0 = 0.3;
					float reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );
					vec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;
					vec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);
					vec3 outgoingLight = albedo;
					gl_FragColor = vec4( outgoingLight, alpha );

					#include <tonemapping_fragment>
					#include <${parseInt(di.replace(/\D+/g, "")) >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
					#include <fog_fragment>	
				}`
      )
    }, j = new Lt({
      fragmentShader: N.fragmentShader,
      vertexShader: N.vertexShader,
      uniforms: ns.clone(N.uniforms),
      lights: !0,
      side: m,
      fog: y
    });
    j.uniforms.mirrorSampler.value = B.texture, j.uniforms.textureMatrix.value = C, j.uniforms.alpha.value = a, j.uniforms.time.value = l, j.uniforms.normalSampler.value = c, j.uniforms.sunColor.value = u, j.uniforms.waterColor.value = p, j.uniforms.sunDirection.value = h, j.uniforms.distortionScale.value = g, j.uniforms.eye.value = f, n.material = j, n.onBeforeRender = function(V, Q, Z) {
      if (v.setFromMatrixPosition(n.matrixWorld), E.setFromMatrixPosition(Z.matrixWorld), P.extractRotation(n.matrixWorld), w.set(0, 0, 1), w.applyMatrix4(P), x.subVectors(v, E), x.dot(w) > 0)
        return;
      x.reflect(w).negate(), x.add(v), P.extractRotation(Z.matrixWorld), T.set(0, 0, -1), T.applyMatrix4(P), T.add(E), M.subVectors(v, T), M.reflect(w).negate(), M.add(v), R.position.copy(x), R.up.set(0, 1, 0), R.up.applyMatrix4(P), R.up.reflect(w), R.lookAt(M), R.far = Z.far, R.updateMatrixWorld(), R.projectionMatrix.copy(Z.projectionMatrix), C.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), C.multiply(R.projectionMatrix), C.multiply(R.matrixWorldInverse), d.setFromNormalAndCoplanarPoint(w, v), d.applyMatrix4(R.matrixWorldInverse), b.set(d.normal.x, d.normal.y, d.normal.z, d.constant);
      const ne = R.projectionMatrix;
      _.x = (Math.sign(b.x) + ne.elements[8]) / ne.elements[0], _.y = (Math.sign(b.y) + ne.elements[9]) / ne.elements[5], _.z = -1, _.w = (1 + ne.elements[10]) / ne.elements[14], b.multiplyScalar(2 / b.dot(_)), ne.elements[2] = b.x, ne.elements[6] = b.y, ne.elements[10] = b.z + 1 - r, ne.elements[14] = b.w, f.setFromMatrixPosition(Z.matrixWorld);
      const te = V.getRenderTarget(), le = V.xr.enabled, ae = V.shadowMap.autoUpdate;
      n.visible = !1, V.xr.enabled = !1, V.shadowMap.autoUpdate = !1, V.setRenderTarget(B), V.state.buffers.depth.setMask(!0), V.autoClear === !1 && V.clear(), V.render(Q, R), n.visible = !0, V.xr.enabled = le, V.shadowMap.autoUpdate = ae, V.setRenderTarget(te);
      const Te = Z.viewport;
      Te !== void 0 && V.state.viewport(Te);
    };
  }
}
var dh = Object.defineProperty, ph = (o, e, t) => e in o ? dh(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, Xa = (o, e, t) => (ph(o, typeof e != "symbol" ? e + "" : e, t), t);
const ri = {
  uniforms: {
    turbidity: { value: 2 },
    rayleigh: { value: 1 },
    mieCoefficient: { value: 5e-3 },
    mieDirectionalG: { value: 0.8 },
    sunPosition: { value: new $() },
    up: { value: new $(0, 1, 0) }
  },
  vertexShader: (
    /* glsl */
    `
      uniform vec3 sunPosition;
      uniform float rayleigh;
      uniform float turbidity;
      uniform float mieCoefficient;
      uniform vec3 up;

      varying vec3 vWorldPosition;
      varying vec3 vSunDirection;
      varying float vSunfade;
      varying vec3 vBetaR;
      varying vec3 vBetaM;
      varying float vSunE;

      // constants for atmospheric scattering
      const float e = 2.71828182845904523536028747135266249775724709369995957;
      const float pi = 3.141592653589793238462643383279502884197169;

      // wavelength of used primaries, according to preetham
      const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );
      // this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:
      // (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))
      const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );

      // mie stuff
      // K coefficient for the primaries
      const float v = 4.0;
      const vec3 K = vec3( 0.686, 0.678, 0.666 );
      // MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K
      const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );

      // earth shadow hack
      // cutoffAngle = pi / 1.95;
      const float cutoffAngle = 1.6110731556870734;
      const float steepness = 1.5;
      const float EE = 1000.0;

      float sunIntensity( float zenithAngleCos ) {
        zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );
        return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );
      }

      vec3 totalMie( float T ) {
        float c = ( 0.2 * T ) * 10E-18;
        return 0.434 * c * MieConst;
      }

      void main() {

        vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
        vWorldPosition = worldPosition.xyz;

        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        gl_Position.z = gl_Position.w; // set z to camera.far

        vSunDirection = normalize( sunPosition );

        vSunE = sunIntensity( dot( vSunDirection, up ) );

        vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );

        float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );

      // extinction (absorbtion + out scattering)
      // rayleigh coefficients
        vBetaR = totalRayleigh * rayleighCoefficient;

      // mie coefficients
        vBetaM = totalMie( turbidity ) * mieCoefficient;

      }
    `
  ),
  fragmentShader: (
    /* glsl */
    `
      varying vec3 vWorldPosition;
      varying vec3 vSunDirection;
      varying float vSunfade;
      varying vec3 vBetaR;
      varying vec3 vBetaM;
      varying float vSunE;

      uniform float mieDirectionalG;
      uniform vec3 up;

      const vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );

      // constants for atmospheric scattering
      const float pi = 3.141592653589793238462643383279502884197169;

      const float n = 1.0003; // refractive index of air
      const float N = 2.545E25; // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)

      // optical length at zenith for molecules
      const float rayleighZenithLength = 8.4E3;
      const float mieZenithLength = 1.25E3;
      // 66 arc seconds -> degrees, and the cosine of that
      const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;

      // 3.0 / ( 16.0 * pi )
      const float THREE_OVER_SIXTEENPI = 0.05968310365946075;
      // 1.0 / ( 4.0 * pi )
      const float ONE_OVER_FOURPI = 0.07957747154594767;

      float rayleighPhase( float cosTheta ) {
        return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );
      }

      float hgPhase( float cosTheta, float g ) {
        float g2 = pow( g, 2.0 );
        float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );
        return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );
      }

      void main() {

        vec3 direction = normalize( vWorldPosition - cameraPos );

      // optical length
      // cutoff angle at 90 to avoid singularity in next formula.
        float zenithAngle = acos( max( 0.0, dot( up, direction ) ) );
        float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );
        float sR = rayleighZenithLength * inverse;
        float sM = mieZenithLength * inverse;

      // combined extinction factor
        vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );

      // in scattering
        float cosTheta = dot( direction, vSunDirection );

        float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );
        vec3 betaRTheta = vBetaR * rPhase;

        float mPhase = hgPhase( cosTheta, mieDirectionalG );
        vec3 betaMTheta = vBetaM * mPhase;

        vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );
        Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );

      // nightsky
        float theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]
        float phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]
        vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );
        vec3 L0 = vec3( 0.1 ) * Fex;

      // composition + solar disc
        float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );
        L0 += ( vSunE * 19000.0 * Fex ) * sundisk;

        vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );

        vec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );

        gl_FragColor = vec4( retColor, 1.0 );

      #include <tonemapping_fragment>
      #include <${vi >= 154 ? "colorspace_fragment" : "encodings_fragment"}>

      }
    `
  )
}, Wa = new Lt({
  name: "SkyShader",
  fragmentShader: ri.fragmentShader,
  vertexShader: ri.vertexShader,
  uniforms: ns.clone(ri.uniforms),
  side: Pl,
  depthWrite: !1
});
class Fr extends he {
  constructor() {
    super(new Kt(1, 1, 1), Wa);
  }
}
Xa(Fr, "SkyShader", ri);
Xa(Fr, "material", Wa);
const et = new Cl(), Vs = new $();
class mh {
  constructor(e) {
    let t = e.geometry;
    t.index && (console.warn("THREE.MeshSurfaceSampler: Converting geometry to non-indexed BufferGeometry."), t = t.toNonIndexed()), this.geometry = t, this.randomFunction = Math.random, this.positionAttribute = this.geometry.getAttribute("position"), this.colorAttribute = this.geometry.getAttribute("color"), this.weightAttribute = null, this.distribution = null;
  }
  setWeightAttribute(e) {
    return this.weightAttribute = e ? this.geometry.getAttribute(e) : null, this;
  }
  build() {
    const e = this.positionAttribute, t = this.weightAttribute, n = new Float32Array(e.count / 3);
    for (let i = 0; i < e.count; i += 3) {
      let r = 1;
      t && (r = t.getX(i) + t.getX(i + 1) + t.getX(i + 2)), et.a.fromBufferAttribute(e, i), et.b.fromBufferAttribute(e, i + 1), et.c.fromBufferAttribute(e, i + 2), r *= et.getArea(), n[i / 3] = r;
    }
    this.distribution = new Float32Array(e.count / 3);
    let s = 0;
    for (let i = 0; i < n.length; i++)
      s += n[i], this.distribution[i] = s;
    return this;
  }
  setRandomGenerator(e) {
    return this.randomFunction = e, this;
  }
  sample(e, t, n) {
    const s = this.sampleFaceIndex();
    return this.sampleFace(s, e, t, n);
  }
  sampleFaceIndex() {
    const e = this.distribution[this.distribution.length - 1];
    return this.binarySearch(this.randomFunction() * e);
  }
  binarySearch(e) {
    const t = this.distribution;
    let n = 0, s = t.length - 1, i = -1;
    for (; n <= s; ) {
      const r = Math.ceil((n + s) / 2);
      if (r === 0 || t[r - 1] <= e && t[r] > e) {
        i = r;
        break;
      } else e < t[r] ? s = r - 1 : n = r + 1;
    }
    return i;
  }
  sampleFace(e, t, n, s) {
    let i = this.randomFunction(), r = this.randomFunction();
    return i + r > 1 && (i = 1 - i, r = 1 - r), et.a.fromBufferAttribute(this.positionAttribute, e * 3), et.b.fromBufferAttribute(this.positionAttribute, e * 3 + 1), et.c.fromBufferAttribute(this.positionAttribute, e * 3 + 2), t.set(0, 0, 0).addScaledVector(et.a, i).addScaledVector(et.b, r).addScaledVector(et.c, 1 - (i + r)), n !== void 0 && et.getNormal(n), s !== void 0 && this.colorAttribute !== void 0 && (et.a.fromBufferAttribute(this.colorAttribute, e * 3), et.b.fromBufferAttribute(this.colorAttribute, e * 3 + 1), et.c.fromBufferAttribute(this.colorAttribute, e * 3 + 2), Vs.set(0, 0, 0).addScaledVector(et.a, i).addScaledVector(et.b, r).addScaledVector(et.c, 1 - (i + r)), s.r = Vs.x, s.g = Vs.y, s.b = Vs.z), this;
  }
}
var gh = Object.defineProperty, yh = (o, e, t) => e in o ? gh(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, K = (o, e, t) => (yh(o, typeof e != "symbol" ? e + "" : e, t), t);
class vh extends Pt {
  constructor(e, t) {
    super(), K(this, "isTransformControls", !0), K(this, "visible", !1), K(this, "domElement"), K(this, "raycaster", new da()), K(this, "gizmo"), K(this, "plane"), K(this, "tempVector", new $()), K(this, "tempVector2", new $()), K(this, "tempQuaternion", new ze()), K(this, "unit", {
      X: new $(1, 0, 0),
      Y: new $(0, 1, 0),
      Z: new $(0, 0, 1)
    }), K(this, "pointStart", new $()), K(this, "pointEnd", new $()), K(this, "offset", new $()), K(this, "rotationAxis", new $()), K(this, "startNorm", new $()), K(this, "endNorm", new $()), K(this, "rotationAngle", 0), K(this, "cameraPosition", new $()), K(this, "cameraQuaternion", new ze()), K(this, "cameraScale", new $()), K(this, "parentPosition", new $()), K(this, "parentQuaternion", new ze()), K(this, "parentQuaternionInv", new ze()), K(this, "parentScale", new $()), K(this, "worldPositionStart", new $()), K(this, "worldQuaternionStart", new ze()), K(this, "worldScaleStart", new $()), K(this, "worldPosition", new $()), K(this, "worldQuaternion", new ze()), K(this, "worldQuaternionInv", new ze()), K(this, "worldScale", new $()), K(this, "eye", new $()), K(this, "positionStart", new $()), K(this, "quaternionStart", new ze()), K(this, "scaleStart", new $()), K(this, "camera"), K(this, "object"), K(this, "enabled", !0), K(this, "axis", null), K(this, "mode", "translate"), K(this, "translationSnap", null), K(this, "rotationSnap", null), K(this, "scaleSnap", null), K(this, "space", "world"), K(this, "size", 1), K(this, "dragging", !1), K(this, "showX", !0), K(this, "showY", !0), K(this, "showZ", !0), K(this, "changeEvent", { type: "change" }), K(this, "mouseDownEvent", { type: "mouseDown", mode: this.mode }), K(this, "mouseUpEvent", { type: "mouseUp", mode: this.mode }), K(this, "objectChangeEvent", { type: "objectChange" }), K(this, "intersectObjectWithRay", (s, i, r) => {
      const a = i.intersectObject(s, !0);
      for (let l = 0; l < a.length; l++)
        if (a[l].object.visible || r)
          return a[l];
      return !1;
    }), K(this, "attach", (s) => (this.object = s, this.visible = !0, this)), K(this, "detach", () => (this.object = void 0, this.visible = !1, this.axis = null, this)), K(this, "reset", () => this.enabled ? (this.dragging && this.object !== void 0 && (this.object.position.copy(this.positionStart), this.object.quaternion.copy(this.quaternionStart), this.object.scale.copy(this.scaleStart), this.dispatchEvent(this.changeEvent), this.dispatchEvent(this.objectChangeEvent), this.pointStart.copy(this.pointEnd)), this) : this), K(this, "updateMatrixWorld", () => {
      this.object !== void 0 && (this.object.updateMatrixWorld(), this.object.parent === null ? console.error("TransformControls: The attached 3D object must be a part of the scene graph.") : this.object.parent.matrixWorld.decompose(this.parentPosition, this.parentQuaternion, this.parentScale), this.object.matrixWorld.decompose(this.worldPosition, this.worldQuaternion, this.worldScale), this.parentQuaternionInv.copy(this.parentQuaternion).invert(), this.worldQuaternionInv.copy(this.worldQuaternion).invert()), this.camera.updateMatrixWorld(), this.camera.matrixWorld.decompose(this.cameraPosition, this.cameraQuaternion, this.cameraScale), this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(), super.updateMatrixWorld();
    }), K(this, "pointerHover", (s) => {
      if (this.object === void 0 || this.dragging === !0)
        return;
      this.raycaster.setFromCamera(s, this.camera);
      const i = this.intersectObjectWithRay(this.gizmo.picker[this.mode], this.raycaster);
      i ? this.axis = i.object.name : this.axis = null;
    }), K(this, "pointerDown", (s) => {
      if (!(this.object === void 0 || this.dragging === !0 || s.button !== 0) && this.axis !== null) {
        this.raycaster.setFromCamera(s, this.camera);
        const i = this.intersectObjectWithRay(this.plane, this.raycaster, !0);
        if (i) {
          let r = this.space;
          if (this.mode === "scale" ? r = "local" : (this.axis === "E" || this.axis === "XYZE" || this.axis === "XYZ") && (r = "world"), r === "local" && this.mode === "rotate") {
            const a = this.rotationSnap;
            this.axis === "X" && a && (this.object.rotation.x = Math.round(this.object.rotation.x / a) * a), this.axis === "Y" && a && (this.object.rotation.y = Math.round(this.object.rotation.y / a) * a), this.axis === "Z" && a && (this.object.rotation.z = Math.round(this.object.rotation.z / a) * a);
          }
          this.object.updateMatrixWorld(), this.object.parent && this.object.parent.updateMatrixWorld(), this.positionStart.copy(this.object.position), this.quaternionStart.copy(this.object.quaternion), this.scaleStart.copy(this.object.scale), this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this.worldScaleStart), this.pointStart.copy(i.point).sub(this.worldPositionStart);
        }
        this.dragging = !0, this.mouseDownEvent.mode = this.mode, this.dispatchEvent(this.mouseDownEvent);
      }
    }), K(this, "pointerMove", (s) => {
      const i = this.axis, r = this.mode, a = this.object;
      let l = this.space;
      if (r === "scale" ? l = "local" : (i === "E" || i === "XYZE" || i === "XYZ") && (l = "world"), a === void 0 || i === null || this.dragging === !1 || s.button !== -1)
        return;
      this.raycaster.setFromCamera(s, this.camera);
      const c = this.intersectObjectWithRay(this.plane, this.raycaster, !0);
      if (c) {
        if (this.pointEnd.copy(c.point).sub(this.worldPositionStart), r === "translate")
          this.offset.copy(this.pointEnd).sub(this.pointStart), l === "local" && i !== "XYZ" && this.offset.applyQuaternion(this.worldQuaternionInv), i.indexOf("X") === -1 && (this.offset.x = 0), i.indexOf("Y") === -1 && (this.offset.y = 0), i.indexOf("Z") === -1 && (this.offset.z = 0), l === "local" && i !== "XYZ" ? this.offset.applyQuaternion(this.quaternionStart).divide(this.parentScale) : this.offset.applyQuaternion(this.parentQuaternionInv).divide(this.parentScale), a.position.copy(this.offset).add(this.positionStart), this.translationSnap && (l === "local" && (a.position.applyQuaternion(this.tempQuaternion.copy(this.quaternionStart).invert()), i.search("X") !== -1 && (a.position.x = Math.round(a.position.x / this.translationSnap) * this.translationSnap), i.search("Y") !== -1 && (a.position.y = Math.round(a.position.y / this.translationSnap) * this.translationSnap), i.search("Z") !== -1 && (a.position.z = Math.round(a.position.z / this.translationSnap) * this.translationSnap), a.position.applyQuaternion(this.quaternionStart)), l === "world" && (a.parent && a.position.add(this.tempVector.setFromMatrixPosition(a.parent.matrixWorld)), i.search("X") !== -1 && (a.position.x = Math.round(a.position.x / this.translationSnap) * this.translationSnap), i.search("Y") !== -1 && (a.position.y = Math.round(a.position.y / this.translationSnap) * this.translationSnap), i.search("Z") !== -1 && (a.position.z = Math.round(a.position.z / this.translationSnap) * this.translationSnap), a.parent && a.position.sub(this.tempVector.setFromMatrixPosition(a.parent.matrixWorld))));
        else if (r === "scale") {
          if (i.search("XYZ") !== -1) {
            let h = this.pointEnd.length() / this.pointStart.length();
            this.pointEnd.dot(this.pointStart) < 0 && (h *= -1), this.tempVector2.set(h, h, h);
          } else
            this.tempVector.copy(this.pointStart), this.tempVector2.copy(this.pointEnd), this.tempVector.applyQuaternion(this.worldQuaternionInv), this.tempVector2.applyQuaternion(this.worldQuaternionInv), this.tempVector2.divide(this.tempVector), i.search("X") === -1 && (this.tempVector2.x = 1), i.search("Y") === -1 && (this.tempVector2.y = 1), i.search("Z") === -1 && (this.tempVector2.z = 1);
          a.scale.copy(this.scaleStart).multiply(this.tempVector2), this.scaleSnap && this.object && (i.search("X") !== -1 && (this.object.scale.x = Math.round(a.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap), i.search("Y") !== -1 && (a.scale.y = Math.round(a.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap), i.search("Z") !== -1 && (a.scale.z = Math.round(a.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap));
        } else if (r === "rotate") {
          this.offset.copy(this.pointEnd).sub(this.pointStart);
          const h = 20 / this.worldPosition.distanceTo(this.tempVector.setFromMatrixPosition(this.camera.matrixWorld));
          i === "E" ? (this.rotationAxis.copy(this.eye), this.rotationAngle = this.pointEnd.angleTo(this.pointStart), this.startNorm.copy(this.pointStart).normalize(), this.endNorm.copy(this.pointEnd).normalize(), this.rotationAngle *= this.endNorm.cross(this.startNorm).dot(this.eye) < 0 ? 1 : -1) : i === "XYZE" ? (this.rotationAxis.copy(this.offset).cross(this.eye).normalize(), this.rotationAngle = this.offset.dot(this.tempVector.copy(this.rotationAxis).cross(this.eye)) * h) : (i === "X" || i === "Y" || i === "Z") && (this.rotationAxis.copy(this.unit[i]), this.tempVector.copy(this.unit[i]), l === "local" && this.tempVector.applyQuaternion(this.worldQuaternion), this.rotationAngle = this.offset.dot(this.tempVector.cross(this.eye).normalize()) * h), this.rotationSnap && (this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap), l === "local" && i !== "E" && i !== "XYZE" ? (a.quaternion.copy(this.quaternionStart), a.quaternion.multiply(this.tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize()) : (this.rotationAxis.applyQuaternion(this.parentQuaternionInv), a.quaternion.copy(this.tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle)), a.quaternion.multiply(this.quaternionStart).normalize());
        }
        this.dispatchEvent(this.changeEvent), this.dispatchEvent(this.objectChangeEvent);
      }
    }), K(this, "pointerUp", (s) => {
      s.button === 0 && (this.dragging && this.axis !== null && (this.mouseUpEvent.mode = this.mode, this.dispatchEvent(this.mouseUpEvent)), this.dragging = !1, this.axis = null);
    }), K(this, "getPointer", (s) => {
      var i;
      if (this.domElement && ((i = this.domElement.ownerDocument) != null && i.pointerLockElement))
        return {
          x: 0,
          y: 0,
          button: s.button
        };
      {
        const r = s.changedTouches ? s.changedTouches[0] : s, a = this.domElement.getBoundingClientRect();
        return {
          x: (r.clientX - a.left) / a.width * 2 - 1,
          y: -(r.clientY - a.top) / a.height * 2 + 1,
          button: s.button
        };
      }
    }), K(this, "onPointerHover", (s) => {
      if (this.enabled)
        switch (s.pointerType) {
          case "mouse":
          case "pen":
            this.pointerHover(this.getPointer(s));
            break;
        }
    }), K(this, "onPointerDown", (s) => {
      !this.enabled || !this.domElement || (this.domElement.style.touchAction = "none", this.domElement.ownerDocument.addEventListener("pointermove", this.onPointerMove), this.pointerHover(this.getPointer(s)), this.pointerDown(this.getPointer(s)));
    }), K(this, "onPointerMove", (s) => {
      this.enabled && this.pointerMove(this.getPointer(s));
    }), K(this, "onPointerUp", (s) => {
      !this.enabled || !this.domElement || (this.domElement.style.touchAction = "", this.domElement.ownerDocument.removeEventListener("pointermove", this.onPointerMove), this.pointerUp(this.getPointer(s)));
    }), K(this, "getMode", () => this.mode), K(this, "setMode", (s) => {
      this.mode = s;
    }), K(this, "setTranslationSnap", (s) => {
      this.translationSnap = s;
    }), K(this, "setRotationSnap", (s) => {
      this.rotationSnap = s;
    }), K(this, "setScaleSnap", (s) => {
      this.scaleSnap = s;
    }), K(this, "setSize", (s) => {
      this.size = s;
    }), K(this, "setSpace", (s) => {
      this.space = s;
    }), K(this, "update", () => {
      console.warn(
        "THREE.TransformControls: update function has no more functionality and therefore has been deprecated."
      );
    }), K(this, "connect", (s) => {
      s === document && console.error(
        'THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'
      ), this.domElement = s, this.domElement.addEventListener("pointerdown", this.onPointerDown), this.domElement.addEventListener("pointermove", this.onPointerHover), this.domElement.ownerDocument.addEventListener("pointerup", this.onPointerUp);
    }), K(this, "dispose", () => {
      var s, i, r, a, l, c;
      (s = this.domElement) == null || s.removeEventListener("pointerdown", this.onPointerDown), (i = this.domElement) == null || i.removeEventListener("pointermove", this.onPointerHover), (a = (r = this.domElement) == null ? void 0 : r.ownerDocument) == null || a.removeEventListener("pointermove", this.onPointerMove), (c = (l = this.domElement) == null ? void 0 : l.ownerDocument) == null || c.removeEventListener("pointerup", this.onPointerUp), this.traverse((h) => {
        const u = h;
        u.geometry && u.geometry.dispose(), u.material && u.material.dispose();
      });
    }), this.domElement = t, this.camera = e, this.gizmo = new _h(), this.add(this.gizmo), this.plane = new xh(), this.add(this.plane);
    const n = (s, i) => {
      let r = i;
      Object.defineProperty(this, s, {
        get: function() {
          return r !== void 0 ? r : i;
        },
        set: function(a) {
          r !== a && (r = a, this.plane[s] = a, this.gizmo[s] = a, this.dispatchEvent({ type: s + "-changed", value: a }), this.dispatchEvent(this.changeEvent));
        }
      }), this[s] = i, this.plane[s] = i, this.gizmo[s] = i;
    };
    n("camera", this.camera), n("object", this.object), n("enabled", this.enabled), n("axis", this.axis), n("mode", this.mode), n("translationSnap", this.translationSnap), n("rotationSnap", this.rotationSnap), n("scaleSnap", this.scaleSnap), n("space", this.space), n("size", this.size), n("dragging", this.dragging), n("showX", this.showX), n("showY", this.showY), n("showZ", this.showZ), n("worldPosition", this.worldPosition), n("worldPositionStart", this.worldPositionStart), n("worldQuaternion", this.worldQuaternion), n("worldQuaternionStart", this.worldQuaternionStart), n("cameraPosition", this.cameraPosition), n("cameraQuaternion", this.cameraQuaternion), n("pointStart", this.pointStart), n("pointEnd", this.pointEnd), n("rotationAxis", this.rotationAxis), n("rotationAngle", this.rotationAngle), n("eye", this.eye), t !== void 0 && this.connect(t);
  }
}
class _h extends Pt {
  constructor() {
    super(), K(this, "isTransformControlsGizmo", !0), K(this, "type", "TransformControlsGizmo"), K(this, "tempVector", new $(0, 0, 0)), K(this, "tempEuler", new Tn()), K(this, "alignVector", new $(0, 1, 0)), K(this, "zeroVector", new $(0, 0, 0)), K(this, "lookAtMatrix", new Re()), K(this, "tempQuaternion", new ze()), K(this, "tempQuaternion2", new ze()), K(this, "identityQuaternion", new ze()), K(this, "unitX", new $(1, 0, 0)), K(this, "unitY", new $(0, 1, 0)), K(this, "unitZ", new $(0, 0, 1)), K(this, "gizmo"), K(this, "picker"), K(this, "helper"), K(this, "rotationAxis", new $()), K(this, "cameraPosition", new $()), K(this, "worldPositionStart", new $()), K(this, "worldQuaternionStart", new ze()), K(this, "worldPosition", new $()), K(this, "worldQuaternion", new ze()), K(this, "eye", new $()), K(this, "camera", null), K(this, "enabled", !0), K(this, "axis", null), K(this, "mode", "translate"), K(this, "space", "world"), K(this, "size", 1), K(this, "dragging", !1), K(this, "showX", !0), K(this, "showY", !0), K(this, "showZ", !0), K(this, "updateMatrixWorld", () => {
      let te = this.space;
      this.mode === "scale" && (te = "local");
      const le = te === "local" ? this.worldQuaternion : this.identityQuaternion;
      this.gizmo.translate.visible = this.mode === "translate", this.gizmo.rotate.visible = this.mode === "rotate", this.gizmo.scale.visible = this.mode === "scale", this.helper.translate.visible = this.mode === "translate", this.helper.rotate.visible = this.mode === "rotate", this.helper.scale.visible = this.mode === "scale";
      let ae = [];
      ae = ae.concat(this.picker[this.mode].children), ae = ae.concat(this.gizmo[this.mode].children), ae = ae.concat(this.helper[this.mode].children);
      for (let Te = 0; Te < ae.length; Te++) {
        const I = ae[Te];
        I.visible = !0, I.rotation.set(0, 0, 0), I.position.copy(this.worldPosition);
        let k;
        if (this.camera.isOrthographicCamera ? k = (this.camera.top - this.camera.bottom) / this.camera.zoom : k = this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7), I.scale.set(1, 1, 1).multiplyScalar(k * this.size / 7), I.tag === "helper") {
          I.visible = !1, I.name === "AXIS" ? (I.position.copy(this.worldPositionStart), I.visible = !!this.axis, this.axis === "X" && (this.tempQuaternion.setFromEuler(this.tempEuler.set(0, 0, 0)), I.quaternion.copy(le).multiply(this.tempQuaternion), Math.abs(this.alignVector.copy(this.unitX).applyQuaternion(le).dot(this.eye)) > 0.9 && (I.visible = !1)), this.axis === "Y" && (this.tempQuaternion.setFromEuler(this.tempEuler.set(0, 0, Math.PI / 2)), I.quaternion.copy(le).multiply(this.tempQuaternion), Math.abs(this.alignVector.copy(this.unitY).applyQuaternion(le).dot(this.eye)) > 0.9 && (I.visible = !1)), this.axis === "Z" && (this.tempQuaternion.setFromEuler(this.tempEuler.set(0, Math.PI / 2, 0)), I.quaternion.copy(le).multiply(this.tempQuaternion), Math.abs(this.alignVector.copy(this.unitZ).applyQuaternion(le).dot(this.eye)) > 0.9 && (I.visible = !1)), this.axis === "XYZE" && (this.tempQuaternion.setFromEuler(this.tempEuler.set(0, Math.PI / 2, 0)), this.alignVector.copy(this.rotationAxis), I.quaternion.setFromRotationMatrix(
            this.lookAtMatrix.lookAt(this.zeroVector, this.alignVector, this.unitY)
          ), I.quaternion.multiply(this.tempQuaternion), I.visible = this.dragging), this.axis === "E" && (I.visible = !1)) : I.name === "START" ? (I.position.copy(this.worldPositionStart), I.visible = this.dragging) : I.name === "END" ? (I.position.copy(this.worldPosition), I.visible = this.dragging) : I.name === "DELTA" ? (I.position.copy(this.worldPositionStart), I.quaternion.copy(this.worldQuaternionStart), this.tempVector.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1), this.tempVector.applyQuaternion(this.worldQuaternionStart.clone().invert()), I.scale.copy(this.tempVector), I.visible = this.dragging) : (I.quaternion.copy(le), this.dragging ? I.position.copy(this.worldPositionStart) : I.position.copy(this.worldPosition), this.axis && (I.visible = this.axis.search(I.name) !== -1));
          continue;
        }
        I.quaternion.copy(le), this.mode === "translate" || this.mode === "scale" ? ((I.name === "X" || I.name === "XYZX") && Math.abs(this.alignVector.copy(this.unitX).applyQuaternion(le).dot(this.eye)) > 0.99 && (I.scale.set(1e-10, 1e-10, 1e-10), I.visible = !1), (I.name === "Y" || I.name === "XYZY") && Math.abs(this.alignVector.copy(this.unitY).applyQuaternion(le).dot(this.eye)) > 0.99 && (I.scale.set(1e-10, 1e-10, 1e-10), I.visible = !1), (I.name === "Z" || I.name === "XYZZ") && Math.abs(this.alignVector.copy(this.unitZ).applyQuaternion(le).dot(this.eye)) > 0.99 && (I.scale.set(1e-10, 1e-10, 1e-10), I.visible = !1), I.name === "XY" && Math.abs(this.alignVector.copy(this.unitZ).applyQuaternion(le).dot(this.eye)) < 0.2 && (I.scale.set(1e-10, 1e-10, 1e-10), I.visible = !1), I.name === "YZ" && Math.abs(this.alignVector.copy(this.unitX).applyQuaternion(le).dot(this.eye)) < 0.2 && (I.scale.set(1e-10, 1e-10, 1e-10), I.visible = !1), I.name === "XZ" && Math.abs(this.alignVector.copy(this.unitY).applyQuaternion(le).dot(this.eye)) < 0.2 && (I.scale.set(1e-10, 1e-10, 1e-10), I.visible = !1), I.name.search("X") !== -1 && (this.alignVector.copy(this.unitX).applyQuaternion(le).dot(this.eye) < 0 ? I.tag === "fwd" ? I.visible = !1 : I.scale.x *= -1 : I.tag === "bwd" && (I.visible = !1)), I.name.search("Y") !== -1 && (this.alignVector.copy(this.unitY).applyQuaternion(le).dot(this.eye) < 0 ? I.tag === "fwd" ? I.visible = !1 : I.scale.y *= -1 : I.tag === "bwd" && (I.visible = !1)), I.name.search("Z") !== -1 && (this.alignVector.copy(this.unitZ).applyQuaternion(le).dot(this.eye) < 0 ? I.tag === "fwd" ? I.visible = !1 : I.scale.z *= -1 : I.tag === "bwd" && (I.visible = !1))) : this.mode === "rotate" && (this.tempQuaternion2.copy(le), this.alignVector.copy(this.eye).applyQuaternion(this.tempQuaternion.copy(le).invert()), I.name.search("E") !== -1 && I.quaternion.setFromRotationMatrix(this.lookAtMatrix.lookAt(this.eye, this.zeroVector, this.unitY)), I.name === "X" && (this.tempQuaternion.setFromAxisAngle(this.unitX, Math.atan2(-this.alignVector.y, this.alignVector.z)), this.tempQuaternion.multiplyQuaternions(this.tempQuaternion2, this.tempQuaternion), I.quaternion.copy(this.tempQuaternion)), I.name === "Y" && (this.tempQuaternion.setFromAxisAngle(this.unitY, Math.atan2(this.alignVector.x, this.alignVector.z)), this.tempQuaternion.multiplyQuaternions(this.tempQuaternion2, this.tempQuaternion), I.quaternion.copy(this.tempQuaternion)), I.name === "Z" && (this.tempQuaternion.setFromAxisAngle(this.unitZ, Math.atan2(this.alignVector.y, this.alignVector.x)), this.tempQuaternion.multiplyQuaternions(this.tempQuaternion2, this.tempQuaternion), I.quaternion.copy(this.tempQuaternion))), I.visible = I.visible && (I.name.indexOf("X") === -1 || this.showX), I.visible = I.visible && (I.name.indexOf("Y") === -1 || this.showY), I.visible = I.visible && (I.name.indexOf("Z") === -1 || this.showZ), I.visible = I.visible && (I.name.indexOf("E") === -1 || this.showX && this.showY && this.showZ), I.material.tempOpacity = I.material.tempOpacity || I.material.opacity, I.material.tempColor = I.material.tempColor || I.material.color.clone(), I.material.color.copy(I.material.tempColor), I.material.opacity = I.material.tempOpacity, this.enabled ? this.axis && (I.name === this.axis ? (I.material.opacity = 1, I.material.color.lerp(new Pe(1, 1, 1), 0.5)) : this.axis.split("").some(function(D) {
          return I.name === D;
        }) ? (I.material.opacity = 1, I.material.color.lerp(new Pe(1, 1, 1), 0.5)) : (I.material.opacity *= 0.25, I.material.color.lerp(new Pe(1, 1, 1), 0.5))) : (I.material.opacity *= 0.5, I.material.color.lerp(new Pe(1, 1, 1), 0.5));
      }
      super.updateMatrixWorld();
    });
    const e = new Qt({
      depthTest: !1,
      depthWrite: !1,
      transparent: !0,
      side: tn,
      fog: !1,
      toneMapped: !1
    }), t = new ws({
      depthTest: !1,
      depthWrite: !1,
      transparent: !0,
      linewidth: 1,
      fog: !1,
      toneMapped: !1
    }), n = e.clone();
    n.opacity = 0.15;
    const s = e.clone();
    s.opacity = 0.33;
    const i = e.clone();
    i.color.set(16711680);
    const r = e.clone();
    r.color.set(65280);
    const a = e.clone();
    a.color.set(255);
    const l = e.clone();
    l.opacity = 0.25;
    const c = l.clone();
    c.color.set(16776960);
    const h = l.clone();
    h.color.set(65535);
    const u = l.clone();
    u.color.set(16711935), e.clone().color.set(16776960);
    const f = t.clone();
    f.color.set(16711680);
    const g = t.clone();
    g.color.set(65280);
    const m = t.clone();
    m.color.set(255);
    const y = t.clone();
    y.color.set(65535);
    const d = t.clone();
    d.color.set(16711935);
    const w = t.clone();
    w.color.set(16776960);
    const v = t.clone();
    v.color.set(7895160);
    const E = w.clone();
    E.opacity = 0.25;
    const P = new Ct(0, 0.05, 0.2, 12, 1, !1), T = new Kt(0.125, 0.125, 0.125), b = new pt();
    b.setAttribute("position", new dt([0, 0, 0, 1, 0, 0], 3));
    const x = (te, le) => {
      const ae = new pt(), Te = [];
      for (let I = 0; I <= 64 * le; ++I)
        Te.push(0, Math.cos(I / 32 * Math.PI) * te, Math.sin(I / 32 * Math.PI) * te);
      return ae.setAttribute("position", new dt(Te, 3)), ae;
    }, M = () => {
      const te = new pt();
      return te.setAttribute("position", new dt([0, 0, 0, 1, 1, 1], 3)), te;
    }, _ = {
      X: [
        [new he(P, i), [1, 0, 0], [0, 0, -Math.PI / 2], null, "fwd"],
        [new he(P, i), [1, 0, 0], [0, 0, Math.PI / 2], null, "bwd"],
        [new Le(b, f)]
      ],
      Y: [
        [new he(P, r), [0, 1, 0], null, null, "fwd"],
        [new he(P, r), [0, 1, 0], [Math.PI, 0, 0], null, "bwd"],
        [new Le(b, g), null, [0, 0, Math.PI / 2]]
      ],
      Z: [
        [new he(P, a), [0, 0, 1], [Math.PI / 2, 0, 0], null, "fwd"],
        [new he(P, a), [0, 0, 1], [-Math.PI / 2, 0, 0], null, "bwd"],
        [new Le(b, m), null, [0, -Math.PI / 2, 0]]
      ],
      XYZ: [[new he(new Cn(0.1, 0), l.clone()), [0, 0, 0], [0, 0, 0]]],
      XY: [
        [new he(new zt(0.295, 0.295), c.clone()), [0.15, 0.15, 0]],
        [new Le(b, w), [0.18, 0.3, 0], null, [0.125, 1, 1]],
        [new Le(b, w), [0.3, 0.18, 0], [0, 0, Math.PI / 2], [0.125, 1, 1]]
      ],
      YZ: [
        [new he(new zt(0.295, 0.295), h.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]],
        [new Le(b, y), [0, 0.18, 0.3], [0, 0, Math.PI / 2], [0.125, 1, 1]],
        [new Le(b, y), [0, 0.3, 0.18], [0, -Math.PI / 2, 0], [0.125, 1, 1]]
      ],
      XZ: [
        [
          new he(new zt(0.295, 0.295), u.clone()),
          [0.15, 0, 0.15],
          [-Math.PI / 2, 0, 0]
        ],
        [new Le(b, d), [0.18, 0, 0.3], null, [0.125, 1, 1]],
        [new Le(b, d), [0.3, 0, 0.18], [0, -Math.PI / 2, 0], [0.125, 1, 1]]
      ]
    }, C = {
      X: [[new he(new Ct(0.2, 0, 1, 4, 1, !1), n), [0.6, 0, 0], [0, 0, -Math.PI / 2]]],
      Y: [[new he(new Ct(0.2, 0, 1, 4, 1, !1), n), [0, 0.6, 0]]],
      Z: [[new he(new Ct(0.2, 0, 1, 4, 1, !1), n), [0, 0, 0.6], [Math.PI / 2, 0, 0]]],
      XYZ: [[new he(new Cn(0.2, 0), n)]],
      XY: [[new he(new zt(0.4, 0.4), n), [0.2, 0.2, 0]]],
      YZ: [[new he(new zt(0.4, 0.4), n), [0, 0.2, 0.2], [0, Math.PI / 2, 0]]],
      XZ: [[new he(new zt(0.4, 0.4), n), [0.2, 0, 0.2], [-Math.PI / 2, 0, 0]]]
    }, R = {
      START: [[new he(new Cn(0.01, 2), s), null, null, null, "helper"]],
      END: [[new he(new Cn(0.01, 2), s), null, null, null, "helper"]],
      DELTA: [[new Le(M(), s), null, null, null, "helper"]],
      X: [[new Le(b, s.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]],
      Y: [[new Le(b, s.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]],
      Z: [[new Le(b, s.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]]
    }, B = {
      X: [
        [new Le(x(1, 0.5), f)],
        [new he(new Cn(0.04, 0), i), [0, 0, 0.99], null, [1, 3, 1]]
      ],
      Y: [
        [new Le(x(1, 0.5), g), null, [0, 0, -Math.PI / 2]],
        [new he(new Cn(0.04, 0), r), [0, 0, 0.99], null, [3, 1, 1]]
      ],
      Z: [
        [new Le(x(1, 0.5), m), null, [0, Math.PI / 2, 0]],
        [new he(new Cn(0.04, 0), a), [0.99, 0, 0], null, [1, 3, 1]]
      ],
      E: [
        [new Le(x(1.25, 1), E), null, [0, Math.PI / 2, 0]],
        [
          new he(new Ct(0.03, 0, 0.15, 4, 1, !1), E),
          [1.17, 0, 0],
          [0, 0, -Math.PI / 2],
          [1, 1, 1e-3]
        ],
        [
          new he(new Ct(0.03, 0, 0.15, 4, 1, !1), E),
          [-1.17, 0, 0],
          [0, 0, Math.PI / 2],
          [1, 1, 1e-3]
        ],
        [
          new he(new Ct(0.03, 0, 0.15, 4, 1, !1), E),
          [0, -1.17, 0],
          [Math.PI, 0, 0],
          [1, 1, 1e-3]
        ],
        [
          new he(new Ct(0.03, 0, 0.15, 4, 1, !1), E),
          [0, 1.17, 0],
          [0, 0, 0],
          [1, 1, 1e-3]
        ]
      ],
      XYZE: [[new Le(x(1, 1), v), null, [0, Math.PI / 2, 0]]]
    }, N = {
      AXIS: [[new Le(b, s.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]]
    }, j = {
      X: [[new he(new Bs(1, 0.1, 4, 24), n), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]],
      Y: [[new he(new Bs(1, 0.1, 4, 24), n), [0, 0, 0], [Math.PI / 2, 0, 0]]],
      Z: [[new he(new Bs(1, 0.1, 4, 24), n), [0, 0, 0], [0, 0, -Math.PI / 2]]],
      E: [[new he(new Bs(1.25, 0.1, 2, 24), n)]],
      XYZE: [[new he(new Rl(0.7, 10, 8), n)]]
    }, V = {
      X: [
        [new he(T, i), [0.8, 0, 0], [0, 0, -Math.PI / 2]],
        [new Le(b, f), null, null, [0.8, 1, 1]]
      ],
      Y: [
        [new he(T, r), [0, 0.8, 0]],
        [new Le(b, g), null, [0, 0, Math.PI / 2], [0.8, 1, 1]]
      ],
      Z: [
        [new he(T, a), [0, 0, 0.8], [Math.PI / 2, 0, 0]],
        [new Le(b, m), null, [0, -Math.PI / 2, 0], [0.8, 1, 1]]
      ],
      XY: [
        [new he(T, c), [0.85, 0.85, 0], null, [2, 2, 0.2]],
        [new Le(b, w), [0.855, 0.98, 0], null, [0.125, 1, 1]],
        [new Le(b, w), [0.98, 0.855, 0], [0, 0, Math.PI / 2], [0.125, 1, 1]]
      ],
      YZ: [
        [new he(T, h), [0, 0.85, 0.85], null, [0.2, 2, 2]],
        [new Le(b, y), [0, 0.855, 0.98], [0, 0, Math.PI / 2], [0.125, 1, 1]],
        [new Le(b, y), [0, 0.98, 0.855], [0, -Math.PI / 2, 0], [0.125, 1, 1]]
      ],
      XZ: [
        [new he(T, u), [0.85, 0, 0.85], null, [2, 0.2, 2]],
        [new Le(b, d), [0.855, 0, 0.98], null, [0.125, 1, 1]],
        [new Le(b, d), [0.98, 0, 0.855], [0, -Math.PI / 2, 0], [0.125, 1, 1]]
      ],
      XYZX: [[new he(new Kt(0.125, 0.125, 0.125), l.clone()), [1.1, 0, 0]]],
      XYZY: [[new he(new Kt(0.125, 0.125, 0.125), l.clone()), [0, 1.1, 0]]],
      XYZZ: [[new he(new Kt(0.125, 0.125, 0.125), l.clone()), [0, 0, 1.1]]]
    }, Q = {
      X: [[new he(new Ct(0.2, 0, 0.8, 4, 1, !1), n), [0.5, 0, 0], [0, 0, -Math.PI / 2]]],
      Y: [[new he(new Ct(0.2, 0, 0.8, 4, 1, !1), n), [0, 0.5, 0]]],
      Z: [[new he(new Ct(0.2, 0, 0.8, 4, 1, !1), n), [0, 0, 0.5], [Math.PI / 2, 0, 0]]],
      XY: [[new he(T, n), [0.85, 0.85, 0], null, [3, 3, 0.2]]],
      YZ: [[new he(T, n), [0, 0.85, 0.85], null, [0.2, 3, 3]]],
      XZ: [[new he(T, n), [0.85, 0, 0.85], null, [3, 0.2, 3]]],
      XYZX: [[new he(new Kt(0.2, 0.2, 0.2), n), [1.1, 0, 0]]],
      XYZY: [[new he(new Kt(0.2, 0.2, 0.2), n), [0, 1.1, 0]]],
      XYZZ: [[new he(new Kt(0.2, 0.2, 0.2), n), [0, 0, 1.1]]]
    }, Z = {
      X: [[new Le(b, s.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]],
      Y: [[new Le(b, s.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]],
      Z: [[new Le(b, s.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]]
    }, ne = (te) => {
      const le = new Pt();
      for (let ae in te)
        for (let Te = te[ae].length; Te--; ) {
          const I = te[ae][Te][0].clone(), k = te[ae][Te][1], D = te[ae][Te][2], O = te[ae][Te][3], z = te[ae][Te][4];
          I.name = ae, I.tag = z, k && I.position.set(k[0], k[1], k[2]), D && I.rotation.set(D[0], D[1], D[2]), O && I.scale.set(O[0], O[1], O[2]), I.updateMatrix();
          const S = I.geometry.clone();
          S.applyMatrix4(I.matrix), I.geometry = S, I.renderOrder = 1 / 0, I.position.set(0, 0, 0), I.rotation.set(0, 0, 0), I.scale.set(1, 1, 1), le.add(I);
        }
      return le;
    };
    this.gizmo = {}, this.picker = {}, this.helper = {}, this.add(this.gizmo.translate = ne(_)), this.add(this.gizmo.rotate = ne(B)), this.add(this.gizmo.scale = ne(V)), this.add(this.picker.translate = ne(C)), this.add(this.picker.rotate = ne(j)), this.add(this.picker.scale = ne(Q)), this.add(this.helper.translate = ne(R)), this.add(this.helper.rotate = ne(N)), this.add(this.helper.scale = ne(Z)), this.picker.translate.visible = !1, this.picker.rotate.visible = !1, this.picker.scale.visible = !1;
  }
}
class xh extends he {
  constructor() {
    super(
      new zt(1e5, 1e5, 2, 2),
      new Qt({
        visible: !1,
        wireframe: !0,
        side: tn,
        transparent: !0,
        opacity: 0.1,
        toneMapped: !1
      })
    ), K(this, "isTransformControlsPlane", !0), K(this, "type", "TransformControlsPlane"), K(this, "unitX", new $(1, 0, 0)), K(this, "unitY", new $(0, 1, 0)), K(this, "unitZ", new $(0, 0, 1)), K(this, "tempVector", new $()), K(this, "dirVector", new $()), K(this, "alignVector", new $()), K(this, "tempMatrix", new Re()), K(this, "identityQuaternion", new ze()), K(this, "cameraQuaternion", new ze()), K(this, "worldPosition", new $()), K(this, "worldQuaternion", new ze()), K(this, "eye", new $()), K(this, "axis", null), K(this, "mode", "translate"), K(this, "space", "world"), K(this, "updateMatrixWorld", () => {
      let e = this.space;
      switch (this.position.copy(this.worldPosition), this.mode === "scale" && (e = "local"), this.unitX.set(1, 0, 0).applyQuaternion(e === "local" ? this.worldQuaternion : this.identityQuaternion), this.unitY.set(0, 1, 0).applyQuaternion(e === "local" ? this.worldQuaternion : this.identityQuaternion), this.unitZ.set(0, 0, 1).applyQuaternion(e === "local" ? this.worldQuaternion : this.identityQuaternion), this.alignVector.copy(this.unitY), this.mode) {
        case "translate":
        case "scale":
          switch (this.axis) {
            case "X":
              this.alignVector.copy(this.eye).cross(this.unitX), this.dirVector.copy(this.unitX).cross(this.alignVector);
              break;
            case "Y":
              this.alignVector.copy(this.eye).cross(this.unitY), this.dirVector.copy(this.unitY).cross(this.alignVector);
              break;
            case "Z":
              this.alignVector.copy(this.eye).cross(this.unitZ), this.dirVector.copy(this.unitZ).cross(this.alignVector);
              break;
            case "XY":
              this.dirVector.copy(this.unitZ);
              break;
            case "YZ":
              this.dirVector.copy(this.unitX);
              break;
            case "XZ":
              this.alignVector.copy(this.unitZ), this.dirVector.copy(this.unitY);
              break;
            case "XYZ":
            case "E":
              this.dirVector.set(0, 0, 0);
              break;
          }
          break;
        case "rotate":
        default:
          this.dirVector.set(0, 0, 0);
      }
      this.dirVector.length() === 0 ? this.quaternion.copy(this.cameraQuaternion) : (this.tempMatrix.lookAt(this.tempVector.set(0, 0, 0), this.dirVector, this.alignVector), this.quaternion.setFromRotationMatrix(this.tempMatrix)), super.updateMatrixWorld();
    });
  }
}
var wh = Object.defineProperty, Th = (o, e, t) => e in o ? wh(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, Qe = (o, e, t) => (Th(o, typeof e != "symbol" ? e + "" : e, t), t);
const Hn = new Tn(0, 0, 0, "YXZ"), Gn = new $(), bh = { type: "change" }, Eh = { type: "lock" }, Mh = { type: "unlock" }, co = Math.PI / 2;
class $a extends pa {
  constructor(e, t) {
    super(), Qe(this, "camera"), Qe(this, "domElement"), Qe(this, "isLocked"), Qe(this, "minPolarAngle"), Qe(this, "maxPolarAngle"), Qe(this, "pointerSpeed"), Qe(this, "onMouseMove", (n) => {
      if (!this.domElement || this.isLocked === !1)
        return;
      const s = n.movementX || n.mozMovementX || n.webkitMovementX || 0, i = n.movementY || n.mozMovementY || n.webkitMovementY || 0;
      Hn.setFromQuaternion(this.camera.quaternion), Hn.y -= s * 2e-3 * this.pointerSpeed, Hn.x -= i * 2e-3 * this.pointerSpeed, Hn.x = Math.max(co - this.maxPolarAngle, Math.min(co - this.minPolarAngle, Hn.x)), this.camera.quaternion.setFromEuler(Hn), this.dispatchEvent(bh);
    }), Qe(this, "onPointerlockChange", () => {
      this.domElement && (this.domElement.ownerDocument.pointerLockElement === this.domElement ? (this.dispatchEvent(Eh), this.isLocked = !0) : (this.dispatchEvent(Mh), this.isLocked = !1));
    }), Qe(this, "onPointerlockError", () => {
      console.error("THREE.PointerLockControls: Unable to use Pointer Lock API");
    }), Qe(this, "connect", (n) => {
      this.domElement = n || this.domElement, this.domElement && (this.domElement.ownerDocument.addEventListener("mousemove", this.onMouseMove), this.domElement.ownerDocument.addEventListener("pointerlockchange", this.onPointerlockChange), this.domElement.ownerDocument.addEventListener("pointerlockerror", this.onPointerlockError));
    }), Qe(this, "disconnect", () => {
      this.domElement && (this.domElement.ownerDocument.removeEventListener("mousemove", this.onMouseMove), this.domElement.ownerDocument.removeEventListener("pointerlockchange", this.onPointerlockChange), this.domElement.ownerDocument.removeEventListener("pointerlockerror", this.onPointerlockError));
    }), Qe(this, "dispose", () => {
      this.disconnect();
    }), Qe(this, "getObject", () => this.camera), Qe(this, "direction", new $(0, 0, -1)), Qe(this, "getDirection", (n) => n.copy(this.direction).applyQuaternion(this.camera.quaternion)), Qe(this, "moveForward", (n) => {
      Gn.setFromMatrixColumn(this.camera.matrix, 0), Gn.crossVectors(this.camera.up, Gn), this.camera.position.addScaledVector(Gn, n);
    }), Qe(this, "moveRight", (n) => {
      Gn.setFromMatrixColumn(this.camera.matrix, 0), this.camera.position.addScaledVector(Gn, n);
    }), Qe(this, "lock", () => {
      this.domElement && this.domElement.requestPointerLock();
    }), Qe(this, "unlock", () => {
      this.domElement && this.domElement.ownerDocument.exitPointerLock();
    }), this.camera = e, this.domElement = t, this.isLocked = !1, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.pointerSpeed = 1, t && this.connect(t);
  }
}
var Sh = Object.defineProperty, Ah = (o, e, t) => e in o ? Sh(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, xe = (o, e, t) => (Ah(o, typeof e != "symbol" ? e + "" : e, t), t);
const Ys = new Il(), uo = new pi(), Ph = Math.cos(70 * (Math.PI / 180)), ho = (o, e) => (o % e + e) % e;
class Za extends pa {
  constructor(e, t) {
    super(), xe(this, "object"), xe(this, "domElement"), xe(this, "enabled", !0), xe(this, "target", new $()), xe(this, "minDistance", 0), xe(this, "maxDistance", 1 / 0), xe(this, "minZoom", 0), xe(this, "maxZoom", 1 / 0), xe(this, "minPolarAngle", 0), xe(this, "maxPolarAngle", Math.PI), xe(this, "minAzimuthAngle", -1 / 0), xe(this, "maxAzimuthAngle", 1 / 0), xe(this, "enableDamping", !1), xe(this, "dampingFactor", 0.05), xe(this, "enableZoom", !0), xe(this, "zoomSpeed", 1), xe(this, "enableRotate", !0), xe(this, "rotateSpeed", 1), xe(this, "enablePan", !0), xe(this, "panSpeed", 1), xe(this, "screenSpacePanning", !0), xe(this, "keyPanSpeed", 7), xe(this, "zoomToCursor", !1), xe(this, "autoRotate", !1), xe(this, "autoRotateSpeed", 2), xe(this, "reverseOrbit", !1), xe(this, "reverseHorizontalOrbit", !1), xe(this, "reverseVerticalOrbit", !1), xe(this, "keys", { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }), xe(this, "mouseButtons", {
      LEFT: _n.ROTATE,
      MIDDLE: _n.DOLLY,
      RIGHT: _n.PAN
    }), xe(this, "touches", { ONE: Ht.ROTATE, TWO: Ht.DOLLY_PAN }), xe(this, "target0"), xe(this, "position0"), xe(this, "zoom0"), xe(this, "_domElementKeyEvents", null), xe(this, "getPolarAngle"), xe(this, "getAzimuthalAngle"), xe(this, "setPolarAngle"), xe(this, "setAzimuthalAngle"), xe(this, "getDistance"), xe(this, "listenToKeyEvents"), xe(this, "stopListenToKeyEvents"), xe(this, "saveState"), xe(this, "reset"), xe(this, "update"), xe(this, "connect"), xe(this, "dispose"), this.object = e, this.domElement = t, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this.getPolarAngle = () => h.phi, this.getAzimuthalAngle = () => h.theta, this.setPolarAngle = (W) => {
      let re = ho(W, 2 * Math.PI), be = h.phi;
      be < 0 && (be += 2 * Math.PI), re < 0 && (re += 2 * Math.PI);
      let Be = Math.abs(re - be);
      2 * Math.PI - Be < Be && (re < be ? re += 2 * Math.PI : be += 2 * Math.PI), u.phi = re - be, n.update();
    }, this.setAzimuthalAngle = (W) => {
      let re = ho(W, 2 * Math.PI), be = h.theta;
      be < 0 && (be += 2 * Math.PI), re < 0 && (re += 2 * Math.PI);
      let Be = Math.abs(re - be);
      2 * Math.PI - Be < Be && (re < be ? re += 2 * Math.PI : be += 2 * Math.PI), u.theta = re - be, n.update();
    }, this.getDistance = () => n.object.position.distanceTo(n.target), this.listenToKeyEvents = (W) => {
      W.addEventListener("keydown", ln), this._domElementKeyEvents = W;
    }, this.stopListenToKeyEvents = () => {
      this._domElementKeyEvents.removeEventListener("keydown", ln), this._domElementKeyEvents = null;
    }, this.saveState = () => {
      n.target0.copy(n.target), n.position0.copy(n.object.position), n.zoom0 = n.object.zoom;
    }, this.reset = () => {
      n.target.copy(n.target0), n.object.position.copy(n.position0), n.object.zoom = n.zoom0, n.object.updateProjectionMatrix(), n.dispatchEvent(s), n.update(), l = a.NONE;
    }, this.update = (() => {
      const W = new $(), re = new $(0, 1, 0), be = new ze().setFromUnitVectors(e.up, re), Be = be.clone().invert(), Je = new $(), Wt = new ze(), un = 2 * Math.PI;
      return function() {
        const Vr = n.object.position;
        be.setFromUnitVectors(e.up, re), Be.copy(be).invert(), W.copy(Vr).sub(n.target), W.applyQuaternion(be), h.setFromVector3(W), n.autoRotate && l === a.NONE && N(R()), n.enableDamping ? (h.theta += u.theta * n.dampingFactor, h.phi += u.phi * n.dampingFactor) : (h.theta += u.theta, h.phi += u.phi);
        let $t = n.minAzimuthAngle, Zt = n.maxAzimuthAngle;
        isFinite($t) && isFinite(Zt) && ($t < -Math.PI ? $t += un : $t > Math.PI && ($t -= un), Zt < -Math.PI ? Zt += un : Zt > Math.PI && (Zt -= un), $t <= Zt ? h.theta = Math.max($t, Math.min(Zt, h.theta)) : h.theta = h.theta > ($t + Zt) / 2 ? Math.max($t, h.theta) : Math.min(Zt, h.theta)), h.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, h.phi)), h.makeSafe(), n.enableDamping === !0 ? n.target.addScaledVector(f, n.dampingFactor) : n.target.add(f), n.zoomToCursor && M || n.object.isOrthographicCamera ? h.radius = ae(h.radius) : h.radius = ae(h.radius * p), W.setFromSpherical(h), W.applyQuaternion(Be), Vr.copy(n.target).add(W), n.object.matrixAutoUpdate || n.object.updateMatrix(), n.object.lookAt(n.target), n.enableDamping === !0 ? (u.theta *= 1 - n.dampingFactor, u.phi *= 1 - n.dampingFactor, f.multiplyScalar(1 - n.dampingFactor)) : (u.set(0, 0, 0), f.set(0, 0, 0));
        let is = !1;
        if (n.zoomToCursor && M) {
          let rs = null;
          if (n.object instanceof At && n.object.isPerspectiveCamera) {
            const os = W.length();
            rs = ae(os * p);
            const ks = os - rs;
            n.object.position.addScaledVector(b, ks), n.object.updateMatrixWorld();
          } else if (n.object.isOrthographicCamera) {
            const os = new $(x.x, x.y, 0);
            os.unproject(n.object), n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / p)), n.object.updateProjectionMatrix(), is = !0;
            const ks = new $(x.x, x.y, 0);
            ks.unproject(n.object), n.object.position.sub(ks).add(os), n.object.updateMatrixWorld(), rs = W.length();
          } else
            console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."), n.zoomToCursor = !1;
          rs !== null && (n.screenSpacePanning ? n.target.set(0, 0, -1).transformDirection(n.object.matrix).multiplyScalar(rs).add(n.object.position) : (Ys.origin.copy(n.object.position), Ys.direction.set(0, 0, -1).transformDirection(n.object.matrix), Math.abs(n.object.up.dot(Ys.direction)) < Ph ? e.lookAt(n.target) : (uo.setFromNormalAndCoplanarPoint(n.object.up, n.target), Ys.intersectPlane(uo, n.target))));
        } else n.object instanceof en && n.object.isOrthographicCamera && (is = p !== 1, is && (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / p)), n.object.updateProjectionMatrix()));
        return p = 1, M = !1, is || Je.distanceToSquared(n.object.position) > c || 8 * (1 - Wt.dot(n.object.quaternion)) > c ? (n.dispatchEvent(s), Je.copy(n.object.position), Wt.copy(n.object.quaternion), is = !1, !0) : !1;
      };
    })(), this.connect = (W) => {
      n.domElement = W, n.domElement.style.touchAction = "none", n.domElement.addEventListener("contextmenu", wt), n.domElement.addEventListener("pointerdown", pe), n.domElement.addEventListener("pointercancel", Ve), n.domElement.addEventListener("wheel", Xt);
    }, this.dispose = () => {
      var W, re, be, Be, Je, Wt;
      n.domElement && (n.domElement.style.touchAction = "auto"), (W = n.domElement) == null || W.removeEventListener("contextmenu", wt), (re = n.domElement) == null || re.removeEventListener("pointerdown", pe), (be = n.domElement) == null || be.removeEventListener("pointercancel", Ve), (Be = n.domElement) == null || Be.removeEventListener("wheel", Xt), (Je = n.domElement) == null || Je.ownerDocument.removeEventListener("pointermove", Ae), (Wt = n.domElement) == null || Wt.ownerDocument.removeEventListener("pointerup", Ve), n._domElementKeyEvents !== null && n._domElementKeyEvents.removeEventListener("keydown", ln);
    };
    const n = this, s = { type: "change" }, i = { type: "start" }, r = { type: "end" }, a = {
      NONE: -1,
      ROTATE: 0,
      DOLLY: 1,
      PAN: 2,
      TOUCH_ROTATE: 3,
      TOUCH_PAN: 4,
      TOUCH_DOLLY_PAN: 5,
      TOUCH_DOLLY_ROTATE: 6
    };
    let l = a.NONE;
    const c = 1e-6, h = new oi(), u = new oi();
    let p = 1;
    const f = new $(), g = new ge(), m = new ge(), y = new ge(), d = new ge(), w = new ge(), v = new ge(), E = new ge(), P = new ge(), T = new ge(), b = new $(), x = new ge();
    let M = !1;
    const _ = [], C = {};
    function R() {
      return 2 * Math.PI / 60 / 60 * n.autoRotateSpeed;
    }
    function B() {
      return Math.pow(0.95, n.zoomSpeed);
    }
    function N(W) {
      n.reverseOrbit || n.reverseHorizontalOrbit ? u.theta += W : u.theta -= W;
    }
    function j(W) {
      n.reverseOrbit || n.reverseVerticalOrbit ? u.phi += W : u.phi -= W;
    }
    const V = (() => {
      const W = new $();
      return function(be, Be) {
        W.setFromMatrixColumn(Be, 0), W.multiplyScalar(-be), f.add(W);
      };
    })(), Q = (() => {
      const W = new $();
      return function(be, Be) {
        n.screenSpacePanning === !0 ? W.setFromMatrixColumn(Be, 1) : (W.setFromMatrixColumn(Be, 0), W.crossVectors(n.object.up, W)), W.multiplyScalar(be), f.add(W);
      };
    })(), Z = (() => {
      const W = new $();
      return function(be, Be) {
        const Je = n.domElement;
        if (Je && n.object instanceof At && n.object.isPerspectiveCamera) {
          const Wt = n.object.position;
          W.copy(Wt).sub(n.target);
          let un = W.length();
          un *= Math.tan(n.object.fov / 2 * Math.PI / 180), V(2 * be * un / Je.clientHeight, n.object.matrix), Q(2 * Be * un / Je.clientHeight, n.object.matrix);
        } else Je && n.object instanceof en && n.object.isOrthographicCamera ? (V(
          be * (n.object.right - n.object.left) / n.object.zoom / Je.clientWidth,
          n.object.matrix
        ), Q(
          Be * (n.object.top - n.object.bottom) / n.object.zoom / Je.clientHeight,
          n.object.matrix
        )) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), n.enablePan = !1);
      };
    })();
    function ne(W) {
      n.object instanceof At && n.object.isPerspectiveCamera || n.object instanceof en && n.object.isOrthographicCamera ? p /= W : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1);
    }
    function te(W) {
      n.object instanceof At && n.object.isPerspectiveCamera || n.object instanceof en && n.object.isOrthographicCamera ? p *= W : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1);
    }
    function le(W) {
      if (!n.zoomToCursor || !n.domElement)
        return;
      M = !0;
      const re = n.domElement.getBoundingClientRect(), be = W.clientX - re.left, Be = W.clientY - re.top, Je = re.width, Wt = re.height;
      x.x = be / Je * 2 - 1, x.y = -(Be / Wt) * 2 + 1, b.set(x.x, x.y, 1).unproject(n.object).sub(n.object.position).normalize();
    }
    function ae(W) {
      return Math.max(n.minDistance, Math.min(n.maxDistance, W));
    }
    function Te(W) {
      g.set(W.clientX, W.clientY);
    }
    function I(W) {
      le(W), E.set(W.clientX, W.clientY);
    }
    function k(W) {
      d.set(W.clientX, W.clientY);
    }
    function D(W) {
      m.set(W.clientX, W.clientY), y.subVectors(m, g).multiplyScalar(n.rotateSpeed);
      const re = n.domElement;
      re && (N(2 * Math.PI * y.x / re.clientHeight), j(2 * Math.PI * y.y / re.clientHeight)), g.copy(m), n.update();
    }
    function O(W) {
      P.set(W.clientX, W.clientY), T.subVectors(P, E), T.y > 0 ? ne(B()) : T.y < 0 && te(B()), E.copy(P), n.update();
    }
    function z(W) {
      w.set(W.clientX, W.clientY), v.subVectors(w, d).multiplyScalar(n.panSpeed), Z(v.x, v.y), d.copy(w), n.update();
    }
    function S(W) {
      le(W), W.deltaY < 0 ? te(B()) : W.deltaY > 0 && ne(B()), n.update();
    }
    function A(W) {
      let re = !1;
      switch (W.code) {
        case n.keys.UP:
          Z(0, n.keyPanSpeed), re = !0;
          break;
        case n.keys.BOTTOM:
          Z(0, -n.keyPanSpeed), re = !0;
          break;
        case n.keys.LEFT:
          Z(n.keyPanSpeed, 0), re = !0;
          break;
        case n.keys.RIGHT:
          Z(-n.keyPanSpeed, 0), re = !0;
          break;
      }
      re && (W.preventDefault(), n.update());
    }
    function L() {
      if (_.length == 1)
        g.set(_[0].pageX, _[0].pageY);
      else {
        const W = 0.5 * (_[0].pageX + _[1].pageX), re = 0.5 * (_[0].pageY + _[1].pageY);
        g.set(W, re);
      }
    }
    function X() {
      if (_.length == 1)
        d.set(_[0].pageX, _[0].pageY);
      else {
        const W = 0.5 * (_[0].pageX + _[1].pageX), re = 0.5 * (_[0].pageY + _[1].pageY);
        d.set(W, re);
      }
    }
    function H() {
      const W = _[0].pageX - _[1].pageX, re = _[0].pageY - _[1].pageY, be = Math.sqrt(W * W + re * re);
      E.set(0, be);
    }
    function G() {
      n.enableZoom && H(), n.enablePan && X();
    }
    function q() {
      n.enableZoom && H(), n.enableRotate && L();
    }
    function se(W) {
      if (_.length == 1)
        m.set(W.pageX, W.pageY);
      else {
        const be = ss(W), Be = 0.5 * (W.pageX + be.x), Je = 0.5 * (W.pageY + be.y);
        m.set(Be, Je);
      }
      y.subVectors(m, g).multiplyScalar(n.rotateSpeed);
      const re = n.domElement;
      re && (N(2 * Math.PI * y.x / re.clientHeight), j(2 * Math.PI * y.y / re.clientHeight)), g.copy(m);
    }
    function ie(W) {
      if (_.length == 1)
        w.set(W.pageX, W.pageY);
      else {
        const re = ss(W), be = 0.5 * (W.pageX + re.x), Be = 0.5 * (W.pageY + re.y);
        w.set(be, Be);
      }
      v.subVectors(w, d).multiplyScalar(n.panSpeed), Z(v.x, v.y), d.copy(w);
    }
    function Y(W) {
      const re = ss(W), be = W.pageX - re.x, Be = W.pageY - re.y, Je = Math.sqrt(be * be + Be * Be);
      P.set(0, Je), T.set(0, Math.pow(P.y / E.y, n.zoomSpeed)), ne(T.y), E.copy(P);
    }
    function F(W) {
      n.enableZoom && Y(W), n.enablePan && ie(W);
    }
    function oe(W) {
      n.enableZoom && Y(W), n.enableRotate && se(W);
    }
    function pe(W) {
      var re, be;
      n.enabled !== !1 && (_.length === 0 && ((re = n.domElement) == null || re.ownerDocument.addEventListener("pointermove", Ae), (be = n.domElement) == null || be.ownerDocument.addEventListener("pointerup", Ve)), Ds(W), W.pointerType === "touch" ? cn(W) : We(W));
    }
    function Ae(W) {
      n.enabled !== !1 && (W.pointerType === "touch" ? gt(W) : xt(W));
    }
    function Ve(W) {
      var re, be, Be;
      Ls(W), _.length === 0 && ((re = n.domElement) == null || re.releasePointerCapture(W.pointerId), (be = n.domElement) == null || be.ownerDocument.removeEventListener("pointermove", Ae), (Be = n.domElement) == null || Be.ownerDocument.removeEventListener("pointerup", Ve)), n.dispatchEvent(r), l = a.NONE;
    }
    function We(W) {
      let re;
      switch (W.button) {
        case 0:
          re = n.mouseButtons.LEFT;
          break;
        case 1:
          re = n.mouseButtons.MIDDLE;
          break;
        case 2:
          re = n.mouseButtons.RIGHT;
          break;
        default:
          re = -1;
      }
      switch (re) {
        case _n.DOLLY:
          if (n.enableZoom === !1)
            return;
          I(W), l = a.DOLLY;
          break;
        case _n.ROTATE:
          if (W.ctrlKey || W.metaKey || W.shiftKey) {
            if (n.enablePan === !1)
              return;
            k(W), l = a.PAN;
          } else {
            if (n.enableRotate === !1)
              return;
            Te(W), l = a.ROTATE;
          }
          break;
        case _n.PAN:
          if (W.ctrlKey || W.metaKey || W.shiftKey) {
            if (n.enableRotate === !1)
              return;
            Te(W), l = a.ROTATE;
          } else {
            if (n.enablePan === !1)
              return;
            k(W), l = a.PAN;
          }
          break;
        default:
          l = a.NONE;
      }
      l !== a.NONE && n.dispatchEvent(i);
    }
    function xt(W) {
      if (n.enabled !== !1)
        switch (l) {
          case a.ROTATE:
            if (n.enableRotate === !1)
              return;
            D(W);
            break;
          case a.DOLLY:
            if (n.enableZoom === !1)
              return;
            O(W);
            break;
          case a.PAN:
            if (n.enablePan === !1)
              return;
            z(W);
            break;
        }
    }
    function Xt(W) {
      n.enabled === !1 || n.enableZoom === !1 || l !== a.NONE && l !== a.ROTATE || (W.preventDefault(), n.dispatchEvent(i), S(W), n.dispatchEvent(r));
    }
    function ln(W) {
      n.enabled === !1 || n.enablePan === !1 || A(W);
    }
    function cn(W) {
      switch (Fs(W), _.length) {
        case 1:
          switch (n.touches.ONE) {
            case Ht.ROTATE:
              if (n.enableRotate === !1)
                return;
              L(), l = a.TOUCH_ROTATE;
              break;
            case Ht.PAN:
              if (n.enablePan === !1)
                return;
              X(), l = a.TOUCH_PAN;
              break;
            default:
              l = a.NONE;
          }
          break;
        case 2:
          switch (n.touches.TWO) {
            case Ht.DOLLY_PAN:
              if (n.enableZoom === !1 && n.enablePan === !1)
                return;
              G(), l = a.TOUCH_DOLLY_PAN;
              break;
            case Ht.DOLLY_ROTATE:
              if (n.enableZoom === !1 && n.enableRotate === !1)
                return;
              q(), l = a.TOUCH_DOLLY_ROTATE;
              break;
            default:
              l = a.NONE;
          }
          break;
        default:
          l = a.NONE;
      }
      l !== a.NONE && n.dispatchEvent(i);
    }
    function gt(W) {
      switch (Fs(W), l) {
        case a.TOUCH_ROTATE:
          if (n.enableRotate === !1)
            return;
          se(W), n.update();
          break;
        case a.TOUCH_PAN:
          if (n.enablePan === !1)
            return;
          ie(W), n.update();
          break;
        case a.TOUCH_DOLLY_PAN:
          if (n.enableZoom === !1 && n.enablePan === !1)
            return;
          F(W), n.update();
          break;
        case a.TOUCH_DOLLY_ROTATE:
          if (n.enableZoom === !1 && n.enableRotate === !1)
            return;
          oe(W), n.update();
          break;
        default:
          l = a.NONE;
      }
    }
    function wt(W) {
      n.enabled !== !1 && W.preventDefault();
    }
    function Ds(W) {
      _.push(W);
    }
    function Ls(W) {
      delete C[W.pointerId];
      for (let re = 0; re < _.length; re++)
        if (_[re].pointerId == W.pointerId) {
          _.splice(re, 1);
          return;
        }
    }
    function Fs(W) {
      let re = C[W.pointerId];
      re === void 0 && (re = new ge(), C[W.pointerId] = re), re.set(W.pageX, W.pageY);
    }
    function ss(W) {
      const re = W.pointerId === _[0].pointerId ? _[1] : _[0];
      return C[re.pointerId];
    }
    t !== void 0 && this.connect(t), this.update();
  }
}
class Ch extends Za {
  constructor(e, t) {
    super(e, t), this.screenSpacePanning = !1, this.mouseButtons.LEFT = _n.PAN, this.mouseButtons.RIGHT = _n.ROTATE, this.touches.ONE = Ht.PAN, this.touches.TWO = Ht.DOLLY_ROTATE;
  }
}
function Ka(o) {
  if (typeof TextDecoder < "u")
    return new TextDecoder().decode(o);
  let e = "";
  for (let t = 0, n = o.length; t < n; t++)
    e += String.fromCharCode(o[t]);
  try {
    return decodeURIComponent(escape(e));
  } catch {
    return e;
  }
}
const as = new $();
function Tt(o, e, t, n, s, i) {
  const r = 2 * Math.PI * s / 4, a = Math.max(i - 2 * s, 0), l = Math.PI / 4;
  as.copy(e), as[n] = 0, as.normalize();
  const c = 0.5 * r / (r + a), h = 1 - as.angleTo(o) / l;
  return Math.sign(as[t]) === 1 ? h * c : a / (r + a) + c + c * (1 - h);
}
class Rh extends Kt {
  constructor(e = 1, t = 1, n = 1, s = 2, i = 0.1) {
    if (s = s * 2 + 1, i = Math.min(e / 2, t / 2, n / 2, i), super(1, 1, 1, s, s, s), s === 1)
      return;
    const r = this.toNonIndexed();
    this.index = null, this.attributes.position = r.attributes.position, this.attributes.normal = r.attributes.normal, this.attributes.uv = r.attributes.uv;
    const a = new $(), l = new $(), c = new $(e, t, n).divideScalar(2).subScalar(i), h = this.attributes.position.array, u = this.attributes.normal.array, p = this.attributes.uv.array, f = h.length / 6, g = new $(), m = 0.5 / s;
    for (let y = 0, d = 0; y < h.length; y += 3, d += 2)
      switch (a.fromArray(h, y), l.copy(a), l.x -= Math.sign(l.x) * m, l.y -= Math.sign(l.y) * m, l.z -= Math.sign(l.z) * m, l.normalize(), h[y + 0] = c.x * Math.sign(a.x) + l.x * i, h[y + 1] = c.y * Math.sign(a.y) + l.y * i, h[y + 2] = c.z * Math.sign(a.z) + l.z * i, u[y + 0] = l.x, u[y + 1] = l.y, u[y + 2] = l.z, Math.floor(y / f)) {
        case 0:
          g.set(1, 0, 0), p[d + 0] = Tt(g, l, "z", "y", i, n), p[d + 1] = 1 - Tt(g, l, "y", "z", i, t);
          break;
        case 1:
          g.set(-1, 0, 0), p[d + 0] = 1 - Tt(g, l, "z", "y", i, n), p[d + 1] = 1 - Tt(g, l, "y", "z", i, t);
          break;
        case 2:
          g.set(0, 1, 0), p[d + 0] = 1 - Tt(g, l, "x", "z", i, e), p[d + 1] = Tt(g, l, "z", "x", i, n);
          break;
        case 3:
          g.set(0, -1, 0), p[d + 0] = 1 - Tt(g, l, "x", "z", i, e), p[d + 1] = 1 - Tt(g, l, "z", "x", i, n);
          break;
        case 4:
          g.set(0, 0, 1), p[d + 0] = 1 - Tt(g, l, "x", "y", i, e), p[d + 1] = 1 - Tt(g, l, "y", "x", i, t);
          break;
        case 5:
          g.set(0, 0, -1), p[d + 0] = Tt(g, l, "x", "y", i, e), p[d + 1] = 1 - Tt(g, l, "y", "x", i, t);
          break;
      }
  }
}
class fo extends Ol {
  constructor(e, t = {}) {
    const {
      bevelEnabled: n = !1,
      bevelSize: s = 8,
      bevelThickness: i = 10,
      font: r,
      height: a = 50,
      size: l = 100,
      lineHeight: c = 1,
      letterSpacing: h = 0,
      ...u
    } = t;
    if (r === void 0)
      super();
    else {
      const p = r.generateShapes(e, l, { lineHeight: c, letterSpacing: h });
      super(p, { ...u, bevelEnabled: n, bevelSize: s, bevelThickness: i, depth: a });
    }
    this.type = "TextGeometry";
  }
}
const Ih = {
  uniforms: {
    tDiffuse: { value: null },
    h: { value: 1 / 512 }
  },
  vertexShader: (
    /* glsl */
    `
      varying vec2 vUv;

      void main() {

        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

      }
  `
  ),
  fragmentShader: (
    /* glsl */
    `
    uniform sampler2D tDiffuse;
    uniform float h;

    varying vec2 vUv;

    void main() {

    	vec4 sum = vec4( 0.0 );

    	sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;
    	sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;
    	sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;
    	sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;
    	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;

    	gl_FragColor = sum;

    }
  `
  )
}, Oh = {
  uniforms: {
    tDiffuse: { value: null },
    v: { value: 1 / 512 }
  },
  vertexShader: (
    /* glsl */
    `
    varying vec2 vUv;

    void main() {

      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

    }
  `
  ),
  fragmentShader: (
    /* glsl */
    `

  uniform sampler2D tDiffuse;
  uniform float v;

  varying vec2 vUv;

  void main() {

    vec4 sum = vec4( 0.0 );

    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;

    gl_FragColor = sum;

  }
  `
  )
};
function qa(o, e, t) {
  const n = t.length - o - 1;
  if (e >= t[n])
    return n - 1;
  if (e <= t[o])
    return o;
  let s = o, i = n, r = Math.floor((s + i) / 2);
  for (; e < t[r] || e >= t[r + 1]; )
    e < t[r] ? i = r : s = r, r = Math.floor((s + i) / 2);
  return r;
}
function Dh(o, e, t, n) {
  const s = [], i = [], r = [];
  s[0] = 1;
  for (let a = 1; a <= t; ++a) {
    i[a] = e - n[o + 1 - a], r[a] = n[o + a] - e;
    let l = 0;
    for (let c = 0; c < a; ++c) {
      const h = r[c + 1], u = i[a - c], p = s[c] / (h + u);
      s[c] = l + h * p, l = u * p;
    }
    s[a] = l;
  }
  return s;
}
function Lh(o, e, t, n) {
  const s = qa(o, n, e), i = Dh(s, n, o, e), r = new it(0, 0, 0, 0);
  for (let a = 0; a <= o; ++a) {
    const l = t[s - o + a], c = i[a], h = l.w * c;
    r.x += l.x * h, r.y += l.y * h, r.z += l.z * h, r.w += l.w * c;
  }
  return r;
}
function Fh(o, e, t, n, s) {
  const i = [];
  for (let u = 0; u <= t; ++u)
    i[u] = 0;
  const r = [];
  for (let u = 0; u <= n; ++u)
    r[u] = i.slice(0);
  const a = [];
  for (let u = 0; u <= t; ++u)
    a[u] = i.slice(0);
  a[0][0] = 1;
  const l = i.slice(0), c = i.slice(0);
  for (let u = 1; u <= t; ++u) {
    l[u] = e - s[o + 1 - u], c[u] = s[o + u] - e;
    let p = 0;
    for (let f = 0; f < u; ++f) {
      const g = c[f + 1], m = l[u - f];
      a[u][f] = g + m;
      const y = a[f][u - 1] / a[u][f];
      a[f][u] = p + g * y, p = m * y;
    }
    a[u][u] = p;
  }
  for (let u = 0; u <= t; ++u)
    r[0][u] = a[u][t];
  for (let u = 0; u <= t; ++u) {
    let p = 0, f = 1;
    const g = [];
    for (let m = 0; m <= t; ++m)
      g[m] = i.slice(0);
    g[0][0] = 1;
    for (let m = 1; m <= n; ++m) {
      let y = 0;
      const d = u - m, w = t - m;
      u >= m && (g[f][0] = g[p][0] / a[w + 1][d], y = g[f][0] * a[d][w]);
      const v = d >= -1 ? 1 : -d, E = u - 1 <= w ? m - 1 : t - u;
      for (let T = v; T <= E; ++T)
        g[f][T] = (g[p][T] - g[p][T - 1]) / a[w + 1][d + T], y += g[f][T] * a[d + T][w];
      u <= w && (g[f][m] = -g[p][m - 1] / a[w + 1][u], y += g[f][m] * a[u][w]), r[m][u] = y;
      const P = p;
      p = f, f = P;
    }
  }
  let h = t;
  for (let u = 1; u <= n; ++u) {
    for (let p = 0; p <= t; ++p)
      r[u][p] *= h;
    h *= t - u;
  }
  return r;
}
function kh(o, e, t, n, s) {
  const i = s < o ? s : o, r = [], a = qa(o, n, e), l = Fh(a, n, o, i, e), c = [];
  for (let h = 0; h < t.length; ++h) {
    const u = t[h].clone(), p = u.w;
    u.x *= p, u.y *= p, u.z *= p, c[h] = u;
  }
  for (let h = 0; h <= i; ++h) {
    const u = c[a - o].clone().multiplyScalar(l[h][0]);
    for (let p = 1; p <= o; ++p)
      u.add(c[a - o + p].clone().multiplyScalar(l[h][p]));
    r[h] = u;
  }
  for (let h = i + 1; h <= s + 1; ++h)
    r[h] = new it(0, 0, 0);
  return r;
}
function Bh(o, e) {
  let t = 1;
  for (let s = 2; s <= o; ++s)
    t *= s;
  let n = 1;
  for (let s = 2; s <= e; ++s)
    n *= s;
  for (let s = 2; s <= o - e; ++s)
    n *= s;
  return t / n;
}
function Nh(o) {
  const e = o.length, t = [], n = [];
  for (let i = 0; i < e; ++i) {
    const r = o[i];
    t[i] = new $(r.x, r.y, r.z), n[i] = r.w;
  }
  const s = [];
  for (let i = 0; i < e; ++i) {
    const r = t[i].clone();
    for (let a = 1; a <= i; ++a)
      r.sub(s[i - a].clone().multiplyScalar(Bh(i, a) * n[a]));
    s[i] = r.divideScalar(n[0]);
  }
  return s;
}
function Uh(o, e, t, n, s) {
  const i = kh(o, e, t, n, s);
  return Nh(i);
}
class po extends Dl {
  constructor(e, t, n, s, i) {
    super(), this.degree = e, this.knots = t, this.controlPoints = [], this.startKnot = s || 0, this.endKnot = i || this.knots.length - 1;
    for (let r = 0; r < n.length; ++r) {
      const a = n[r];
      this.controlPoints[r] = new it(a.x, a.y, a.z, a.w);
    }
  }
  getPoint(e, t) {
    const n = t || new $(), s = this.knots[this.startKnot] + e * (this.knots[this.endKnot] - this.knots[this.startKnot]), i = Lh(this.degree, this.knots, this.controlPoints, s);
    return i.w != 1 && i.divideScalar(i.w), n.set(i.x, i.y, i.z);
  }
  getTangent(e, t) {
    const n = t || new $(), s = this.knots[0] + e * (this.knots[this.knots.length - 1] - this.knots[0]), i = Uh(this.degree, this.knots, this.controlPoints, s, 1);
    return n.copy(i[1]).normalize(), n;
  }
}
let Ce, qe, ft;
class zh extends As {
  constructor(e) {
    super(e);
  }
  load(e, t, n, s) {
    const i = this, r = i.path === "" ? Qn.extractUrlBase(e) : i.path, a = new Bn(this.manager);
    a.setPath(i.path), a.setResponseType("arraybuffer"), a.setRequestHeader(i.requestHeader), a.setWithCredentials(i.withCredentials), a.load(
      e,
      function(l) {
        try {
          t(i.parse(l, r));
        } catch (c) {
          s ? s(c) : console.error(c), i.manager.itemError(e);
        }
      },
      n,
      s
    );
  }
  parse(e, t) {
    if (Xh(e))
      Ce = new Yh().parse(e);
    else {
      const s = tl(e);
      if (!Wh(s))
        throw new Error("THREE.FBXLoader: Unknown format.");
      if (go(s) < 7e3)
        throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + go(s));
      Ce = new Vh().parse(s);
    }
    const n = new fi(this.manager).setPath(this.resourcePath || t).setCrossOrigin(this.crossOrigin);
    return new Hh(n, this.manager).parse(Ce);
  }
}
class Hh {
  constructor(e, t) {
    this.textureLoader = e, this.manager = t;
  }
  parse() {
    qe = this.parseConnections();
    const e = this.parseImages(), t = this.parseTextures(e), n = this.parseMaterials(t), s = this.parseDeformers(), i = new Gh().parse(s);
    return this.parseScene(s, i, n), ft;
  }
  // Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )
  // and details the connection type
  parseConnections() {
    const e = /* @__PURE__ */ new Map();
    return "Connections" in Ce && Ce.Connections.connections.forEach(function(n) {
      const s = n[0], i = n[1], r = n[2];
      e.has(s) || e.set(s, {
        parents: [],
        children: []
      });
      const a = { ID: i, relationship: r };
      e.get(s).parents.push(a), e.has(i) || e.set(i, {
        parents: [],
        children: []
      });
      const l = { ID: s, relationship: r };
      e.get(i).children.push(l);
    }), e;
  }
  // Parse FBXTree.Objects.Video for embedded image data
  // These images are connected to textures in FBXTree.Objects.Textures
  // via FBXTree.Connections.
  parseImages() {
    const e = {}, t = {};
    if ("Video" in Ce.Objects) {
      const n = Ce.Objects.Video;
      for (const s in n) {
        const i = n[s], r = parseInt(s);
        if (e[r] = i.RelativeFilename || i.Filename, "Content" in i) {
          const a = i.Content instanceof ArrayBuffer && i.Content.byteLength > 0, l = typeof i.Content == "string" && i.Content !== "";
          if (a || l) {
            const c = this.parseImage(n[s]);
            t[i.RelativeFilename || i.Filename] = c;
          }
        }
      }
    }
    for (const n in e) {
      const s = e[n];
      t[s] !== void 0 ? e[n] = t[s] : e[n] = e[n].split("\\").pop();
    }
    return e;
  }
  // Parse embedded image data in FBXTree.Video.Content
  parseImage(e) {
    const t = e.Content, n = e.RelativeFilename || e.Filename, s = n.slice(n.lastIndexOf(".") + 1).toLowerCase();
    let i;
    switch (s) {
      case "bmp":
        i = "image/bmp";
        break;
      case "jpg":
      case "jpeg":
        i = "image/jpeg";
        break;
      case "png":
        i = "image/png";
        break;
      case "tif":
        i = "image/tiff";
        break;
      case "tga":
        this.manager.getHandler(".tga") === null && console.warn("FBXLoader: TGA loader not found, skipping ", n), i = "image/tga";
        break;
      default:
        console.warn('FBXLoader: Image type "' + s + '" is not supported.');
        return;
    }
    if (typeof t == "string")
      return "data:" + i + ";base64," + t;
    {
      const r = new Uint8Array(t);
      return window.URL.createObjectURL(new Blob([r], { type: i }));
    }
  }
  // Parse nodes in FBXTree.Objects.Texture
  // These contain details such as UV scaling, cropping, rotation etc and are connected
  // to images in FBXTree.Objects.Video
  parseTextures(e) {
    const t = /* @__PURE__ */ new Map();
    if ("Texture" in Ce.Objects) {
      const n = Ce.Objects.Texture;
      for (const s in n) {
        const i = this.parseTexture(n[s], e);
        t.set(parseInt(s), i);
      }
    }
    return t;
  }
  // Parse individual node in FBXTree.Objects.Texture
  parseTexture(e, t) {
    const n = this.loadTexture(e, t);
    n.ID = e.id, n.name = e.attrName;
    const s = e.WrapModeU, i = e.WrapModeV, r = s !== void 0 ? s.value : 0, a = i !== void 0 ? i.value : 0;
    if (n.wrapS = r === 0 ? kn : ts, n.wrapT = a === 0 ? kn : ts, "Scaling" in e) {
      const l = e.Scaling.value;
      n.repeat.x = l[0], n.repeat.y = l[1];
    }
    return n;
  }
  // load a texture specified as a blob or data URI, or via an external URL using TextureLoader
  loadTexture(e, t) {
    let n;
    const s = this.textureLoader.path, i = qe.get(e.id).children;
    i !== void 0 && i.length > 0 && t[i[0].ID] !== void 0 && (n = t[i[0].ID], (n.indexOf("blob:") === 0 || n.indexOf("data:") === 0) && this.textureLoader.setPath(void 0));
    let r;
    const a = e.FileName.slice(-3).toLowerCase();
    if (a === "tga") {
      const l = this.manager.getHandler(".tga");
      l === null ? (console.warn("FBXLoader: TGA loader not found, creating placeholder texture for", e.RelativeFilename), r = new es()) : (l.setPath(this.textureLoader.path), r = l.load(n));
    } else a === "psd" ? (console.warn(
      "FBXLoader: PSD textures are not supported, creating placeholder texture for",
      e.RelativeFilename
    ), r = new es()) : r = this.textureLoader.load(n);
    return this.textureLoader.setPath(s), r;
  }
  // Parse nodes in FBXTree.Objects.Material
  parseMaterials(e) {
    const t = /* @__PURE__ */ new Map();
    if ("Material" in Ce.Objects) {
      const n = Ce.Objects.Material;
      for (const s in n) {
        const i = this.parseMaterial(n[s], e);
        i !== null && t.set(parseInt(s), i);
      }
    }
    return t;
  }
  // Parse single node in FBXTree.Objects.Material
  // Materials are connected to texture maps in FBXTree.Objects.Textures
  // FBX format currently only supports Lambert and Phong shading models
  parseMaterial(e, t) {
    const n = e.id, s = e.attrName;
    let i = e.ShadingModel;
    if (typeof i == "object" && (i = i.value), !qe.has(n))
      return null;
    const r = this.parseParameters(e, t, n);
    let a;
    switch (i.toLowerCase()) {
      case "phong":
        a = new wi();
        break;
      case "lambert":
        a = new Ll();
        break;
      default:
        console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', i), a = new wi();
        break;
    }
    return a.setValues(r), a.name = s, a;
  }
  // Parse FBX material and return parameters suitable for a three.js material
  // Also parse the texture map and return any textures associated with the material
  parseParameters(e, t, n) {
    const s = {};
    e.BumpFactor && (s.bumpScale = e.BumpFactor.value), e.Diffuse ? s.color = new Pe().fromArray(e.Diffuse.value) : e.DiffuseColor && (e.DiffuseColor.type === "Color" || e.DiffuseColor.type === "ColorRGB") && (s.color = new Pe().fromArray(e.DiffuseColor.value)), e.DisplacementFactor && (s.displacementScale = e.DisplacementFactor.value), e.Emissive ? s.emissive = new Pe().fromArray(e.Emissive.value) : e.EmissiveColor && (e.EmissiveColor.type === "Color" || e.EmissiveColor.type === "ColorRGB") && (s.emissive = new Pe().fromArray(e.EmissiveColor.value)), e.EmissiveFactor && (s.emissiveIntensity = parseFloat(e.EmissiveFactor.value)), e.Opacity && (s.opacity = parseFloat(e.Opacity.value)), s.opacity < 1 && (s.transparent = !0), e.ReflectionFactor && (s.reflectivity = e.ReflectionFactor.value), e.Shininess && (s.shininess = e.Shininess.value), e.Specular ? s.specular = new Pe().fromArray(e.Specular.value) : e.SpecularColor && e.SpecularColor.type === "Color" && (s.specular = new Pe().fromArray(e.SpecularColor.value));
    const i = this;
    return qe.get(n).children.forEach(function(r) {
      const a = r.relationship;
      switch (a) {
        case "Bump":
          s.bumpMap = i.getTexture(t, r.ID);
          break;
        case "Maya|TEX_ao_map":
          s.aoMap = i.getTexture(t, r.ID);
          break;
        case "DiffuseColor":
        case "Maya|TEX_color_map":
          s.map = i.getTexture(t, r.ID), s.map !== void 0 && ("colorSpace" in s.map ? s.map.colorSpace = "srgb" : s.map.encoding = 3001);
          break;
        case "DisplacementColor":
          s.displacementMap = i.getTexture(t, r.ID);
          break;
        case "EmissiveColor":
          s.emissiveMap = i.getTexture(t, r.ID), s.emissiveMap !== void 0 && ("colorSpace" in s.emissiveMap ? s.emissiveMap.colorSpace = "srgb" : s.emissiveMap.encoding = 3001);
          break;
        case "NormalMap":
        case "Maya|TEX_normal_map":
          s.normalMap = i.getTexture(t, r.ID);
          break;
        case "ReflectionColor":
          s.envMap = i.getTexture(t, r.ID), s.envMap !== void 0 && (s.envMap.mapping = sr, "colorSpace" in s.envMap ? s.envMap.colorSpace = "srgb" : s.envMap.encoding = 3001);
          break;
        case "SpecularColor":
          s.specularMap = i.getTexture(t, r.ID), s.specularMap !== void 0 && ("colorSpace" in s.specularMap ? s.specularMap.colorSpace = "srgb" : s.specularMap.encoding = 3001);
          break;
        case "TransparentColor":
        case "TransparencyFactor":
          s.alphaMap = i.getTexture(t, r.ID), s.transparent = !0;
          break;
        case "AmbientColor":
        case "ShininessExponent":
        case "SpecularFactor":
        case "VectorDisplacementColor":
        default:
          console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", a);
          break;
      }
    }), s;
  }
  // get a texture from the textureMap for use by a material.
  getTexture(e, t) {
    return "LayeredTexture" in Ce.Objects && t in Ce.Objects.LayeredTexture && (console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."), t = qe.get(t).children[0].ID), e.get(t);
  }
  // Parse nodes in FBXTree.Objects.Deformer
  // Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here
  // Generates map of Skeleton-like objects for use later when generating and binding skeletons.
  parseDeformers() {
    const e = {}, t = {};
    if ("Deformer" in Ce.Objects) {
      const n = Ce.Objects.Deformer;
      for (const s in n) {
        const i = n[s], r = qe.get(parseInt(s));
        if (i.attrType === "Skin") {
          const a = this.parseSkeleton(r, n);
          a.ID = s, r.parents.length > 1 && console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."), a.geometryID = r.parents[0].ID, e[s] = a;
        } else if (i.attrType === "BlendShape") {
          const a = {
            id: s
          };
          a.rawTargets = this.parseMorphTargets(r, n), a.id = s, r.parents.length > 1 && console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."), t[s] = a;
        }
      }
    }
    return {
      skeletons: e,
      morphTargets: t
    };
  }
  // Parse single nodes in FBXTree.Objects.Deformer
  // The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'
  // Each skin node represents a skeleton and each cluster node represents a bone
  parseSkeleton(e, t) {
    const n = [];
    return e.children.forEach(function(s) {
      const i = t[s.ID];
      if (i.attrType !== "Cluster")
        return;
      const r = {
        ID: s.ID,
        indices: [],
        weights: [],
        transformLink: new Re().fromArray(i.TransformLink.a)
        // transform: new Matrix4().fromArray( boneNode.Transform.a ),
        // linkMode: boneNode.Mode,
      };
      "Indexes" in i && (r.indices = i.Indexes.a, r.weights = i.Weights.a), n.push(r);
    }), {
      rawBones: n,
      bones: []
    };
  }
  // The top level morph deformer node has type "BlendShape" and sub nodes have type "BlendShapeChannel"
  parseMorphTargets(e, t) {
    const n = [];
    for (let s = 0; s < e.children.length; s++) {
      const i = e.children[s], r = t[i.ID], a = {
        name: r.attrName,
        initialWeight: r.DeformPercent,
        id: r.id,
        fullWeights: r.FullWeights.a
      };
      if (r.attrType !== "BlendShapeChannel")
        return;
      a.geoID = qe.get(parseInt(i.ID)).children.filter(function(l) {
        return l.relationship === void 0;
      })[0].ID, n.push(a);
    }
    return n;
  }
  // create the main Group() to be returned by the loader
  parseScene(e, t, n) {
    ft = new Sn();
    const s = this.parseModels(e.skeletons, t, n), i = Ce.Objects.Model, r = this;
    s.forEach(function(l) {
      const c = i[l.ID];
      r.setLookAtProperties(l, c), qe.get(l.ID).parents.forEach(function(u) {
        const p = s.get(u.ID);
        p !== void 0 && p.add(l);
      }), l.parent === null && ft.add(l);
    }), this.bindSkeleton(e.skeletons, t, s), this.createAmbientLight(), ft.traverse(function(l) {
      if (l.userData.transformData) {
        l.parent && (l.userData.transformData.parentMatrix = l.parent.matrix, l.userData.transformData.parentMatrixWorld = l.parent.matrixWorld);
        const c = Ja(l.userData.transformData);
        l.applyMatrix4(c), l.updateWorldMatrix();
      }
    });
    const a = new jh().parse();
    ft.children.length === 1 && ft.children[0].isGroup && (ft.children[0].animations = a, ft = ft.children[0]), ft.animations = a;
  }
  // parse nodes in FBXTree.Objects.Model
  parseModels(e, t, n) {
    const s = /* @__PURE__ */ new Map(), i = Ce.Objects.Model;
    for (const r in i) {
      const a = parseInt(r), l = i[r], c = qe.get(a);
      let h = this.buildSkeleton(c, e, a, l.attrName);
      if (!h) {
        switch (l.attrType) {
          case "Camera":
            h = this.createCamera(c);
            break;
          case "Light":
            h = this.createLight(c);
            break;
          case "Mesh":
            h = this.createMesh(c, t, n);
            break;
          case "NurbsCurve":
            h = this.createCurve(c, t);
            break;
          case "LimbNode":
          case "Root":
            h = new ir();
            break;
          case "Null":
          default:
            h = new Sn();
            break;
        }
        h.name = l.attrName ? nn.sanitizeNodeName(l.attrName) : "", h.ID = a;
      }
      this.getTransformData(h, l), s.set(a, h);
    }
    return s;
  }
  buildSkeleton(e, t, n, s) {
    let i = null;
    return e.parents.forEach(function(r) {
      for (const a in t) {
        const l = t[a];
        l.rawBones.forEach(function(c, h) {
          if (c.ID === r.ID) {
            const u = i;
            i = new ir(), i.matrixWorld.copy(c.transformLink), i.name = s ? nn.sanitizeNodeName(s) : "", i.ID = n, l.bones[h] = i, u !== null && i.add(u);
          }
        });
      }
    }), i;
  }
  // create a PerspectiveCamera or OrthographicCamera
  createCamera(e) {
    let t, n;
    if (e.children.forEach(function(s) {
      const i = Ce.Objects.NodeAttribute[s.ID];
      i !== void 0 && (n = i);
    }), n === void 0)
      t = new Pt();
    else {
      let s = 0;
      n.CameraProjectionType !== void 0 && n.CameraProjectionType.value === 1 && (s = 1);
      let i = 1;
      n.NearPlane !== void 0 && (i = n.NearPlane.value / 1e3);
      let r = 1e3;
      n.FarPlane !== void 0 && (r = n.FarPlane.value / 1e3);
      let a = window.innerWidth, l = window.innerHeight;
      n.AspectWidth !== void 0 && n.AspectHeight !== void 0 && (a = n.AspectWidth.value, l = n.AspectHeight.value);
      const c = a / l;
      let h = 45;
      n.FieldOfView !== void 0 && (h = n.FieldOfView.value);
      const u = n.FocalLength ? n.FocalLength.value : null;
      switch (s) {
        case 0:
          t = new At(h, c, i, r), u !== null && t.setFocalLength(u);
          break;
        case 1:
          t = new en(
            -a / 2,
            a / 2,
            l / 2,
            -l / 2,
            i,
            r
          );
          break;
        default:
          console.warn("THREE.FBXLoader: Unknown camera type " + s + "."), t = new Pt();
          break;
      }
    }
    return t;
  }
  // Create a DirectionalLight, PointLight or SpotLight
  createLight(e) {
    let t, n;
    if (e.children.forEach(function(s) {
      const i = Ce.Objects.NodeAttribute[s.ID];
      i !== void 0 && (n = i);
    }), n === void 0)
      t = new Pt();
    else {
      let s;
      n.LightType === void 0 ? s = 0 : s = n.LightType.value;
      let i = 16777215;
      n.Color !== void 0 && (i = new Pe().fromArray(n.Color.value));
      let r = n.Intensity === void 0 ? 1 : n.Intensity.value / 100;
      n.CastLightOnObject !== void 0 && n.CastLightOnObject.value === 0 && (r = 0);
      let a = 0;
      n.FarAttenuationEnd !== void 0 && (n.EnableFarAttenuation !== void 0 && n.EnableFarAttenuation.value === 0 ? a = 0 : a = n.FarAttenuationEnd.value);
      const l = 1;
      switch (s) {
        case 0:
          t = new rr(i, r, a, l);
          break;
        case 1:
          t = new ga(i, r);
          break;
        case 2:
          let c = Math.PI / 3;
          n.InnerAngle !== void 0 && (c = Ze.degToRad(n.InnerAngle.value));
          let h = 0;
          n.OuterAngle !== void 0 && (h = Ze.degToRad(n.OuterAngle.value), h = Math.max(h, 1)), t = new ma(i, r, a, c, h, l);
          break;
        default:
          console.warn(
            "THREE.FBXLoader: Unknown light type " + n.LightType.value + ", defaulting to a PointLight."
          ), t = new rr(i, r);
          break;
      }
      n.CastShadows !== void 0 && n.CastShadows.value === 1 && (t.castShadow = !0);
    }
    return t;
  }
  createMesh(e, t, n) {
    let s, i = null, r = null;
    const a = [];
    return e.children.forEach(function(l) {
      t.has(l.ID) && (i = t.get(l.ID)), n.has(l.ID) && a.push(n.get(l.ID));
    }), a.length > 1 ? r = a : a.length > 0 ? r = a[0] : (r = new wi({ color: 13421772 }), a.push(r)), "color" in i.attributes && a.forEach(function(l) {
      l.vertexColors = !0;
    }), i.FBX_Deformer ? (s = new ya(i, r), s.normalizeSkinWeights()) : s = new he(i, r), s;
  }
  createCurve(e, t) {
    const n = e.children.reduce(function(i, r) {
      return t.has(r.ID) && (i = t.get(r.ID)), i;
    }, null), s = new ws({ color: 3342591, linewidth: 1 });
    return new Le(n, s);
  }
  // parse the model node for transform data
  getTransformData(e, t) {
    const n = {};
    "InheritType" in t && (n.inheritType = parseInt(t.InheritType.value)), "RotationOrder" in t ? n.eulerOrder = el(t.RotationOrder.value) : n.eulerOrder = "ZYX", "Lcl_Translation" in t && (n.translation = t.Lcl_Translation.value), "PreRotation" in t && (n.preRotation = t.PreRotation.value), "Lcl_Rotation" in t && (n.rotation = t.Lcl_Rotation.value), "PostRotation" in t && (n.postRotation = t.PostRotation.value), "Lcl_Scaling" in t && (n.scale = t.Lcl_Scaling.value), "ScalingOffset" in t && (n.scalingOffset = t.ScalingOffset.value), "ScalingPivot" in t && (n.scalingPivot = t.ScalingPivot.value), "RotationOffset" in t && (n.rotationOffset = t.RotationOffset.value), "RotationPivot" in t && (n.rotationPivot = t.RotationPivot.value), e.userData.transformData = n;
  }
  setLookAtProperties(e, t) {
    "LookAtProperty" in t && qe.get(e.ID).children.forEach(function(s) {
      if (s.relationship === "LookAtProperty") {
        const i = Ce.Objects.Model[s.ID];
        if ("Lcl_Translation" in i) {
          const r = i.Lcl_Translation.value;
          e.target !== void 0 ? (e.target.position.fromArray(r), ft.add(e.target)) : e.lookAt(new $().fromArray(r));
        }
      }
    });
  }
  bindSkeleton(e, t, n) {
    const s = this.parsePoseNodes();
    for (const i in e) {
      const r = e[i];
      qe.get(parseInt(r.ID)).parents.forEach(function(l) {
        if (t.has(l.ID)) {
          const c = l.ID;
          qe.get(c).parents.forEach(function(u) {
            n.has(u.ID) && n.get(u.ID).bind(new va(r.bones), s[u.ID]);
          });
        }
      });
    }
  }
  parsePoseNodes() {
    const e = {};
    if ("Pose" in Ce.Objects) {
      const t = Ce.Objects.Pose;
      for (const n in t)
        if (t[n].attrType === "BindPose" && t[n].NbPoseNodes > 0) {
          const s = t[n].PoseNode;
          Array.isArray(s) ? s.forEach(function(i) {
            e[i.Node] = new Re().fromArray(i.Matrix.a);
          }) : e[s.Node] = new Re().fromArray(s.Matrix.a);
        }
    }
    return e;
  }
  // Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light
  createAmbientLight() {
    if ("GlobalSettings" in Ce && "AmbientColor" in Ce.GlobalSettings) {
      const e = Ce.GlobalSettings.AmbientColor.value, t = e[0], n = e[1], s = e[2];
      if (t !== 0 || n !== 0 || s !== 0) {
        const i = new Pe(t, n, s);
        ft.add(new Fl(i, 1));
      }
    }
  }
}
class Gh {
  // Parse nodes in FBXTree.Objects.Geometry
  parse(e) {
    const t = /* @__PURE__ */ new Map();
    if ("Geometry" in Ce.Objects) {
      const n = Ce.Objects.Geometry;
      for (const s in n) {
        const i = qe.get(parseInt(s)), r = this.parseGeometry(i, n[s], e);
        t.set(parseInt(s), r);
      }
    }
    return t;
  }
  // Parse single node in FBXTree.Objects.Geometry
  parseGeometry(e, t, n) {
    switch (t.attrType) {
      case "Mesh":
        return this.parseMeshGeometry(e, t, n);
      case "NurbsCurve":
        return this.parseNurbsGeometry(t);
    }
  }
  // Parse single node mesh geometry in FBXTree.Objects.Geometry
  parseMeshGeometry(e, t, n) {
    const s = n.skeletons, i = [], r = e.parents.map(function(u) {
      return Ce.Objects.Model[u.ID];
    });
    if (r.length === 0)
      return;
    const a = e.children.reduce(function(u, p) {
      return s[p.ID] !== void 0 && (u = s[p.ID]), u;
    }, null);
    e.children.forEach(function(u) {
      n.morphTargets[u.ID] !== void 0 && i.push(n.morphTargets[u.ID]);
    });
    const l = r[0], c = {};
    "RotationOrder" in l && (c.eulerOrder = el(l.RotationOrder.value)), "InheritType" in l && (c.inheritType = parseInt(l.InheritType.value)), "GeometricTranslation" in l && (c.translation = l.GeometricTranslation.value), "GeometricRotation" in l && (c.rotation = l.GeometricRotation.value), "GeometricScaling" in l && (c.scale = l.GeometricScaling.value);
    const h = Ja(c);
    return this.genGeometry(t, a, i, h);
  }
  // Generate a BufferGeometry from a node in FBXTree.Objects.Geometry
  genGeometry(e, t, n, s) {
    const i = new pt();
    e.attrName && (i.name = e.attrName);
    const r = this.parseGeoNode(e, t), a = this.genBuffers(r), l = new dt(a.vertex, 3);
    if (l.applyMatrix4(s), i.setAttribute("position", l), a.colors.length > 0 && i.setAttribute("color", new dt(a.colors, 3)), t && (i.setAttribute("skinIndex", new kl(a.weightsIndices, 4)), i.setAttribute("skinWeight", new dt(a.vertexWeights, 4)), i.FBX_Deformer = t), a.normal.length > 0) {
      const c = new Ln().getNormalMatrix(s), h = new dt(a.normal, 3);
      h.applyNormalMatrix(c), i.setAttribute("normal", h);
    }
    if (a.uvs.forEach(function(c, h) {
      Mu === "uv2" && h++;
      const u = h === 0 ? "uv" : `uv${h}`;
      i.setAttribute(u, new dt(a.uvs[h], 2));
    }), r.material && r.material.mappingType !== "AllSame") {
      let c = a.materialIndex[0], h = 0;
      if (a.materialIndex.forEach(function(u, p) {
        u !== c && (i.addGroup(h, p - h, c), c = u, h = p);
      }), i.groups.length > 0) {
        const u = i.groups[i.groups.length - 1], p = u.start + u.count;
        p !== a.materialIndex.length && i.addGroup(p, a.materialIndex.length - p, c);
      }
      i.groups.length === 0 && i.addGroup(0, a.materialIndex.length, a.materialIndex[0]);
    }
    return this.addMorphTargets(i, e, n, s), i;
  }
  parseGeoNode(e, t) {
    const n = {};
    if (n.vertexPositions = e.Vertices !== void 0 ? e.Vertices.a : [], n.vertexIndices = e.PolygonVertexIndex !== void 0 ? e.PolygonVertexIndex.a : [], e.LayerElementColor && (n.color = this.parseVertexColors(e.LayerElementColor[0])), e.LayerElementMaterial && (n.material = this.parseMaterialIndices(e.LayerElementMaterial[0])), e.LayerElementNormal && (n.normal = this.parseNormals(e.LayerElementNormal[0])), e.LayerElementUV) {
      n.uv = [];
      let s = 0;
      for (; e.LayerElementUV[s]; )
        e.LayerElementUV[s].UV && n.uv.push(this.parseUVs(e.LayerElementUV[s])), s++;
    }
    return n.weightTable = {}, t !== null && (n.skeleton = t, t.rawBones.forEach(function(s, i) {
      s.indices.forEach(function(r, a) {
        n.weightTable[r] === void 0 && (n.weightTable[r] = []), n.weightTable[r].push({
          id: i,
          weight: s.weights[a]
        });
      });
    })), n;
  }
  genBuffers(e) {
    const t = {
      vertex: [],
      normal: [],
      colors: [],
      uvs: [],
      materialIndex: [],
      vertexWeights: [],
      weightsIndices: []
    };
    let n = 0, s = 0, i = !1, r = [], a = [], l = [], c = [], h = [], u = [];
    const p = this;
    return e.vertexIndices.forEach(function(f, g) {
      let m, y = !1;
      f < 0 && (f = f ^ -1, y = !0);
      let d = [], w = [];
      if (r.push(f * 3, f * 3 + 1, f * 3 + 2), e.color) {
        const v = Xs(g, n, f, e.color);
        l.push(v[0], v[1], v[2]);
      }
      if (e.skeleton) {
        if (e.weightTable[f] !== void 0 && e.weightTable[f].forEach(function(v) {
          w.push(v.weight), d.push(v.id);
        }), w.length > 4) {
          i || (console.warn(
            "THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."
          ), i = !0);
          const v = [0, 0, 0, 0], E = [0, 0, 0, 0];
          w.forEach(function(P, T) {
            let b = P, x = d[T];
            E.forEach(function(M, _, C) {
              if (b > M) {
                C[_] = b, b = M;
                const R = v[_];
                v[_] = x, x = R;
              }
            });
          }), d = v, w = E;
        }
        for (; w.length < 4; )
          w.push(0), d.push(0);
        for (let v = 0; v < 4; ++v)
          h.push(w[v]), u.push(d[v]);
      }
      if (e.normal) {
        const v = Xs(g, n, f, e.normal);
        a.push(v[0], v[1], v[2]);
      }
      e.material && e.material.mappingType !== "AllSame" && (m = Xs(g, n, f, e.material)[0]), e.uv && e.uv.forEach(function(v, E) {
        const P = Xs(g, n, f, v);
        c[E] === void 0 && (c[E] = []), c[E].push(P[0]), c[E].push(P[1]);
      }), s++, y && (p.genFace(
        t,
        e,
        r,
        m,
        a,
        l,
        c,
        h,
        u,
        s
      ), n++, s = 0, r = [], a = [], l = [], c = [], h = [], u = []);
    }), t;
  }
  // Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris
  genFace(e, t, n, s, i, r, a, l, c, h) {
    for (let u = 2; u < h; u++)
      e.vertex.push(t.vertexPositions[n[0]]), e.vertex.push(t.vertexPositions[n[1]]), e.vertex.push(t.vertexPositions[n[2]]), e.vertex.push(t.vertexPositions[n[(u - 1) * 3]]), e.vertex.push(t.vertexPositions[n[(u - 1) * 3 + 1]]), e.vertex.push(t.vertexPositions[n[(u - 1) * 3 + 2]]), e.vertex.push(t.vertexPositions[n[u * 3]]), e.vertex.push(t.vertexPositions[n[u * 3 + 1]]), e.vertex.push(t.vertexPositions[n[u * 3 + 2]]), t.skeleton && (e.vertexWeights.push(l[0]), e.vertexWeights.push(l[1]), e.vertexWeights.push(l[2]), e.vertexWeights.push(l[3]), e.vertexWeights.push(l[(u - 1) * 4]), e.vertexWeights.push(l[(u - 1) * 4 + 1]), e.vertexWeights.push(l[(u - 1) * 4 + 2]), e.vertexWeights.push(l[(u - 1) * 4 + 3]), e.vertexWeights.push(l[u * 4]), e.vertexWeights.push(l[u * 4 + 1]), e.vertexWeights.push(l[u * 4 + 2]), e.vertexWeights.push(l[u * 4 + 3]), e.weightsIndices.push(c[0]), e.weightsIndices.push(c[1]), e.weightsIndices.push(c[2]), e.weightsIndices.push(c[3]), e.weightsIndices.push(c[(u - 1) * 4]), e.weightsIndices.push(c[(u - 1) * 4 + 1]), e.weightsIndices.push(c[(u - 1) * 4 + 2]), e.weightsIndices.push(c[(u - 1) * 4 + 3]), e.weightsIndices.push(c[u * 4]), e.weightsIndices.push(c[u * 4 + 1]), e.weightsIndices.push(c[u * 4 + 2]), e.weightsIndices.push(c[u * 4 + 3])), t.color && (e.colors.push(r[0]), e.colors.push(r[1]), e.colors.push(r[2]), e.colors.push(r[(u - 1) * 3]), e.colors.push(r[(u - 1) * 3 + 1]), e.colors.push(r[(u - 1) * 3 + 2]), e.colors.push(r[u * 3]), e.colors.push(r[u * 3 + 1]), e.colors.push(r[u * 3 + 2])), t.material && t.material.mappingType !== "AllSame" && (e.materialIndex.push(s), e.materialIndex.push(s), e.materialIndex.push(s)), t.normal && (e.normal.push(i[0]), e.normal.push(i[1]), e.normal.push(i[2]), e.normal.push(i[(u - 1) * 3]), e.normal.push(i[(u - 1) * 3 + 1]), e.normal.push(i[(u - 1) * 3 + 2]), e.normal.push(i[u * 3]), e.normal.push(i[u * 3 + 1]), e.normal.push(i[u * 3 + 2])), t.uv && t.uv.forEach(function(p, f) {
        e.uvs[f] === void 0 && (e.uvs[f] = []), e.uvs[f].push(a[f][0]), e.uvs[f].push(a[f][1]), e.uvs[f].push(a[f][(u - 1) * 2]), e.uvs[f].push(a[f][(u - 1) * 2 + 1]), e.uvs[f].push(a[f][u * 2]), e.uvs[f].push(a[f][u * 2 + 1]);
      });
  }
  addMorphTargets(e, t, n, s) {
    if (n.length === 0)
      return;
    e.morphTargetsRelative = !0, e.morphAttributes.position = [];
    const i = this;
    n.forEach(function(r) {
      r.rawTargets.forEach(function(a) {
        const l = Ce.Objects.Geometry[a.geoID];
        l !== void 0 && i.genMorphGeometry(e, t, l, s, a.name);
      });
    });
  }
  // a morph geometry node is similar to a standard  node, and the node is also contained
  // in FBXTree.Objects.Geometry, however it can only have attributes for position, normal
  // and a special attribute Index defining which vertices of the original geometry are affected
  // Normal and position attributes only have data for the vertices that are affected by the morph
  genMorphGeometry(e, t, n, s, i) {
    const r = t.PolygonVertexIndex !== void 0 ? t.PolygonVertexIndex.a : [], a = n.Vertices !== void 0 ? n.Vertices.a : [], l = n.Indexes !== void 0 ? n.Indexes.a : [], c = e.attributes.position.count * 3, h = new Float32Array(c);
    for (let g = 0; g < l.length; g++) {
      const m = l[g] * 3;
      h[m] = a[g * 3], h[m + 1] = a[g * 3 + 1], h[m + 2] = a[g * 3 + 2];
    }
    const u = {
      vertexIndices: r,
      vertexPositions: h
    }, p = this.genBuffers(u), f = new dt(p.vertex, 3);
    f.name = i || n.attrName, f.applyMatrix4(s), e.morphAttributes.position.push(f);
  }
  // Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists
  parseNormals(e) {
    const t = e.MappingInformationType, n = e.ReferenceInformationType, s = e.Normals.a;
    let i = [];
    return n === "IndexToDirect" && ("NormalIndex" in e ? i = e.NormalIndex.a : "NormalsIndex" in e && (i = e.NormalsIndex.a)), {
      dataSize: 3,
      buffer: s,
      indices: i,
      mappingType: t,
      referenceType: n
    };
  }
  // Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists
  parseUVs(e) {
    const t = e.MappingInformationType, n = e.ReferenceInformationType, s = e.UV.a;
    let i = [];
    return n === "IndexToDirect" && (i = e.UVIndex.a), {
      dataSize: 2,
      buffer: s,
      indices: i,
      mappingType: t,
      referenceType: n
    };
  }
  // Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists
  parseVertexColors(e) {
    const t = e.MappingInformationType, n = e.ReferenceInformationType, s = e.Colors.a;
    let i = [];
    return n === "IndexToDirect" && (i = e.ColorIndex.a), {
      dataSize: 4,
      buffer: s,
      indices: i,
      mappingType: t,
      referenceType: n
    };
  }
  // Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists
  parseMaterialIndices(e) {
    const t = e.MappingInformationType, n = e.ReferenceInformationType;
    if (t === "NoMappingInformation")
      return {
        dataSize: 1,
        buffer: [0],
        indices: [0],
        mappingType: "AllSame",
        referenceType: n
      };
    const s = e.Materials.a, i = [];
    for (let r = 0; r < s.length; ++r)
      i.push(r);
    return {
      dataSize: 1,
      buffer: s,
      indices: i,
      mappingType: t,
      referenceType: n
    };
  }
  // Generate a NurbGeometry from a node in FBXTree.Objects.Geometry
  parseNurbsGeometry(e) {
    if (po === void 0)
      return console.error(
        "THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry."
      ), new pt();
    const t = parseInt(e.Order);
    if (isNaN(t))
      return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", e.Order, e.id), new pt();
    const n = t - 1, s = e.KnotVector.a, i = [], r = e.Points.a;
    for (let u = 0, p = r.length; u < p; u += 4)
      i.push(new it().fromArray(r, u));
    let a, l;
    if (e.Form === "Closed")
      i.push(i[0]);
    else if (e.Form === "Periodic") {
      a = n, l = s.length - 1 - a;
      for (let u = 0; u < n; ++u)
        i.push(i[u]);
    }
    const h = new po(n, s, i, a, l).getPoints(i.length * 12);
    return new pt().setFromPoints(h);
  }
}
class jh {
  // take raw animation clips and turn them into three.js animation clips
  parse() {
    const e = [], t = this.parseClips();
    if (t !== void 0)
      for (const n in t) {
        const s = t[n], i = this.addClip(s);
        e.push(i);
      }
    return e;
  }
  parseClips() {
    if (Ce.Objects.AnimationCurve === void 0)
      return;
    const e = this.parseAnimationCurveNodes();
    this.parseAnimationCurves(e);
    const t = this.parseAnimationLayers(e);
    return this.parseAnimStacks(t);
  }
  // parse nodes in FBXTree.Objects.AnimationCurveNode
  // each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )
  // and is referenced by an AnimationLayer
  parseAnimationCurveNodes() {
    const e = Ce.Objects.AnimationCurveNode, t = /* @__PURE__ */ new Map();
    for (const n in e) {
      const s = e[n];
      if (s.attrName.match(/S|R|T|DeformPercent/) !== null) {
        const i = {
          id: s.id,
          attr: s.attrName,
          curves: {}
        };
        t.set(i.id, i);
      }
    }
    return t;
  }
  // parse nodes in FBXTree.Objects.AnimationCurve and connect them up to
  // previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated
  // axis ( e.g. times and values of x rotation)
  parseAnimationCurves(e) {
    const t = Ce.Objects.AnimationCurve;
    for (const n in t) {
      const s = {
        id: t[n].id,
        times: t[n].KeyTime.a.map($h),
        values: t[n].KeyValueFloat.a
      }, i = qe.get(s.id);
      if (i !== void 0) {
        const r = i.parents[0].ID, a = i.parents[0].relationship;
        a.match(/X/) ? e.get(r).curves.x = s : a.match(/Y/) ? e.get(r).curves.y = s : a.match(/Z/) ? e.get(r).curves.z = s : a.match(/d|DeformPercent/) && e.has(r) && (e.get(r).curves.morph = s);
      }
    }
  }
  // parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references
  // to various AnimationCurveNodes and is referenced by an AnimationStack node
  // note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack
  parseAnimationLayers(e) {
    const t = Ce.Objects.AnimationLayer, n = /* @__PURE__ */ new Map();
    for (const s in t) {
      const i = [], r = qe.get(parseInt(s));
      r !== void 0 && (r.children.forEach(function(l, c) {
        if (e.has(l.ID)) {
          const h = e.get(l.ID);
          if (h.curves.x !== void 0 || h.curves.y !== void 0 || h.curves.z !== void 0) {
            if (i[c] === void 0) {
              const u = qe.get(l.ID).parents.filter(function(p) {
                return p.relationship !== void 0;
              })[0].ID;
              if (u !== void 0) {
                const p = Ce.Objects.Model[u.toString()];
                if (p === void 0) {
                  console.warn("THREE.FBXLoader: Encountered a unused curve.", l);
                  return;
                }
                const f = {
                  modelName: p.attrName ? nn.sanitizeNodeName(p.attrName) : "",
                  ID: p.id,
                  initialPosition: [0, 0, 0],
                  initialRotation: [0, 0, 0],
                  initialScale: [1, 1, 1]
                };
                ft.traverse(function(g) {
                  g.ID === p.id && (f.transform = g.matrix, g.userData.transformData && (f.eulerOrder = g.userData.transformData.eulerOrder));
                }), f.transform || (f.transform = new Re()), "PreRotation" in p && (f.preRotation = p.PreRotation.value), "PostRotation" in p && (f.postRotation = p.PostRotation.value), i[c] = f;
              }
            }
            i[c] && (i[c][h.attr] = h);
          } else if (h.curves.morph !== void 0) {
            if (i[c] === void 0) {
              const u = qe.get(l.ID).parents.filter(function(d) {
                return d.relationship !== void 0;
              })[0].ID, p = qe.get(u).parents[0].ID, f = qe.get(p).parents[0].ID, g = qe.get(f).parents[0].ID, m = Ce.Objects.Model[g], y = {
                modelName: m.attrName ? nn.sanitizeNodeName(m.attrName) : "",
                morphName: Ce.Objects.Deformer[u].attrName
              };
              i[c] = y;
            }
            i[c][h.attr] = h;
          }
        }
      }), n.set(parseInt(s), i));
    }
    return n;
  }
  // parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation
  // hierarchy. Each Stack node will be used to create a AnimationClip
  parseAnimStacks(e) {
    const t = Ce.Objects.AnimationStack, n = {};
    for (const s in t) {
      const i = qe.get(parseInt(s)).children;
      i.length > 1 && console.warn(
        "THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers."
      );
      const r = e.get(i[0].ID);
      n[s] = {
        name: t[s].attrName,
        layer: r
      };
    }
    return n;
  }
  addClip(e) {
    let t = [];
    const n = this;
    return e.layer.forEach(function(s) {
      t = t.concat(n.generateTracks(s));
    }), new _a(e.name, -1, t);
  }
  generateTracks(e) {
    const t = [];
    let n = new $(), s = new ze(), i = new $();
    if (e.transform && e.transform.decompose(n, s, i), n = n.toArray(), s = new Tn().setFromQuaternion(s, e.eulerOrder).toArray(), i = i.toArray(), e.T !== void 0 && Object.keys(e.T.curves).length > 0) {
      const r = this.generateVectorTrack(
        e.modelName,
        e.T.curves,
        n,
        "position"
      );
      r !== void 0 && t.push(r);
    }
    if (e.R !== void 0 && Object.keys(e.R.curves).length > 0) {
      const r = this.generateRotationTrack(
        e.modelName,
        e.R.curves,
        s,
        e.preRotation,
        e.postRotation,
        e.eulerOrder
      );
      r !== void 0 && t.push(r);
    }
    if (e.S !== void 0 && Object.keys(e.S.curves).length > 0) {
      const r = this.generateVectorTrack(e.modelName, e.S.curves, i, "scale");
      r !== void 0 && t.push(r);
    }
    if (e.DeformPercent !== void 0) {
      const r = this.generateMorphTrack(e);
      r !== void 0 && t.push(r);
    }
    return t;
  }
  generateVectorTrack(e, t, n, s) {
    const i = this.getTimesForAllAxes(t), r = this.getKeyframeTrackValues(i, t, n);
    return new or(e + "." + s, i, r);
  }
  generateRotationTrack(e, t, n, s, i, r) {
    t.x !== void 0 && (this.interpolateRotations(t.x), t.x.values = t.x.values.map(Ze.degToRad)), t.y !== void 0 && (this.interpolateRotations(t.y), t.y.values = t.y.values.map(Ze.degToRad)), t.z !== void 0 && (this.interpolateRotations(t.z), t.z.values = t.z.values.map(Ze.degToRad));
    const a = this.getTimesForAllAxes(t), l = this.getKeyframeTrackValues(a, t, n);
    s !== void 0 && (s = s.map(Ze.degToRad), s.push(r), s = new Tn().fromArray(s), s = new ze().setFromEuler(s)), i !== void 0 && (i = i.map(Ze.degToRad), i.push(r), i = new Tn().fromArray(i), i = new ze().setFromEuler(i).invert());
    const c = new ze(), h = new Tn(), u = [];
    for (let p = 0; p < l.length; p += 3)
      h.set(l[p], l[p + 1], l[p + 2], r), c.setFromEuler(h), s !== void 0 && c.premultiply(s), i !== void 0 && c.multiply(i), c.toArray(u, p / 3 * 4);
    return new ar(e + ".quaternion", a, u);
  }
  generateMorphTrack(e) {
    const t = e.DeformPercent.curves.morph, n = t.values.map(function(i) {
      return i / 100;
    }), s = ft.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];
    return new lr(
      e.modelName + ".morphTargetInfluences[" + s + "]",
      t.times,
      n
    );
  }
  // For all animated objects, times are defined separately for each axis
  // Here we'll combine the times into one sorted array without duplicates
  getTimesForAllAxes(e) {
    let t = [];
    if (e.x !== void 0 && (t = t.concat(e.x.times)), e.y !== void 0 && (t = t.concat(e.y.times)), e.z !== void 0 && (t = t.concat(e.z.times)), t = t.sort(function(n, s) {
      return n - s;
    }), t.length > 1) {
      let n = 1, s = t[0];
      for (let i = 1; i < t.length; i++) {
        const r = t[i];
        r !== s && (t[n] = r, s = r, n++);
      }
      t = t.slice(0, n);
    }
    return t;
  }
  getKeyframeTrackValues(e, t, n) {
    const s = n, i = [];
    let r = -1, a = -1, l = -1;
    return e.forEach(function(c) {
      if (t.x && (r = t.x.times.indexOf(c)), t.y && (a = t.y.times.indexOf(c)), t.z && (l = t.z.times.indexOf(c)), r !== -1) {
        const h = t.x.values[r];
        i.push(h), s[0] = h;
      } else
        i.push(s[0]);
      if (a !== -1) {
        const h = t.y.values[a];
        i.push(h), s[1] = h;
      } else
        i.push(s[1]);
      if (l !== -1) {
        const h = t.z.values[l];
        i.push(h), s[2] = h;
      } else
        i.push(s[2]);
    }), i;
  }
  // Rotations are defined as Euler angles which can have values  of any size
  // These will be converted to quaternions which don't support values greater than
  // PI, so we'll interpolate large rotations
  interpolateRotations(e) {
    for (let t = 1; t < e.values.length; t++) {
      const n = e.values[t - 1], s = e.values[t] - n, i = Math.abs(s);
      if (i >= 180) {
        const r = i / 180, a = s / r;
        let l = n + a;
        const c = e.times[t - 1], u = (e.times[t] - c) / r;
        let p = c + u;
        const f = [], g = [];
        for (; p < e.times[t]; )
          f.push(p), p += u, g.push(l), l += a;
        e.times = yo(e.times, t, f), e.values = yo(e.values, t, g);
      }
    }
  }
}
class Vh {
  getPrevNode() {
    return this.nodeStack[this.currentIndent - 2];
  }
  getCurrentNode() {
    return this.nodeStack[this.currentIndent - 1];
  }
  getCurrentProp() {
    return this.currentProp;
  }
  pushStack(e) {
    this.nodeStack.push(e), this.currentIndent += 1;
  }
  popStack() {
    this.nodeStack.pop(), this.currentIndent -= 1;
  }
  setCurrentProp(e, t) {
    this.currentProp = e, this.currentPropName = t;
  }
  parse(e) {
    this.currentIndent = 0, this.allNodes = new Qa(), this.nodeStack = [], this.currentProp = [], this.currentPropName = "";
    const t = this, n = e.split(/[\r\n]+/);
    return n.forEach(function(s, i) {
      const r = s.match(/^[\s\t]*;/), a = s.match(/^[\s\t]*$/);
      if (r || a)
        return;
      const l = s.match("^\\t{" + t.currentIndent + "}(\\w+):(.*){", ""), c = s.match("^\\t{" + t.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)"), h = s.match("^\\t{" + (t.currentIndent - 1) + "}}");
      l ? t.parseNodeBegin(s, l) : c ? t.parseNodeProperty(s, c, n[++i]) : h ? t.popStack() : s.match(/^[^\s\t}]/) && t.parseNodePropertyContinued(s);
    }), this.allNodes;
  }
  parseNodeBegin(e, t) {
    const n = t[1].trim().replace(/^"/, "").replace(/"$/, ""), s = t[2].split(",").map(function(l) {
      return l.trim().replace(/^"/, "").replace(/"$/, "");
    }), i = { name: n }, r = this.parseNodeAttr(s), a = this.getCurrentNode();
    this.currentIndent === 0 ? this.allNodes.add(n, i) : n in a ? (n === "PoseNode" ? a.PoseNode.push(i) : a[n].id !== void 0 && (a[n] = {}, a[n][a[n].id] = a[n]), r.id !== "" && (a[n][r.id] = i)) : typeof r.id == "number" ? (a[n] = {}, a[n][r.id] = i) : n !== "Properties70" && (n === "PoseNode" ? a[n] = [i] : a[n] = i), typeof r.id == "number" && (i.id = r.id), r.name !== "" && (i.attrName = r.name), r.type !== "" && (i.attrType = r.type), this.pushStack(i);
  }
  parseNodeAttr(e) {
    let t = e[0];
    e[0] !== "" && (t = parseInt(e[0]), isNaN(t) && (t = e[0]));
    let n = "", s = "";
    return e.length > 1 && (n = e[1].replace(/^(\w+)::/, ""), s = e[2]), { id: t, name: n, type: s };
  }
  parseNodeProperty(e, t, n) {
    let s = t[1].replace(/^"/, "").replace(/"$/, "").trim(), i = t[2].replace(/^"/, "").replace(/"$/, "").trim();
    s === "Content" && i === "," && (i = n.replace(/"/g, "").replace(/,$/, "").trim());
    const r = this.getCurrentNode();
    if (r.name === "Properties70") {
      this.parseNodeSpecialProperty(e, s, i);
      return;
    }
    if (s === "C") {
      const l = i.split(",").slice(1), c = parseInt(l[0]), h = parseInt(l[1]);
      let u = i.split(",").slice(3);
      u = u.map(function(p) {
        return p.trim().replace(/^"/, "");
      }), s = "connections", i = [c, h], Kh(i, u), r[s] === void 0 && (r[s] = []);
    }
    s === "Node" && (r.id = i), s in r && Array.isArray(r[s]) ? r[s].push(i) : s !== "a" ? r[s] = i : r.a = i, this.setCurrentProp(r, s), s === "a" && i.slice(-1) !== "," && (r.a = Ii(i));
  }
  parseNodePropertyContinued(e) {
    const t = this.getCurrentNode();
    t.a += e, e.slice(-1) !== "," && (t.a = Ii(t.a));
  }
  // parse "Property70"
  parseNodeSpecialProperty(e, t, n) {
    const s = n.split('",').map(function(h) {
      return h.trim().replace(/^\"/, "").replace(/\s/, "_");
    }), i = s[0], r = s[1], a = s[2], l = s[3];
    let c = s[4];
    switch (r) {
      case "int":
      case "enum":
      case "bool":
      case "ULongLong":
      case "double":
      case "Number":
      case "FieldOfView":
        c = parseFloat(c);
        break;
      case "Color":
      case "ColorRGB":
      case "Vector3D":
      case "Lcl_Translation":
      case "Lcl_Rotation":
      case "Lcl_Scaling":
        c = Ii(c);
        break;
    }
    this.getPrevNode()[i] = {
      type: r,
      type2: a,
      flag: l,
      value: c
    }, this.setCurrentProp(this.getPrevNode(), i);
  }
}
class Yh {
  parse(e) {
    const t = new mo(e);
    t.skip(23);
    const n = t.getUint32();
    if (n < 6400)
      throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + n);
    const s = new Qa();
    for (; !this.endOfContent(t); ) {
      const i = this.parseNode(t, n);
      i !== null && s.add(i.name, i);
    }
    return s;
  }
  // Check if reader has reached the end of content.
  endOfContent(e) {
    return e.size() % 16 === 0 ? (e.getOffset() + 160 + 16 & -16) >= e.size() : e.getOffset() + 160 + 16 >= e.size();
  }
  // recursively parse nodes until the end of the file is reached
  parseNode(e, t) {
    const n = {}, s = t >= 7500 ? e.getUint64() : e.getUint32(), i = t >= 7500 ? e.getUint64() : e.getUint32();
    t >= 7500 ? e.getUint64() : e.getUint32();
    const r = e.getUint8(), a = e.getString(r);
    if (s === 0)
      return null;
    const l = [];
    for (let p = 0; p < i; p++)
      l.push(this.parseProperty(e));
    const c = l.length > 0 ? l[0] : "", h = l.length > 1 ? l[1] : "", u = l.length > 2 ? l[2] : "";
    for (n.singleProperty = i === 1 && e.getOffset() === s; s > e.getOffset(); ) {
      const p = this.parseNode(e, t);
      p !== null && this.parseSubNode(a, n, p);
    }
    return n.propertyList = l, typeof c == "number" && (n.id = c), h !== "" && (n.attrName = h), u !== "" && (n.attrType = u), a !== "" && (n.name = a), n;
  }
  parseSubNode(e, t, n) {
    if (n.singleProperty === !0) {
      const s = n.propertyList[0];
      Array.isArray(s) ? (t[n.name] = n, n.a = s) : t[n.name] = s;
    } else if (e === "Connections" && n.name === "C") {
      const s = [];
      n.propertyList.forEach(function(i, r) {
        r !== 0 && s.push(i);
      }), t.connections === void 0 && (t.connections = []), t.connections.push(s);
    } else if (n.name === "Properties70")
      Object.keys(n).forEach(function(i) {
        t[i] = n[i];
      });
    else if (e === "Properties70" && n.name === "P") {
      let s = n.propertyList[0], i = n.propertyList[1];
      const r = n.propertyList[2], a = n.propertyList[3];
      let l;
      s.indexOf("Lcl ") === 0 && (s = s.replace("Lcl ", "Lcl_")), i.indexOf("Lcl ") === 0 && (i = i.replace("Lcl ", "Lcl_")), i === "Color" || i === "ColorRGB" || i === "Vector" || i === "Vector3D" || i.indexOf("Lcl_") === 0 ? l = [n.propertyList[4], n.propertyList[5], n.propertyList[6]] : l = n.propertyList[4], t[s] = {
        type: i,
        type2: r,
        flag: a,
        value: l
      };
    } else t[n.name] === void 0 ? typeof n.id == "number" ? (t[n.name] = {}, t[n.name][n.id] = n) : t[n.name] = n : n.name === "PoseNode" ? (Array.isArray(t[n.name]) || (t[n.name] = [t[n.name]]), t[n.name].push(n)) : t[n.name][n.id] === void 0 && (t[n.name][n.id] = n);
  }
  parseProperty(e) {
    const t = e.getString(1);
    let n;
    switch (t) {
      case "C":
        return e.getBoolean();
      case "D":
        return e.getFloat64();
      case "F":
        return e.getFloat32();
      case "I":
        return e.getInt32();
      case "L":
        return e.getInt64();
      case "R":
        return n = e.getUint32(), e.getArrayBuffer(n);
      case "S":
        return n = e.getUint32(), e.getString(n);
      case "Y":
        return e.getInt16();
      case "b":
      case "c":
      case "d":
      case "f":
      case "i":
      case "l":
        const s = e.getUint32(), i = e.getUint32(), r = e.getUint32();
        if (i === 0)
          switch (t) {
            case "b":
            case "c":
              return e.getBooleanArray(s);
            case "d":
              return e.getFloat64Array(s);
            case "f":
              return e.getFloat32Array(s);
            case "i":
              return e.getInt32Array(s);
            case "l":
              return e.getInt64Array(s);
          }
        const a = oh(new Uint8Array(e.getArrayBuffer(r))), l = new mo(a.buffer);
        switch (t) {
          case "b":
          case "c":
            return l.getBooleanArray(s);
          case "d":
            return l.getFloat64Array(s);
          case "f":
            return l.getFloat32Array(s);
          case "i":
            return l.getInt32Array(s);
          case "l":
            return l.getInt64Array(s);
        }
      default:
        throw new Error("THREE.FBXLoader: Unknown property type " + t);
    }
  }
}
class mo {
  constructor(e, t) {
    this.dv = new DataView(e), this.offset = 0, this.littleEndian = t !== void 0 ? t : !0;
  }
  getOffset() {
    return this.offset;
  }
  size() {
    return this.dv.buffer.byteLength;
  }
  skip(e) {
    this.offset += e;
  }
  // seems like true/false representation depends on exporter.
  // true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)
  // then sees LSB.
  getBoolean() {
    return (this.getUint8() & 1) === 1;
  }
  getBooleanArray(e) {
    const t = [];
    for (let n = 0; n < e; n++)
      t.push(this.getBoolean());
    return t;
  }
  getUint8() {
    const e = this.dv.getUint8(this.offset);
    return this.offset += 1, e;
  }
  getInt16() {
    const e = this.dv.getInt16(this.offset, this.littleEndian);
    return this.offset += 2, e;
  }
  getInt32() {
    const e = this.dv.getInt32(this.offset, this.littleEndian);
    return this.offset += 4, e;
  }
  getInt32Array(e) {
    const t = [];
    for (let n = 0; n < e; n++)
      t.push(this.getInt32());
    return t;
  }
  getUint32() {
    const e = this.dv.getUint32(this.offset, this.littleEndian);
    return this.offset += 4, e;
  }
  // JavaScript doesn't support 64-bit integer so calculate this here
  // 1 << 32 will return 1 so using multiply operation instead here.
  // There's a possibility that this method returns wrong value if the value
  // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.
  // TODO: safely handle 64-bit integer
  getInt64() {
    let e, t;
    return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), t & 2147483648 ? (t = ~t & 4294967295, e = ~e & 4294967295, e === 4294967295 && (t = t + 1 & 4294967295), e = e + 1 & 4294967295, -(t * 4294967296 + e)) : t * 4294967296 + e;
  }
  getInt64Array(e) {
    const t = [];
    for (let n = 0; n < e; n++)
      t.push(this.getInt64());
    return t;
  }
  // Note: see getInt64() comment
  getUint64() {
    let e, t;
    return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), t * 4294967296 + e;
  }
  getFloat32() {
    const e = this.dv.getFloat32(this.offset, this.littleEndian);
    return this.offset += 4, e;
  }
  getFloat32Array(e) {
    const t = [];
    for (let n = 0; n < e; n++)
      t.push(this.getFloat32());
    return t;
  }
  getFloat64() {
    const e = this.dv.getFloat64(this.offset, this.littleEndian);
    return this.offset += 8, e;
  }
  getFloat64Array(e) {
    const t = [];
    for (let n = 0; n < e; n++)
      t.push(this.getFloat64());
    return t;
  }
  getArrayBuffer(e) {
    const t = this.dv.buffer.slice(this.offset, this.offset + e);
    return this.offset += e, t;
  }
  getString(e) {
    let t = [];
    for (let s = 0; s < e; s++)
      t[s] = this.getUint8();
    const n = t.indexOf(0);
    return n >= 0 && (t = t.slice(0, n)), Ka(new Uint8Array(t));
  }
}
class Qa {
  add(e, t) {
    this[e] = t;
  }
}
function Xh(o) {
  const e = "Kaydara FBX Binary  \0";
  return o.byteLength >= e.length && e === tl(o, 0, e.length);
}
function Wh(o) {
  const e = [
    "K",
    "a",
    "y",
    "d",
    "a",
    "r",
    "a",
    "\\",
    "F",
    "B",
    "X",
    "\\",
    "B",
    "i",
    "n",
    "a",
    "r",
    "y",
    "\\",
    "\\"
  ];
  let t = 0;
  function n(s) {
    const i = o[s - 1];
    return o = o.slice(t + s), t++, i;
  }
  for (let s = 0; s < e.length; ++s)
    if (n(1) === e[s])
      return !1;
  return !0;
}
function go(o) {
  const e = /FBXVersion: (\d+)/, t = o.match(e);
  if (t)
    return parseInt(t[1]);
  throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.");
}
function $h(o) {
  return o / 46186158e3;
}
const Zh = [];
function Xs(o, e, t, n) {
  let s;
  switch (n.mappingType) {
    case "ByPolygonVertex":
      s = o;
      break;
    case "ByPolygon":
      s = e;
      break;
    case "ByVertice":
      s = t;
      break;
    case "AllSame":
      s = n.indices[0];
      break;
    default:
      console.warn("THREE.FBXLoader: unknown attribute mapping type " + n.mappingType);
  }
  n.referenceType === "IndexToDirect" && (s = n.indices[s]);
  const i = s * n.dataSize, r = i + n.dataSize;
  return qh(Zh, n.buffer, i, r);
}
const Ri = new Tn(), jn = new $();
function Ja(o) {
  const e = new Re(), t = new Re(), n = new Re(), s = new Re(), i = new Re(), r = new Re(), a = new Re(), l = new Re(), c = new Re(), h = new Re(), u = new Re(), p = new Re(), f = o.inheritType ? o.inheritType : 0;
  if (o.translation && e.setPosition(jn.fromArray(o.translation)), o.preRotation) {
    const _ = o.preRotation.map(Ze.degToRad);
    _.push(o.eulerOrder), t.makeRotationFromEuler(Ri.fromArray(_));
  }
  if (o.rotation) {
    const _ = o.rotation.map(Ze.degToRad);
    _.push(o.eulerOrder), n.makeRotationFromEuler(Ri.fromArray(_));
  }
  if (o.postRotation) {
    const _ = o.postRotation.map(Ze.degToRad);
    _.push(o.eulerOrder), s.makeRotationFromEuler(Ri.fromArray(_)), s.invert();
  }
  o.scale && i.scale(jn.fromArray(o.scale)), o.scalingOffset && a.setPosition(jn.fromArray(o.scalingOffset)), o.scalingPivot && r.setPosition(jn.fromArray(o.scalingPivot)), o.rotationOffset && l.setPosition(jn.fromArray(o.rotationOffset)), o.rotationPivot && c.setPosition(jn.fromArray(o.rotationPivot)), o.parentMatrixWorld && (u.copy(o.parentMatrix), h.copy(o.parentMatrixWorld));
  const g = t.clone().multiply(n).multiply(s), m = new Re();
  m.extractRotation(h);
  const y = new Re();
  y.copyPosition(h);
  const d = y.clone().invert().multiply(h), w = m.clone().invert().multiply(d), v = i, E = new Re();
  if (f === 0)
    E.copy(m).multiply(g).multiply(w).multiply(v);
  else if (f === 1)
    E.copy(m).multiply(w).multiply(g).multiply(v);
  else {
    const C = new Re().scale(new $().setFromMatrixScale(u)).clone().invert(), R = w.clone().multiply(C);
    E.copy(m).multiply(g).multiply(R).multiply(v);
  }
  const P = c.clone().invert(), T = r.clone().invert();
  let b = e.clone().multiply(l).multiply(c).multiply(t).multiply(n).multiply(s).multiply(P).multiply(a).multiply(r).multiply(i).multiply(T);
  const x = new Re().copyPosition(b), M = h.clone().multiply(x);
  return p.copyPosition(M), b = p.clone().multiply(E), b.premultiply(h.invert()), b;
}
function el(o) {
  o = o || 0;
  const e = [
    "ZYX",
    // -> XYZ extrinsic
    "YZX",
    // -> XZY extrinsic
    "XZY",
    // -> YZX extrinsic
    "ZXY",
    // -> YXZ extrinsic
    "YXZ",
    // -> ZXY extrinsic
    "XYZ"
    // -> ZYX extrinsic
    //'SphericXYZ', // not possible to support
  ];
  return o === 6 ? (console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."), e[0]) : e[o];
}
function Ii(o) {
  return o.split(",").map(function(t) {
    return parseFloat(t);
  });
}
function tl(o, e, t) {
  return e === void 0 && (e = 0), t === void 0 && (t = o.byteLength), Ka(new Uint8Array(o, e, t));
}
function Kh(o, e) {
  for (let t = 0, n = o.length, s = e.length; t < s; t++, n++)
    o[n] = e[t];
}
function qh(o, e, t, n) {
  for (let s = t, i = 0; s < n; s++, i++)
    o[i] = e[s];
  return o;
}
function yo(o, e, t) {
  return o.slice(0, e).concat(t).concat(o.slice(e));
}
var Qh = Object.defineProperty, Jh = (o, e, t) => e in o ? Qh(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t, kr = (o, e, t) => (Jh(o, typeof e != "symbol" ? e + "" : e, t), t);
class ef extends As {
  constructor(e) {
    super(e);
  }
  load(e, t, n, s) {
    const i = new Bn(this.manager);
    i.setPath(this.path), i.setRequestHeader(this.requestHeader), i.setWithCredentials(this.withCredentials), i.load(
      e,
      (r) => {
        if (typeof r != "string")
          throw new Error("unsupported data type");
        const a = JSON.parse(r), l = this.parse(a);
        t && t(l);
      },
      n,
      s
    );
  }
  loadAsync(e, t) {
    return super.loadAsync(e, t);
  }
  parse(e) {
    return new Br(e);
  }
}
class Br {
  constructor(e) {
    kr(this, "data"), this.data = e;
  }
  generateShapes(e, t = 100, n) {
    const s = [], i = { letterSpacing: 0, lineHeight: 1, ...n }, r = tf(e, t, this.data, i);
    for (let a = 0, l = r.length; a < l; a++)
      Array.prototype.push.apply(s, r[a].toShapes(!1));
    return s;
  }
}
kr(Br, "isFont");
kr(Br, "type");
function tf(o, e, t, n) {
  const s = Array.from(o), i = e / t.resolution, r = (t.boundingBox.yMax - t.boundingBox.yMin + t.underlineThickness) * i, a = [];
  let l = 0, c = 0;
  for (let h = 0; h < s.length; h++) {
    const u = s[h];
    if (u === `
`)
      l = 0, c -= r * n.lineHeight;
    else {
      const p = nf(u, i, l, c, t);
      p && (l += p.offsetX + n.letterSpacing, a.push(p.path));
    }
  }
  return a;
}
function nf(o, e, t, n, s) {
  const i = s.glyphs[o] || s.glyphs["?"];
  if (!i) {
    console.error('THREE.Font: character "' + o + '" does not exists in font family ' + s.familyName + ".");
    return;
  }
  const r = new gn();
  let a, l, c, h, u, p, f, g;
  if (i.o) {
    const m = i._cachedOutline || (i._cachedOutline = i.o.split(" "));
    for (let y = 0, d = m.length; y < d; )
      switch (m[y++]) {
        case "m":
          a = parseInt(m[y++]) * e + t, l = parseInt(m[y++]) * e + n, r.moveTo(a, l);
          break;
        case "l":
          a = parseInt(m[y++]) * e + t, l = parseInt(m[y++]) * e + n, r.lineTo(a, l);
          break;
        case "q":
          c = parseInt(m[y++]) * e + t, h = parseInt(m[y++]) * e + n, u = parseInt(m[y++]) * e + t, p = parseInt(m[y++]) * e + n, r.quadraticCurveTo(u, p, c, h);
          break;
        case "b":
          c = parseInt(m[y++]) * e + t, h = parseInt(m[y++]) * e + n, u = parseInt(m[y++]) * e + t, p = parseInt(m[y++]) * e + n, f = parseInt(m[y++]) * e + t, g = parseInt(m[y++]) * e + n, r.bezierCurveTo(u, p, f, g, c, h);
          break;
      }
  }
  return { offsetX: i.ha * e, path: r };
}
class vo extends Bl {
  constructor(e) {
    super(e), this.type = Vt;
  }
  // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html
  parse(e) {
    const r = function(x, M) {
      switch (x) {
        case 1:
          throw new Error("THREE.RGBELoader: Read Error: " + (M || ""));
        case 2:
          throw new Error("THREE.RGBELoader: Write Error: " + (M || ""));
        case 3:
          throw new Error("THREE.RGBELoader: Bad File Format: " + (M || ""));
        default:
        case 4:
          throw new Error("THREE.RGBELoader: Memory Error: " + (M || ""));
      }
    }, h = `
`, u = function(x, M, _) {
      M = M || 1024;
      let R = x.pos, B = -1, N = 0, j = "", V = String.fromCharCode.apply(null, new Uint16Array(x.subarray(R, R + 128)));
      for (; 0 > (B = V.indexOf(h)) && N < M && R < x.byteLength; )
        j += V, N += V.length, R += 128, V += String.fromCharCode.apply(null, new Uint16Array(x.subarray(R, R + 128)));
      return -1 < B ? (x.pos += N + B + 1, j + V.slice(0, B)) : !1;
    }, p = function(x) {
      const M = /^#\?(\S+)/, _ = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/, C = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/, R = /^\s*FORMAT=(\S+)\s*$/, B = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/, N = {
        valid: 0,
        string: "",
        comments: "",
        programtype: "RGBE",
        format: "",
        gamma: 1,
        exposure: 1,
        width: 0,
        height: 0
      };
      let j, V;
      for ((x.pos >= x.byteLength || !(j = u(x))) && r(1, "no header found"), (V = j.match(M)) || r(3, "bad initial token"), N.valid |= 1, N.programtype = V[1], N.string += j + `
`; j = u(x), j !== !1; ) {
        if (N.string += j + `
`, j.charAt(0) === "#") {
          N.comments += j + `
`;
          continue;
        }
        if ((V = j.match(_)) && (N.gamma = parseFloat(V[1])), (V = j.match(C)) && (N.exposure = parseFloat(V[1])), (V = j.match(R)) && (N.valid |= 2, N.format = V[1]), (V = j.match(B)) && (N.valid |= 4, N.height = parseInt(V[1], 10), N.width = parseInt(V[2], 10)), N.valid & 2 && N.valid & 4)
          break;
      }
      return N.valid & 2 || r(3, "missing format specifier"), N.valid & 4 || r(3, "missing image size specifier"), N;
    }, f = function(x, M, _) {
      const C = M;
      if (
        // run length encoding is not allowed so read flat
        C < 8 || C > 32767 || // this file is not run length encoded
        x[0] !== 2 || x[1] !== 2 || x[2] & 128
      )
        return new Uint8Array(x);
      C !== (x[2] << 8 | x[3]) && r(3, "wrong scanline width");
      const R = new Uint8Array(4 * M * _);
      R.length || r(4, "unable to allocate buffer space");
      let B = 0, N = 0;
      const j = 4 * C, V = new Uint8Array(4), Q = new Uint8Array(j);
      let Z = _;
      for (; Z > 0 && N < x.byteLength; ) {
        N + 4 > x.byteLength && r(1), V[0] = x[N++], V[1] = x[N++], V[2] = x[N++], V[3] = x[N++], (V[0] != 2 || V[1] != 2 || (V[2] << 8 | V[3]) != C) && r(3, "bad rgbe scanline format");
        let ne = 0, te;
        for (; ne < j && N < x.byteLength; ) {
          te = x[N++];
          const ae = te > 128;
          if (ae && (te -= 128), (te === 0 || ne + te > j) && r(3, "bad scanline data"), ae) {
            const Te = x[N++];
            for (let I = 0; I < te; I++)
              Q[ne++] = Te;
          } else
            Q.set(x.subarray(N, N + te), ne), ne += te, N += te;
        }
        const le = C;
        for (let ae = 0; ae < le; ae++) {
          let Te = 0;
          R[B] = Q[ae + Te], Te += C, R[B + 1] = Q[ae + Te], Te += C, R[B + 2] = Q[ae + Te], Te += C, R[B + 3] = Q[ae + Te], B += 4;
        }
        Z--;
      }
      return R;
    }, g = function(x, M, _, C) {
      const R = x[M + 3], B = Math.pow(2, R - 128) / 255;
      _[C + 0] = x[M + 0] * B, _[C + 1] = x[M + 1] * B, _[C + 2] = x[M + 2] * B, _[C + 3] = 1;
    }, m = function(x, M, _, C) {
      const R = x[M + 3], B = Math.pow(2, R - 128) / 255;
      _[C + 0] = Ns.toHalfFloat(Math.min(x[M + 0] * B, 65504)), _[C + 1] = Ns.toHalfFloat(Math.min(x[M + 1] * B, 65504)), _[C + 2] = Ns.toHalfFloat(Math.min(x[M + 2] * B, 65504)), _[C + 3] = Ns.toHalfFloat(1);
    }, y = new Uint8Array(e);
    y.pos = 0;
    const d = p(y), w = d.width, v = d.height, E = f(y.subarray(y.pos), w, v);
    let P, T, b;
    switch (this.type) {
      case si:
        b = E.length / 4;
        const x = new Float32Array(b * 4);
        for (let _ = 0; _ < b; _++)
          g(E, _ * 4, x, _ * 4);
        P = x, T = si;
        break;
      case Vt:
        b = E.length / 4;
        const M = new Uint16Array(b * 4);
        for (let _ = 0; _ < b; _++)
          m(E, _ * 4, M, _ * 4);
        P = M, T = Vt;
        break;
      default:
        throw new Error("THREE.RGBELoader: Unsupported type: " + this.type);
    }
    return {
      width: w,
      height: v,
      data: P,
      header: d.string,
      gamma: d.gamma,
      exposure: d.exposure,
      type: T
    };
  }
  setDataType(e) {
    return this.type = e, this;
  }
  load(e, t, n, s) {
    function i(r, a) {
      switch (r.type) {
        case si:
        case Vt:
          "colorSpace" in r ? r.colorSpace = "srgb-linear" : r.encoding = 3e3, r.minFilter = vt, r.magFilter = vt, r.generateMipmaps = !1, r.flipY = !0;
          break;
      }
      t && t(r, a);
    }
    return super.load(e, i, n, s);
  }
}
const sf = "srgb";
class xs extends As {
  constructor(e) {
    super(e), this.defaultDPI = 90, this.defaultUnit = "px";
  }
  load(e, t, n, s) {
    const i = this, r = new Bn(i.manager);
    r.setPath(i.path), r.setRequestHeader(i.requestHeader), r.setWithCredentials(i.withCredentials), r.load(
      e,
      function(a) {
        try {
          t(i.parse(a));
        } catch (l) {
          s ? s(l) : console.error(l), i.manager.itemError(e);
        }
      },
      n,
      s
    );
  }
  parse(e) {
    const t = this;
    function n(I, k) {
      if (I.nodeType !== 1)
        return;
      const D = E(I);
      let O = !1, z = null;
      switch (I.nodeName) {
        case "svg":
          k = g(I, k);
          break;
        case "style":
          i(I);
          break;
        case "g":
          k = g(I, k);
          break;
        case "path":
          k = g(I, k), I.hasAttribute("d") && (z = s(I));
          break;
        case "rect":
          k = g(I, k), z = l(I);
          break;
        case "polygon":
          k = g(I, k), z = c(I);
          break;
        case "polyline":
          k = g(I, k), z = h(I);
          break;
        case "circle":
          k = g(I, k), z = u(I);
          break;
        case "ellipse":
          k = g(I, k), z = p(I);
          break;
        case "line":
          k = g(I, k), z = f(I);
          break;
        case "defs":
          O = !0;
          break;
        case "use":
          k = g(I, k);
          const L = (I.getAttributeNS("http://www.w3.org/1999/xlink", "href") || "").substring(1), X = I.viewportElement.getElementById(L);
          X ? n(X, k) : console.warn("SVGLoader: 'use node' references non-existent node id: " + L);
          break;
      }
      z && (k.fill !== void 0 && k.fill !== "none" && z.color.setStyle(k.fill, sf), T(z, le), R.push(z), z.userData = { node: I, style: k });
      const S = I.childNodes;
      for (let A = 0; A < S.length; A++) {
        const L = S[A];
        O && L.nodeName !== "style" && L.nodeName !== "defs" || n(L, k);
      }
      D && (N.pop(), N.length > 0 ? le.copy(N[N.length - 1]) : le.identity());
    }
    function s(I) {
      const k = new gn(), D = new ge(), O = new ge(), z = new ge();
      let S = !0, A = !1;
      const L = I.getAttribute("d");
      if (L === "" || L === "none")
        return null;
      const X = L.match(/[a-df-z][^a-df-z]*/gi);
      for (let H = 0, G = X.length; H < G; H++) {
        const q = X[H], se = q.charAt(0), ie = q.slice(1).trim();
        S === !0 && (A = !0, S = !1);
        let Y;
        switch (se) {
          case "M":
            Y = y(ie);
            for (let F = 0, oe = Y.length; F < oe; F += 2)
              D.x = Y[F + 0], D.y = Y[F + 1], O.x = D.x, O.y = D.y, F === 0 ? k.moveTo(D.x, D.y) : k.lineTo(D.x, D.y), F === 0 && z.copy(D);
            break;
          case "H":
            Y = y(ie);
            for (let F = 0, oe = Y.length; F < oe; F++)
              D.x = Y[F], O.x = D.x, O.y = D.y, k.lineTo(D.x, D.y), F === 0 && A === !0 && z.copy(D);
            break;
          case "V":
            Y = y(ie);
            for (let F = 0, oe = Y.length; F < oe; F++)
              D.y = Y[F], O.x = D.x, O.y = D.y, k.lineTo(D.x, D.y), F === 0 && A === !0 && z.copy(D);
            break;
          case "L":
            Y = y(ie);
            for (let F = 0, oe = Y.length; F < oe; F += 2)
              D.x = Y[F + 0], D.y = Y[F + 1], O.x = D.x, O.y = D.y, k.lineTo(D.x, D.y), F === 0 && A === !0 && z.copy(D);
            break;
          case "C":
            Y = y(ie);
            for (let F = 0, oe = Y.length; F < oe; F += 6)
              k.bezierCurveTo(
                Y[F + 0],
                Y[F + 1],
                Y[F + 2],
                Y[F + 3],
                Y[F + 4],
                Y[F + 5]
              ), O.x = Y[F + 2], O.y = Y[F + 3], D.x = Y[F + 4], D.y = Y[F + 5], F === 0 && A === !0 && z.copy(D);
            break;
          case "S":
            Y = y(ie);
            for (let F = 0, oe = Y.length; F < oe; F += 4)
              k.bezierCurveTo(
                m(D.x, O.x),
                m(D.y, O.y),
                Y[F + 0],
                Y[F + 1],
                Y[F + 2],
                Y[F + 3]
              ), O.x = Y[F + 0], O.y = Y[F + 1], D.x = Y[F + 2], D.y = Y[F + 3], F === 0 && A === !0 && z.copy(D);
            break;
          case "Q":
            Y = y(ie);
            for (let F = 0, oe = Y.length; F < oe; F += 4)
              k.quadraticCurveTo(Y[F + 0], Y[F + 1], Y[F + 2], Y[F + 3]), O.x = Y[F + 0], O.y = Y[F + 1], D.x = Y[F + 2], D.y = Y[F + 3], F === 0 && A === !0 && z.copy(D);
            break;
          case "T":
            Y = y(ie);
            for (let F = 0, oe = Y.length; F < oe; F += 2) {
              const pe = m(D.x, O.x), Ae = m(D.y, O.y);
              k.quadraticCurveTo(pe, Ae, Y[F + 0], Y[F + 1]), O.x = pe, O.y = Ae, D.x = Y[F + 0], D.y = Y[F + 1], F === 0 && A === !0 && z.copy(D);
            }
            break;
          case "A":
            Y = y(ie, [3, 4], 7);
            for (let F = 0, oe = Y.length; F < oe; F += 7) {
              if (Y[F + 5] == D.x && Y[F + 6] == D.y)
                continue;
              const pe = D.clone();
              D.x = Y[F + 5], D.y = Y[F + 6], O.x = D.x, O.y = D.y, r(
                k,
                Y[F],
                Y[F + 1],
                Y[F + 2],
                Y[F + 3],
                Y[F + 4],
                pe,
                D
              ), F === 0 && A === !0 && z.copy(D);
            }
            break;
          case "m":
            Y = y(ie);
            for (let F = 0, oe = Y.length; F < oe; F += 2)
              D.x += Y[F + 0], D.y += Y[F + 1], O.x = D.x, O.y = D.y, F === 0 ? k.moveTo(D.x, D.y) : k.lineTo(D.x, D.y), F === 0 && z.copy(D);
            break;
          case "h":
            Y = y(ie);
            for (let F = 0, oe = Y.length; F < oe; F++)
              D.x += Y[F], O.x = D.x, O.y = D.y, k.lineTo(D.x, D.y), F === 0 && A === !0 && z.copy(D);
            break;
          case "v":
            Y = y(ie);
            for (let F = 0, oe = Y.length; F < oe; F++)
              D.y += Y[F], O.x = D.x, O.y = D.y, k.lineTo(D.x, D.y), F === 0 && A === !0 && z.copy(D);
            break;
          case "l":
            Y = y(ie);
            for (let F = 0, oe = Y.length; F < oe; F += 2)
              D.x += Y[F + 0], D.y += Y[F + 1], O.x = D.x, O.y = D.y, k.lineTo(D.x, D.y), F === 0 && A === !0 && z.copy(D);
            break;
          case "c":
            Y = y(ie);
            for (let F = 0, oe = Y.length; F < oe; F += 6)
              k.bezierCurveTo(
                D.x + Y[F + 0],
                D.y + Y[F + 1],
                D.x + Y[F + 2],
                D.y + Y[F + 3],
                D.x + Y[F + 4],
                D.y + Y[F + 5]
              ), O.x = D.x + Y[F + 2], O.y = D.y + Y[F + 3], D.x += Y[F + 4], D.y += Y[F + 5], F === 0 && A === !0 && z.copy(D);
            break;
          case "s":
            Y = y(ie);
            for (let F = 0, oe = Y.length; F < oe; F += 4)
              k.bezierCurveTo(
                m(D.x, O.x),
                m(D.y, O.y),
                D.x + Y[F + 0],
                D.y + Y[F + 1],
                D.x + Y[F + 2],
                D.y + Y[F + 3]
              ), O.x = D.x + Y[F + 0], O.y = D.y + Y[F + 1], D.x += Y[F + 2], D.y += Y[F + 3], F === 0 && A === !0 && z.copy(D);
            break;
          case "q":
            Y = y(ie);
            for (let F = 0, oe = Y.length; F < oe; F += 4)
              k.quadraticCurveTo(
                D.x + Y[F + 0],
                D.y + Y[F + 1],
                D.x + Y[F + 2],
                D.y + Y[F + 3]
              ), O.x = D.x + Y[F + 0], O.y = D.y + Y[F + 1], D.x += Y[F + 2], D.y += Y[F + 3], F === 0 && A === !0 && z.copy(D);
            break;
          case "t":
            Y = y(ie);
            for (let F = 0, oe = Y.length; F < oe; F += 2) {
              const pe = m(D.x, O.x), Ae = m(D.y, O.y);
              k.quadraticCurveTo(pe, Ae, D.x + Y[F + 0], D.y + Y[F + 1]), O.x = pe, O.y = Ae, D.x = D.x + Y[F + 0], D.y = D.y + Y[F + 1], F === 0 && A === !0 && z.copy(D);
            }
            break;
          case "a":
            Y = y(ie, [3, 4], 7);
            for (let F = 0, oe = Y.length; F < oe; F += 7) {
              if (Y[F + 5] == 0 && Y[F + 6] == 0)
                continue;
              const pe = D.clone();
              D.x += Y[F + 5], D.y += Y[F + 6], O.x = D.x, O.y = D.y, r(
                k,
                Y[F],
                Y[F + 1],
                Y[F + 2],
                Y[F + 3],
                Y[F + 4],
                pe,
                D
              ), F === 0 && A === !0 && z.copy(D);
            }
            break;
          case "Z":
          case "z":
            k.currentPath.autoClose = !0, k.currentPath.curves.length > 0 && (D.copy(z), k.currentPath.currentPoint.copy(D), S = !0);
            break;
          default:
            console.warn(q);
        }
        A = !1;
      }
      return k;
    }
    function i(I) {
      if (!(!I.sheet || !I.sheet.cssRules || !I.sheet.cssRules.length))
        for (let k = 0; k < I.sheet.cssRules.length; k++) {
          const D = I.sheet.cssRules[k];
          if (D.type !== 1)
            continue;
          const O = D.selectorText.split(/,/gm).filter(Boolean).map((z) => z.trim());
          for (let z = 0; z < O.length; z++) {
            const S = Object.fromEntries(Object.entries(D.style).filter(([, A]) => A !== ""));
            B[O[z]] = Object.assign(B[O[z]] || {}, S);
          }
        }
    }
    function r(I, k, D, O, z, S, A, L) {
      if (k == 0 || D == 0) {
        I.lineTo(L.x, L.y);
        return;
      }
      O = O * Math.PI / 180, k = Math.abs(k), D = Math.abs(D);
      const X = (A.x - L.x) / 2, H = (A.y - L.y) / 2, G = Math.cos(O) * X + Math.sin(O) * H, q = -Math.sin(O) * X + Math.cos(O) * H;
      let se = k * k, ie = D * D;
      const Y = G * G, F = q * q, oe = Y / se + F / ie;
      if (oe > 1) {
        const wt = Math.sqrt(oe);
        k = wt * k, D = wt * D, se = k * k, ie = D * D;
      }
      const pe = se * F + ie * Y, Ae = (se * ie - pe) / pe;
      let Ve = Math.sqrt(Math.max(0, Ae));
      z === S && (Ve = -Ve);
      const We = Ve * k * q / D, xt = -Ve * D * G / k, Xt = Math.cos(O) * We - Math.sin(O) * xt + (A.x + L.x) / 2, ln = Math.sin(O) * We + Math.cos(O) * xt + (A.y + L.y) / 2, cn = a(1, 0, (G - We) / k, (q - xt) / D), gt = a((G - We) / k, (q - xt) / D, (-G - We) / k, (-q - xt) / D) % (Math.PI * 2);
      I.currentPath.absellipse(Xt, ln, k, D, cn, cn + gt, S === 0, O);
    }
    function a(I, k, D, O) {
      const z = I * D + k * O, S = Math.sqrt(I * I + k * k) * Math.sqrt(D * D + O * O);
      let A = Math.acos(Math.max(-1, Math.min(1, z / S)));
      return I * O - k * D < 0 && (A = -A), A;
    }
    function l(I) {
      const k = v(I.getAttribute("x") || 0), D = v(I.getAttribute("y") || 0), O = v(I.getAttribute("rx") || I.getAttribute("ry") || 0), z = v(I.getAttribute("ry") || I.getAttribute("rx") || 0), S = v(I.getAttribute("width")), A = v(I.getAttribute("height")), L = 1 - 0.551915024494, X = new gn();
      return X.moveTo(k + O, D), X.lineTo(k + S - O, D), (O !== 0 || z !== 0) && X.bezierCurveTo(k + S - O * L, D, k + S, D + z * L, k + S, D + z), X.lineTo(k + S, D + A - z), (O !== 0 || z !== 0) && X.bezierCurveTo(k + S, D + A - z * L, k + S - O * L, D + A, k + S - O, D + A), X.lineTo(k + O, D + A), (O !== 0 || z !== 0) && X.bezierCurveTo(k + O * L, D + A, k, D + A - z * L, k, D + A - z), X.lineTo(k, D + z), (O !== 0 || z !== 0) && X.bezierCurveTo(k, D + z * L, k + O * L, D, k + O, D), X;
    }
    function c(I) {
      function k(S, A, L) {
        const X = v(A), H = v(L);
        z === 0 ? O.moveTo(X, H) : O.lineTo(X, H), z++;
      }
      const D = /([+-]?\d*\.?\d+(?:e[+-]?\d+)?)(?:,|\s)([+-]?\d*\.?\d+(?:e[+-]?\d+)?)/g, O = new gn();
      let z = 0;
      return I.getAttribute("points").replace(D, k), O.currentPath.autoClose = !0, O;
    }
    function h(I) {
      function k(S, A, L) {
        const X = v(A), H = v(L);
        z === 0 ? O.moveTo(X, H) : O.lineTo(X, H), z++;
      }
      const D = /([+-]?\d*\.?\d+(?:e[+-]?\d+)?)(?:,|\s)([+-]?\d*\.?\d+(?:e[+-]?\d+)?)/g, O = new gn();
      let z = 0;
      return I.getAttribute("points").replace(D, k), O.currentPath.autoClose = !1, O;
    }
    function u(I) {
      const k = v(I.getAttribute("cx") || 0), D = v(I.getAttribute("cy") || 0), O = v(I.getAttribute("r") || 0), z = new Ti();
      z.absarc(k, D, O, 0, Math.PI * 2);
      const S = new gn();
      return S.subPaths.push(z), S;
    }
    function p(I) {
      const k = v(I.getAttribute("cx") || 0), D = v(I.getAttribute("cy") || 0), O = v(I.getAttribute("rx") || 0), z = v(I.getAttribute("ry") || 0), S = new Ti();
      S.absellipse(k, D, O, z, 0, Math.PI * 2);
      const A = new gn();
      return A.subPaths.push(S), A;
    }
    function f(I) {
      const k = v(I.getAttribute("x1") || 0), D = v(I.getAttribute("y1") || 0), O = v(I.getAttribute("x2") || 0), z = v(I.getAttribute("y2") || 0), S = new gn();
      return S.moveTo(k, D), S.lineTo(O, z), S.currentPath.autoClose = !1, S;
    }
    function g(I, k) {
      k = Object.assign({}, k);
      let D = {};
      if (I.hasAttribute("class")) {
        const A = I.getAttribute("class").split(/\s/).filter(Boolean).map((L) => L.trim());
        for (let L = 0; L < A.length; L++)
          D = Object.assign(D, B["." + A[L]]);
      }
      I.hasAttribute("id") && (D = Object.assign(D, B["#" + I.getAttribute("id")]));
      function O(A, L, X) {
        X === void 0 && (X = function(G) {
          return G.startsWith("url") && console.warn("SVGLoader: url access in attributes is not implemented."), G;
        }), I.hasAttribute(A) && (k[L] = X(I.getAttribute(A))), D[A] && (k[L] = X(D[A])), I.style && I.style[A] !== "" && (k[L] = X(I.style[A]));
      }
      function z(A) {
        return Math.max(0, Math.min(1, v(A)));
      }
      function S(A) {
        return Math.max(0, v(A));
      }
      return O("fill", "fill"), O("fill-opacity", "fillOpacity", z), O("fill-rule", "fillRule"), O("opacity", "opacity", z), O("stroke", "stroke"), O("stroke-opacity", "strokeOpacity", z), O("stroke-width", "strokeWidth", S), O("stroke-linejoin", "strokeLineJoin"), O("stroke-linecap", "strokeLineCap"), O("stroke-miterlimit", "strokeMiterLimit", S), O("visibility", "visibility"), k;
    }
    function m(I, k) {
      return I - (k - I);
    }
    function y(I, k, D) {
      if (typeof I != "string")
        throw new TypeError("Invalid input: " + typeof I);
      const O = {
        SEPARATOR: /[ \t\r\n\,.\-+]/,
        WHITESPACE: /[ \t\r\n]/,
        DIGIT: /[\d]/,
        SIGN: /[-+]/,
        POINT: /\./,
        COMMA: /,/,
        EXP: /e/i,
        FLAGS: /[01]/
      }, z = 0, S = 1, A = 2, L = 3;
      let X = z, H = !0, G = "", q = "";
      const se = [];
      function ie(pe, Ae, Ve) {
        const We = new SyntaxError('Unexpected character "' + pe + '" at index ' + Ae + ".");
        throw We.partial = Ve, We;
      }
      function Y() {
        G !== "" && (q === "" ? se.push(Number(G)) : se.push(Number(G) * Math.pow(10, Number(q)))), G = "", q = "";
      }
      let F;
      const oe = I.length;
      for (let pe = 0; pe < oe; pe++) {
        if (F = I[pe], Array.isArray(k) && k.includes(se.length % D) && O.FLAGS.test(F)) {
          X = S, G = F, Y();
          continue;
        }
        if (X === z) {
          if (O.WHITESPACE.test(F))
            continue;
          if (O.DIGIT.test(F) || O.SIGN.test(F)) {
            X = S, G = F;
            continue;
          }
          if (O.POINT.test(F)) {
            X = A, G = F;
            continue;
          }
          O.COMMA.test(F) && (H && ie(F, pe, se), H = !0);
        }
        if (X === S) {
          if (O.DIGIT.test(F)) {
            G += F;
            continue;
          }
          if (O.POINT.test(F)) {
            G += F, X = A;
            continue;
          }
          if (O.EXP.test(F)) {
            X = L;
            continue;
          }
          O.SIGN.test(F) && G.length === 1 && O.SIGN.test(G[0]) && ie(F, pe, se);
        }
        if (X === A) {
          if (O.DIGIT.test(F)) {
            G += F;
            continue;
          }
          if (O.EXP.test(F)) {
            X = L;
            continue;
          }
          O.POINT.test(F) && G[G.length - 1] === "." && ie(F, pe, se);
        }
        if (X === L) {
          if (O.DIGIT.test(F)) {
            q += F;
            continue;
          }
          if (O.SIGN.test(F)) {
            if (q === "") {
              q += F;
              continue;
            }
            q.length === 1 && O.SIGN.test(q) && ie(F, pe, se);
          }
        }
        O.WHITESPACE.test(F) ? (Y(), X = z, H = !1) : O.COMMA.test(F) ? (Y(), X = z, H = !0) : O.SIGN.test(F) ? (Y(), X = S, G = F) : O.POINT.test(F) ? (Y(), X = A, G = F) : ie(F, pe, se);
      }
      return Y(), se;
    }
    const d = ["mm", "cm", "in", "pt", "pc", "px"], w = {
      mm: {
        mm: 1,
        cm: 0.1,
        in: 1 / 25.4,
        pt: 72 / 25.4,
        pc: 6 / 25.4,
        px: -1
      },
      cm: {
        mm: 10,
        cm: 1,
        in: 1 / 2.54,
        pt: 72 / 2.54,
        pc: 6 / 2.54,
        px: -1
      },
      in: {
        mm: 25.4,
        cm: 2.54,
        in: 1,
        pt: 72,
        pc: 6,
        px: -1
      },
      pt: {
        mm: 25.4 / 72,
        cm: 2.54 / 72,
        in: 1 / 72,
        pt: 1,
        pc: 6 / 72,
        px: -1
      },
      pc: {
        mm: 25.4 / 6,
        cm: 2.54 / 6,
        in: 1 / 6,
        pt: 72 / 6,
        pc: 1,
        px: -1
      },
      px: {
        px: 1
      }
    };
    function v(I) {
      let k = "px";
      if (typeof I == "string" || I instanceof String)
        for (let O = 0, z = d.length; O < z; O++) {
          const S = d[O];
          if (I.endsWith(S)) {
            k = S, I = I.substring(0, I.length - S.length);
            break;
          }
        }
      let D;
      return k === "px" && t.defaultUnit !== "px" ? D = w.in[t.defaultUnit] / t.defaultDPI : (D = w[k][t.defaultUnit], D < 0 && (D = w[k].in * t.defaultDPI)), D * parseFloat(I);
    }
    function E(I) {
      if (!(I.hasAttribute("transform") || I.nodeName === "use" && (I.hasAttribute("x") || I.hasAttribute("y"))))
        return null;
      const k = P(I);
      return N.length > 0 && k.premultiply(N[N.length - 1]), le.copy(k), N.push(k), k;
    }
    function P(I) {
      const k = new Ln(), D = j;
      if (I.nodeName === "use" && (I.hasAttribute("x") || I.hasAttribute("y"))) {
        const O = v(I.getAttribute("x")), z = v(I.getAttribute("y"));
        k.translate(O, z);
      }
      if (I.hasAttribute("transform")) {
        const O = I.getAttribute("transform").split(")");
        for (let z = O.length - 1; z >= 0; z--) {
          const S = O[z].trim();
          if (S === "")
            continue;
          const A = S.indexOf("("), L = S.length;
          if (A > 0 && A < L) {
            const X = S.slice(0, A), H = y(S.slice(A + 1));
            switch (D.identity(), X) {
              case "translate":
                if (H.length >= 1) {
                  const G = H[0];
                  let q = 0;
                  H.length >= 2 && (q = H[1]), D.translate(G, q);
                }
                break;
              case "rotate":
                if (H.length >= 1) {
                  let G = 0, q = 0, se = 0;
                  G = H[0] * Math.PI / 180, H.length >= 3 && (q = H[1], se = H[2]), V.makeTranslation(-q, -se), Q.makeRotation(G), Z.multiplyMatrices(Q, V), V.makeTranslation(q, se), D.multiplyMatrices(V, Z);
                }
                break;
              case "scale":
                if (H.length >= 1) {
                  const G = H[0];
                  let q = G;
                  H.length >= 2 && (q = H[1]), D.scale(G, q);
                }
                break;
              case "skewX":
                H.length === 1 && D.set(1, Math.tan(H[0] * Math.PI / 180), 0, 0, 1, 0, 0, 0, 1);
                break;
              case "skewY":
                H.length === 1 && D.set(1, 0, 0, Math.tan(H[0] * Math.PI / 180), 1, 0, 0, 0, 1);
                break;
              case "matrix":
                H.length === 6 && D.set(H[0], H[2], H[4], H[1], H[3], H[5], 0, 0, 1);
                break;
            }
          }
          k.premultiply(D);
        }
      }
      return k;
    }
    function T(I, k) {
      function D(A) {
        te.set(A.x, A.y, 1).applyMatrix3(k), A.set(te.x, te.y);
      }
      function O(A) {
        const L = A.xRadius, X = A.yRadius, H = Math.cos(A.aRotation), G = Math.sin(A.aRotation), q = new $(L * H, L * G, 0), se = new $(-X * G, X * H, 0), ie = q.applyMatrix3(k), Y = se.applyMatrix3(k), F = j.set(ie.x, Y.x, 0, ie.y, Y.y, 0, 0, 0, 1), oe = V.copy(F).invert(), Ve = Q.copy(oe).transpose().multiply(oe).elements, We = C(Ve[0], Ve[1], Ve[4]), xt = Math.sqrt(We.rt1), Xt = Math.sqrt(We.rt2);
        if (A.xRadius = 1 / xt, A.yRadius = 1 / Xt, A.aRotation = Math.atan2(We.sn, We.cs), !((A.aEndAngle - A.aStartAngle) % (2 * Math.PI) < Number.EPSILON)) {
          const cn = V.set(xt, 0, 0, 0, Xt, 0, 0, 0, 1), gt = Q.set(We.cs, We.sn, 0, -We.sn, We.cs, 0, 0, 0, 1), wt = cn.multiply(gt).multiply(F), Ds = (Ls) => {
            const { x: Fs, y: ss } = new $(Math.cos(Ls), Math.sin(Ls), 0).applyMatrix3(wt);
            return Math.atan2(ss, Fs);
          };
          A.aStartAngle = Ds(A.aStartAngle), A.aEndAngle = Ds(A.aEndAngle), b(k) && (A.aClockwise = !A.aClockwise);
        }
      }
      function z(A) {
        const L = M(k), X = _(k);
        A.xRadius *= L, A.yRadius *= X;
        const H = L > Number.EPSILON ? Math.atan2(k.elements[1], k.elements[0]) : Math.atan2(-k.elements[3], k.elements[4]);
        A.aRotation += H, b(k) && (A.aStartAngle *= -1, A.aEndAngle *= -1, A.aClockwise = !A.aClockwise);
      }
      const S = I.subPaths;
      for (let A = 0, L = S.length; A < L; A++) {
        const H = S[A].curves;
        for (let G = 0; G < H.length; G++) {
          const q = H[G];
          q.isLineCurve ? (D(q.v1), D(q.v2)) : q.isCubicBezierCurve ? (D(q.v0), D(q.v1), D(q.v2), D(q.v3)) : q.isQuadraticBezierCurve ? (D(q.v0), D(q.v1), D(q.v2)) : q.isEllipseCurve && (ne.set(q.aX, q.aY), D(ne), q.aX = ne.x, q.aY = ne.y, x(k) ? O(q) : z(q));
        }
      }
    }
    function b(I) {
      const k = I.elements;
      return k[0] * k[4] - k[1] * k[3] < 0;
    }
    function x(I) {
      const k = I.elements, D = k[0] * k[3] + k[1] * k[4];
      if (D === 0)
        return !1;
      const O = M(I), z = _(I);
      return Math.abs(D / (O * z)) > Number.EPSILON;
    }
    function M(I) {
      const k = I.elements;
      return Math.sqrt(k[0] * k[0] + k[1] * k[1]);
    }
    function _(I) {
      const k = I.elements;
      return Math.sqrt(k[3] * k[3] + k[4] * k[4]);
    }
    function C(I, k, D) {
      let O, z, S, A, L;
      const X = I + D, H = I - D, G = Math.sqrt(H * H + 4 * k * k);
      return X > 0 ? (O = 0.5 * (X + G), L = 1 / O, z = I * L * D - k * L * k) : X < 0 ? z = 0.5 * (X - G) : (O = 0.5 * G, z = -0.5 * G), H > 0 ? S = H + G : S = H - G, Math.abs(S) > 2 * Math.abs(k) ? (L = -2 * k / S, A = 1 / Math.sqrt(1 + L * L), S = L * A) : Math.abs(k) === 0 ? (S = 1, A = 0) : (L = -0.5 * S / k, S = 1 / Math.sqrt(1 + L * L), A = L * S), H > 0 && (L = S, S = -A, A = L), { rt1: O, rt2: z, cs: S, sn: A };
    }
    const R = [], B = {}, N = [], j = new Ln(), V = new Ln(), Q = new Ln(), Z = new Ln(), ne = new ge(), te = new $(), le = new Ln(), ae = new DOMParser().parseFromString(e, "image/svg+xml");
    return n(ae.documentElement, {
      fill: "#000",
      fillOpacity: 1,
      strokeOpacity: 1,
      strokeWidth: 1,
      strokeLineJoin: "miter",
      strokeLineCap: "butt",
      strokeMiterLimit: 4
    }), { paths: R, xml: ae.documentElement };
  }
  static createShapes(e) {
    const n = {
      ORIGIN: 0,
      DESTINATION: 1,
      BETWEEN: 2,
      LEFT: 3,
      RIGHT: 4,
      BEHIND: 5,
      BEYOND: 6
    }, s = {
      loc: n.ORIGIN,
      t: 0
    };
    function i(m, y, d, w) {
      const v = m.x, E = y.x, P = d.x, T = w.x, b = m.y, x = y.y, M = d.y, _ = w.y, C = (T - P) * (b - M) - (_ - M) * (v - P), R = (E - v) * (b - M) - (x - b) * (v - P), B = (_ - M) * (E - v) - (T - P) * (x - b), N = C / B, j = R / B;
      if (B === 0 && C !== 0 || N <= 0 || N >= 1 || j < 0 || j > 1)
        return null;
      if (C === 0 && B === 0) {
        for (let V = 0; V < 2; V++)
          if (r(V === 0 ? d : w, m, y), s.loc == n.ORIGIN) {
            const Q = V === 0 ? d : w;
            return { x: Q.x, y: Q.y, t: s.t };
          } else if (s.loc == n.BETWEEN) {
            const Q = +(v + s.t * (E - v)).toPrecision(10), Z = +(b + s.t * (x - b)).toPrecision(10);
            return { x: Q, y: Z, t: s.t };
          }
        return null;
      } else {
        for (let Z = 0; Z < 2; Z++)
          if (r(Z === 0 ? d : w, m, y), s.loc == n.ORIGIN) {
            const ne = Z === 0 ? d : w;
            return { x: ne.x, y: ne.y, t: s.t };
          }
        const V = +(v + N * (E - v)).toPrecision(10), Q = +(b + N * (x - b)).toPrecision(10);
        return { x: V, y: Q, t: N };
      }
    }
    function r(m, y, d) {
      const w = d.x - y.x, v = d.y - y.y, E = m.x - y.x, P = m.y - y.y, T = w * P - E * v;
      if (m.x === y.x && m.y === y.y) {
        s.loc = n.ORIGIN, s.t = 0;
        return;
      }
      if (m.x === d.x && m.y === d.y) {
        s.loc = n.DESTINATION, s.t = 1;
        return;
      }
      if (T < -Number.EPSILON) {
        s.loc = n.LEFT;
        return;
      }
      if (T > Number.EPSILON) {
        s.loc = n.RIGHT;
        return;
      }
      if (w * E < 0 || v * P < 0) {
        s.loc = n.BEHIND;
        return;
      }
      if (Math.sqrt(w * w + v * v) < Math.sqrt(E * E + P * P)) {
        s.loc = n.BEYOND;
        return;
      }
      let b;
      w !== 0 ? b = E / w : b = P / v, s.loc = n.BETWEEN, s.t = b;
    }
    function a(m, y) {
      const d = [], w = [];
      for (let v = 1; v < m.length; v++) {
        const E = m[v - 1], P = m[v];
        for (let T = 1; T < y.length; T++) {
          const b = y[T - 1], x = y[T], M = i(E, P, b, x);
          M !== null && d.find(
            (_) => _.t <= M.t + Number.EPSILON && _.t >= M.t - Number.EPSILON
          ) === void 0 && (d.push(M), w.push(new ge(M.x, M.y)));
        }
      }
      return w;
    }
    function l(m, y, d) {
      const w = new ge();
      y.getCenter(w);
      const v = [];
      return d.forEach((E) => {
        E.boundingBox.containsPoint(w) && a(m, E.points).forEach((T) => {
          v.push({ identifier: E.identifier, isCW: E.isCW, point: T });
        });
      }), v.sort((E, P) => E.point.x - P.point.x), v;
    }
    function c(m, y, d, w, v) {
      (v == null || v === "") && (v = "nonzero");
      const E = new ge();
      m.boundingBox.getCenter(E);
      const P = [new ge(d, E.y), new ge(w, E.y)], T = l(P, m.boundingBox, y);
      T.sort((R, B) => R.point.x - B.point.x);
      const b = [], x = [];
      T.forEach((R) => {
        R.identifier === m.identifier ? b.push(R) : x.push(R);
      });
      const M = b[0].point.x, _ = [];
      let C = 0;
      for (; C < x.length && x[C].point.x < M; )
        _.length > 0 && _[_.length - 1] === x[C].identifier ? _.pop() : _.push(x[C].identifier), C++;
      if (_.push(m.identifier), v === "evenodd") {
        const R = _.length % 2 === 0, B = _[_.length - 2];
        return { identifier: m.identifier, isHole: R, for: B };
      } else if (v === "nonzero") {
        let R = !0, B = null, N = null;
        for (let j = 0; j < _.length; j++) {
          const V = _[j];
          R ? (N = y[V].isCW, R = !1, B = V) : N !== y[V].isCW && (N = y[V].isCW, R = !0);
        }
        return { identifier: m.identifier, isHole: R, for: B };
      } else
        console.warn('fill-rule: "' + v + '" is currently not implemented.');
    }
    let h = 999999999, u = -999999999, p = e.subPaths.map((m) => {
      const y = m.getPoints();
      let d = -999999999, w = 999999999, v = -999999999, E = 999999999;
      for (let P = 0; P < y.length; P++) {
        const T = y[P];
        T.y > d && (d = T.y), T.y < w && (w = T.y), T.x > v && (v = T.x), T.x < E && (E = T.x);
      }
      return u <= v && (u = v + 1), h >= E && (h = E - 1), {
        curves: m.curves,
        points: y,
        isCW: Nl.isClockWise(y),
        identifier: -1,
        boundingBox: new ra(new ge(E, w), new ge(v, d))
      };
    });
    p = p.filter((m) => m.points.length > 1);
    for (let m = 0; m < p.length; m++)
      p[m].identifier = m;
    const f = p.map(
      (m) => c(
        m,
        p,
        h,
        u,
        e.userData ? e.userData.style.fillRule : void 0
      )
    ), g = [];
    return p.forEach((m) => {
      if (!f[m.identifier].isHole) {
        const d = new Ul();
        d.curves = m.curves, f.filter((v) => v.isHole && v.for === m.identifier).forEach((v) => {
          const E = p[v.identifier], P = new Ti();
          P.curves = E.curves, d.holes.push(P);
        }), g.push(d);
      }
    }), g;
  }
  static getStrokeStyle(e, t, n, s, i) {
    return e = e !== void 0 ? e : 1, t = t !== void 0 ? t : "#000", n = n !== void 0 ? n : "miter", s = s !== void 0 ? s : "butt", i = i !== void 0 ? i : 4, {
      strokeColor: t,
      strokeWidth: e,
      strokeLineJoin: n,
      strokeLineCap: s,
      strokeMiterLimit: i
    };
  }
  static pointsToStroke(e, t, n, s) {
    const i = [], r = [], a = [];
    if (xs.pointsToStrokeWithBuffers(e, t, n, s, i, r, a) === 0)
      return null;
    const l = new pt();
    return l.setAttribute("position", new dt(i, 3)), l.setAttribute("normal", new dt(r, 3)), l.setAttribute("uv", new dt(a, 2)), l;
  }
  static pointsToStrokeWithBuffers(e, t, n, s, i, r, a, l) {
    const c = new ge(), h = new ge(), u = new ge(), p = new ge(), f = new ge(), g = new ge(), m = new ge(), y = new ge(), d = new ge(), w = new ge(), v = new ge(), E = new ge(), P = new ge(), T = new ge(), b = new ge(), x = new ge(), M = new ge();
    n = n !== void 0 ? n : 12, s = s !== void 0 ? s : 1e-3, l = l !== void 0 ? l : 0, e = H(e);
    const _ = e.length;
    if (_ < 2)
      return 0;
    const C = e[0].equals(e[_ - 1]);
    let R, B = e[0], N;
    const j = t.strokeWidth / 2, V = 1 / (_ - 1);
    let Q = 0, Z, ne, te, le, ae = !1, Te = 0, I = l * 3, k = l * 2;
    D(e[0], e[1], c).multiplyScalar(j), y.copy(e[0]).sub(c), d.copy(e[0]).add(c), w.copy(y), v.copy(d);
    for (let G = 1; G < _; G++) {
      R = e[G], G === _ - 1 ? C ? N = e[1] : N = void 0 : N = e[G + 1];
      const q = c;
      if (D(B, R, q), u.copy(q).multiplyScalar(j), E.copy(R).sub(u), P.copy(R).add(u), Z = Q + V, ne = !1, N !== void 0) {
        D(R, N, h), u.copy(h).multiplyScalar(j), T.copy(R).sub(u), b.copy(R).add(u), te = !0, u.subVectors(N, B), q.dot(u) < 0 && (te = !1), G === 1 && (ae = te), u.subVectors(N, R), u.normalize();
        const se = Math.abs(q.dot(u));
        if (se > Number.EPSILON) {
          const ie = j / se;
          u.multiplyScalar(-ie), p.subVectors(R, B), f.copy(p).setLength(ie).add(u), x.copy(f).negate();
          const Y = f.length(), F = p.length();
          p.divideScalar(F), g.subVectors(N, R);
          const oe = g.length();
          switch (g.divideScalar(oe), p.dot(x) < F && g.dot(x) < oe && (ne = !0), M.copy(f).add(R), x.add(R), le = !1, ne ? te ? (b.copy(x), P.copy(x)) : (T.copy(x), E.copy(x)) : S(), t.strokeLineJoin) {
            case "bevel":
              A(te, ne, Z);
              break;
            case "round":
              L(te, ne), te ? z(R, E, T, Z, 0) : z(R, b, P, Z, 1);
              break;
            case "miter":
            case "miter-clip":
            default:
              const pe = j * t.strokeMiterLimit / Y;
              if (pe < 1)
                if (t.strokeLineJoin !== "miter-clip") {
                  A(te, ne, Z);
                  break;
                } else
                  L(te, ne), te ? (g.subVectors(M, E).multiplyScalar(pe).add(E), m.subVectors(M, T).multiplyScalar(pe).add(T), O(E, Z, 0), O(g, Z, 0), O(R, Z, 0.5), O(R, Z, 0.5), O(g, Z, 0), O(m, Z, 0), O(R, Z, 0.5), O(m, Z, 0), O(T, Z, 0)) : (g.subVectors(M, P).multiplyScalar(pe).add(P), m.subVectors(M, b).multiplyScalar(pe).add(b), O(P, Z, 1), O(g, Z, 1), O(R, Z, 0.5), O(R, Z, 0.5), O(g, Z, 1), O(m, Z, 1), O(R, Z, 0.5), O(m, Z, 1), O(b, Z, 1));
              else
                ne ? (te ? (O(d, Q, 1), O(y, Q, 0), O(M, Z, 0), O(d, Q, 1), O(M, Z, 0), O(x, Z, 1)) : (O(d, Q, 1), O(y, Q, 0), O(M, Z, 1), O(y, Q, 0), O(x, Z, 0), O(M, Z, 1)), te ? T.copy(M) : b.copy(M)) : te ? (O(E, Z, 0), O(M, Z, 0), O(R, Z, 0.5), O(R, Z, 0.5), O(M, Z, 0), O(T, Z, 0)) : (O(P, Z, 1), O(M, Z, 1), O(R, Z, 0.5), O(R, Z, 0.5), O(M, Z, 1), O(b, Z, 1)), le = !0;
              break;
          }
        } else
          S();
      } else
        S();
      !C && G === _ - 1 && X(e[0], w, v, te, !0, Q), Q = Z, B = R, y.copy(T), d.copy(b);
    }
    if (!C)
      X(R, E, P, te, !1, Z);
    else if (ne && i) {
      let G = M, q = x;
      ae !== te && (G = x, q = M), te ? (le || ae) && (q.toArray(i, 0 * 3), q.toArray(i, 3 * 3), le && G.toArray(i, 1 * 3)) : (le || !ae) && (q.toArray(i, 1 * 3), q.toArray(i, 3 * 3), le && G.toArray(i, 0 * 3));
    }
    return Te;
    function D(G, q, se) {
      return se.subVectors(q, G), se.set(-se.y, se.x).normalize();
    }
    function O(G, q, se) {
      i && (i[I] = G.x, i[I + 1] = G.y, i[I + 2] = 0, r && (r[I] = 0, r[I + 1] = 0, r[I + 2] = 1), I += 3, a && (a[k] = q, a[k + 1] = se, k += 2)), Te += 3;
    }
    function z(G, q, se, ie, Y) {
      c.copy(q).sub(G).normalize(), h.copy(se).sub(G).normalize();
      let F = Math.PI;
      const oe = c.dot(h);
      Math.abs(oe) < 1 && (F = Math.abs(Math.acos(oe))), F /= n, u.copy(q);
      for (let pe = 0, Ae = n - 1; pe < Ae; pe++)
        p.copy(u).rotateAround(G, F), O(u, ie, Y), O(p, ie, Y), O(G, ie, 0.5), u.copy(p);
      O(p, ie, Y), O(se, ie, Y), O(G, ie, 0.5);
    }
    function S() {
      O(d, Q, 1), O(y, Q, 0), O(E, Z, 0), O(d, Q, 1), O(E, Z, 0), O(P, Z, 1);
    }
    function A(G, q, se) {
      q ? G ? (O(d, Q, 1), O(y, Q, 0), O(E, Z, 0), O(d, Q, 1), O(E, Z, 0), O(x, Z, 1), O(E, se, 0), O(T, se, 0), O(x, se, 0.5)) : (O(d, Q, 1), O(y, Q, 0), O(P, Z, 1), O(y, Q, 0), O(x, Z, 0), O(P, Z, 1), O(P, se, 1), O(x, se, 0), O(b, se, 1)) : G ? (O(E, se, 0), O(T, se, 0), O(R, se, 0.5)) : (O(P, se, 1), O(b, se, 0), O(R, se, 0.5));
    }
    function L(G, q) {
      q && (G ? (O(d, Q, 1), O(y, Q, 0), O(E, Z, 0), O(d, Q, 1), O(E, Z, 0), O(x, Z, 1), O(E, Q, 0), O(R, Z, 0.5), O(x, Z, 1), O(R, Z, 0.5), O(T, Q, 0), O(x, Z, 1)) : (O(d, Q, 1), O(y, Q, 0), O(P, Z, 1), O(y, Q, 0), O(x, Z, 0), O(P, Z, 1), O(P, Q, 1), O(x, Z, 0), O(R, Z, 0.5), O(R, Z, 0.5), O(x, Z, 0), O(b, Q, 1)));
    }
    function X(G, q, se, ie, Y, F) {
      switch (t.strokeLineCap) {
        case "round":
          Y ? z(G, se, q, F, 0.5) : z(G, q, se, F, 0.5);
          break;
        case "square":
          if (Y)
            c.subVectors(q, G), h.set(c.y, -c.x), u.addVectors(c, h).add(G), p.subVectors(h, c).add(G), ie ? (u.toArray(i, 1 * 3), p.toArray(i, 0 * 3), p.toArray(i, 3 * 3)) : (u.toArray(i, 1 * 3), a[3 * 2 + 1] === 1 ? p.toArray(i, 3 * 3) : u.toArray(i, 3 * 3), p.toArray(i, 0 * 3));
          else {
            c.subVectors(se, G), h.set(c.y, -c.x), u.addVectors(c, h).add(G), p.subVectors(h, c).add(G);
            const oe = i.length;
            ie ? (u.toArray(i, oe - 1 * 3), p.toArray(i, oe - 2 * 3), p.toArray(i, oe - 4 * 3)) : (p.toArray(i, oe - 2 * 3), u.toArray(i, oe - 1 * 3), p.toArray(i, oe - 4 * 3));
          }
          break;
      }
    }
    function H(G) {
      let q = !1;
      for (let ie = 1, Y = G.length - 1; ie < Y; ie++)
        if (G[ie].distanceTo(G[ie + 1]) < s) {
          q = !0;
          break;
        }
      if (!q)
        return G;
      const se = [];
      se.push(G[0]);
      for (let ie = 1, Y = G.length - 1; ie < Y; ie++)
        G[ie].distanceTo(G[ie + 1]) >= s && se.push(G[ie]);
      return se.push(G[G.length - 1]), se;
    }
  }
}
const Oi = /* @__PURE__ */ new WeakMap();
class rf extends As {
  constructor(e) {
    super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
      position: "POSITION",
      normal: "NORMAL",
      color: "COLOR",
      uv: "TEX_COORD"
    }, this.defaultAttributeTypes = {
      position: "Float32Array",
      normal: "Float32Array",
      color: "Float32Array",
      uv: "Float32Array"
    };
  }
  setDecoderPath(e) {
    return this.decoderPath = e, this;
  }
  setDecoderConfig(e) {
    return this.decoderConfig = e, this;
  }
  setWorkerLimit(e) {
    return this.workerLimit = e, this;
  }
  load(e, t, n, s) {
    const i = new Bn(this.manager);
    i.setPath(this.path), i.setResponseType("arraybuffer"), i.setRequestHeader(this.requestHeader), i.setWithCredentials(this.withCredentials), i.load(
      e,
      (r) => {
        const a = {
          attributeIDs: this.defaultAttributeIDs,
          attributeTypes: this.defaultAttributeTypes,
          useUniqueIDs: !1
        };
        this.decodeGeometry(r, a).then(t).catch(s);
      },
      n,
      s
    );
  }
  /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */
  decodeDracoFile(e, t, n, s) {
    const i = {
      attributeIDs: n || this.defaultAttributeIDs,
      attributeTypes: s || this.defaultAttributeTypes,
      useUniqueIDs: !!n
    };
    this.decodeGeometry(e, i).then(t);
  }
  decodeGeometry(e, t) {
    for (const l in t.attributeTypes) {
      const c = t.attributeTypes[l];
      c.BYTES_PER_ELEMENT !== void 0 && (t.attributeTypes[l] = c.name);
    }
    const n = JSON.stringify(t);
    if (Oi.has(e)) {
      const l = Oi.get(e);
      if (l.key === n)
        return l.promise;
      if (e.byteLength === 0)
        throw new Error(
          "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
        );
    }
    let s;
    const i = this.workerNextTaskID++, r = e.byteLength, a = this._getWorker(i, r).then((l) => (s = l, new Promise((c, h) => {
      s._callbacks[i] = { resolve: c, reject: h }, s.postMessage({ type: "decode", id: i, taskConfig: t, buffer: e }, [e]);
    }))).then((l) => this._createGeometry(l.geometry));
    return a.catch(() => !0).then(() => {
      s && i && this._releaseTask(s, i);
    }), Oi.set(e, {
      key: n,
      promise: a
    }), a;
  }
  _createGeometry(e) {
    const t = new pt();
    e.index && t.setIndex(new mt(e.index.array, 1));
    for (let n = 0; n < e.attributes.length; n++) {
      const s = e.attributes[n], i = s.name, r = s.array, a = s.itemSize;
      t.setAttribute(i, new mt(r, a));
    }
    return t;
  }
  _loadLibrary(e, t) {
    const n = new Bn(this.manager);
    return n.setPath(this.decoderPath), n.setResponseType(t), n.setWithCredentials(this.withCredentials), new Promise((s, i) => {
      n.load(e, s, void 0, i);
    });
  }
  preload() {
    return this._initDecoder(), this;
  }
  _initDecoder() {
    if (this.decoderPending)
      return this.decoderPending;
    const e = typeof WebAssembly != "object" || this.decoderConfig.type === "js", t = [];
    return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then((n) => {
      const s = n[0];
      e || (this.decoderConfig.wasmBinary = n[1]);
      const i = of.toString(), r = [
        "/* draco decoder */",
        s,
        "",
        "/* worker */",
        i.substring(i.indexOf("{") + 1, i.lastIndexOf("}"))
      ].join(`
`);
      this.workerSourceURL = URL.createObjectURL(new Blob([r]));
    }), this.decoderPending;
  }
  _getWorker(e, t) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const s = new Worker(this.workerSourceURL);
        s._callbacks = {}, s._taskCosts = {}, s._taskLoad = 0, s.postMessage({ type: "init", decoderConfig: this.decoderConfig }), s.onmessage = function(i) {
          const r = i.data;
          switch (r.type) {
            case "decode":
              s._callbacks[r.id].resolve(r);
              break;
            case "error":
              s._callbacks[r.id].reject(r);
              break;
            default:
              console.error('THREE.DRACOLoader: Unexpected message, "' + r.type + '"');
          }
        }, this.workerPool.push(s);
      } else
        this.workerPool.sort(function(s, i) {
          return s._taskLoad > i._taskLoad ? -1 : 1;
        });
      const n = this.workerPool[this.workerPool.length - 1];
      return n._taskCosts[e] = t, n._taskLoad += t, n;
    });
  }
  _releaseTask(e, t) {
    e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t];
  }
  debug() {
    console.log(
      "Task load: ",
      this.workerPool.map((e) => e._taskLoad)
    );
  }
  dispose() {
    for (let e = 0; e < this.workerPool.length; ++e)
      this.workerPool[e].terminate();
    return this.workerPool.length = 0, this;
  }
}
function of() {
  let o, e;
  onmessage = function(r) {
    const a = r.data;
    switch (a.type) {
      case "init":
        o = a.decoderConfig, e = new Promise(function(h) {
          o.onModuleLoaded = function(u) {
            h({ draco: u });
          }, DracoDecoderModule(o);
        });
        break;
      case "decode":
        const l = a.buffer, c = a.taskConfig;
        e.then((h) => {
          const u = h.draco, p = new u.Decoder(), f = new u.DecoderBuffer();
          f.Init(new Int8Array(l), l.byteLength);
          try {
            const g = t(u, p, f, c), m = g.attributes.map((y) => y.array.buffer);
            g.index && m.push(g.index.array.buffer), self.postMessage({ type: "decode", id: a.id, geometry: g }, m);
          } catch (g) {
            console.error(g), self.postMessage({ type: "error", id: a.id, error: g.message });
          } finally {
            u.destroy(f), u.destroy(p);
          }
        });
        break;
    }
  };
  function t(r, a, l, c) {
    const h = c.attributeIDs, u = c.attributeTypes;
    let p, f;
    const g = a.GetEncodedGeometryType(l);
    if (g === r.TRIANGULAR_MESH)
      p = new r.Mesh(), f = a.DecodeBufferToMesh(l, p);
    else if (g === r.POINT_CLOUD)
      p = new r.PointCloud(), f = a.DecodeBufferToPointCloud(l, p);
    else
      throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
    if (!f.ok() || p.ptr === 0)
      throw new Error("THREE.DRACOLoader: Decoding failed: " + f.error_msg());
    const m = { index: null, attributes: [] };
    for (const y in h) {
      const d = self[u[y]];
      let w, v;
      if (c.useUniqueIDs)
        v = h[y], w = a.GetAttributeByUniqueId(p, v);
      else {
        if (v = a.GetAttributeId(p, r[h[y]]), v === -1)
          continue;
        w = a.GetAttribute(p, v);
      }
      m.attributes.push(s(r, a, p, y, d, w));
    }
    return g === r.TRIANGULAR_MESH && (m.index = n(r, a, p)), r.destroy(p), m;
  }
  function n(r, a, l) {
    const h = l.num_faces() * 3, u = h * 4, p = r._malloc(u);
    a.GetTrianglesUInt32Array(l, u, p);
    const f = new Uint32Array(r.HEAPF32.buffer, p, h).slice();
    return r._free(p), { array: f, itemSize: 1 };
  }
  function s(r, a, l, c, h, u) {
    const p = u.num_components(), g = l.num_points() * p, m = g * h.BYTES_PER_ELEMENT, y = i(r, h), d = r._malloc(m);
    a.GetAttributeDataArrayForAllPoints(l, u, y, m, d);
    const w = new h(r.HEAPF32.buffer, d, g).slice();
    return r._free(d), {
      name: c,
      array: w,
      itemSize: p
    };
  }
  function i(r, a) {
    switch (a) {
      case Float32Array:
        return r.DT_FLOAT32;
      case Int8Array:
        return r.DT_INT8;
      case Int16Array:
        return r.DT_INT16;
      case Int32Array:
        return r.DT_INT32;
      case Uint8Array:
        return r.DT_UINT8;
      case Uint16Array:
        return r.DT_UINT16;
      case Uint32Array:
        return r.DT_UINT32;
    }
  }
}
const af = ["args", "material-uniforms-color-value"], Ig = /* @__PURE__ */ me({
  __name: "Reflector",
  props: {
    color: { default: "#333" },
    textureWidth: { default: 512 },
    textureHeight: { default: 512 },
    clipBias: { default: 0 },
    multisample: { default: 4 },
    shader: { default: pr.ReflectorShader }
  },
  setup(o, { expose: e }) {
    const t = o, { extend: n, invalidate: s } = ve(), i = ye();
    n({ Reflector: pr });
    const { color: r, textureWidth: a, textureHeight: l, clipBias: c, multisample: h, shader: u } = De(t);
    return ee(t, () => s()), e({
      instance: i
    }), (p, f) => (ue(), de("TresReflector", {
      ref_key: "reflectorRef",
      ref: i,
      args: [void 0, { textureWidth: U(a), textureHeight: U(l), clipBias: U(c), multisample: U(h), shader: U(u) }],
      "material-uniforms-color-value": U(r)
    }, [
      je(p.$slots, "default", {}, () => [
        f[0] || (f[0] = _e("TresPlaneGeometry", { args: [5, 5] }, null, -1))
      ])
    ], 8, af));
  }
}), lf = ["args", "center"], Og = /* @__PURE__ */ me({
  __name: "Text3D",
  props: {
    font: {},
    text: {},
    size: { default: 0.5 },
    height: { default: 0.2 },
    curveSegments: { default: 5 },
    bevelEnabled: { type: Boolean, default: !0 },
    bevelThickness: { default: 0.05 },
    bevelSize: { default: 0.02 },
    bevelOffset: { default: 0 },
    bevelSegments: { default: 4 },
    center: { type: Boolean, default: !1 },
    needUpdates: { type: Boolean, default: !1 }
  },
  async setup(o, { expose: e }) {
    let t, n;
    const s = o, {
      center: i,
      font: r,
      text: a,
      needUpdates: l,
      size: c,
      height: h,
      curveSegments: u,
      bevelEnabled: p,
      bevelThickness: f,
      bevelSize: g,
      bevelOffset: m,
      bevelSegments: y
    } = De(s), { extend: d, invalidate: w } = ve();
    ee(s, () => w()), d({ TextGeometry: fo });
    const v = new ef(), E = Ar(), P = Fe(() => {
      var M;
      return a != null && a.value ? a.value : E.default ? (M = E.default()[0].children) == null ? void 0 : M.trim() : l.value ? "" : "TresJS";
    }), T = ye();
    e({
      instance: T
    });
    const b = ([t, n] = Pn(() => new Promise((M, _) => {
      try {
        typeof r.value == "string" ? v.load(r.value, (C) => {
          M(C);
        }) : M(r.value);
      } catch (C) {
        _(console.error("cientos", C));
      }
    })), t = await t, n(), t), x = Fe(() => ({
      font: b,
      size: hn(c),
      height: hn(h),
      curveSegments: hn(u),
      bevelEnabled: hn(p),
      bevelThickness: hn(f),
      bevelSize: hn(g),
      bevelOffset: hn(m),
      bevelSegments: hn(y)
    }));
    return Ft(() => {
      T.value && l.value && (T.value.geometry.dispose(), T.value.geometry = new fo(P.value, x.value), i.value && T.value.geometry.center());
    }), (M, _) => U(r) ? (ue(), de("TresMesh", {
      key: 0,
      ref_key: "text3DRef",
      ref: T
    }, [
      P.value ? (ue(), de("TresTextGeometry", {
        key: 0,
        args: [P.value, x.value],
        center: U(i)
      }, null, 8, lf)) : rn("", !0),
      je(M.$slots, "default")
    ], 512)) : rn("", !0);
  }
});
function Dg(o, e) {
  const t = fe(e), n = new zl(t.value), s = Ma({});
  o.forEach((r) => {
    const a = n.clipAction(r, t.value);
    s[r.name] = a;
  });
  const { onBeforeRender: i } = Ke();
  return i(({ delta: r }) => {
    n.update(r);
  }), {
    actions: s,
    mixer: n
  };
}
function cf(o) {
  const e = fe(null), { height: t, width: n, settings: s, depth: i, autoRender: r = fe(!0) } = pc(o) ? De(o) : De(Es(o)), { onBeforeRender: a } = Ke(), { camera: l, renderer: c, scene: h, sizes: u, invalidate: p } = ve();
  return ee(() => [n == null ? void 0 : n.value, u.width.value, t == null ? void 0 : t.value, u.height.value], () => {
    var f;
    (f = e.value) == null || f.dispose(), e.value = new jt((n == null ? void 0 : n.value) || u.width.value, (t == null ? void 0 : t.value) || u.height.value, {
      minFilter: vt,
      magFilter: vt,
      type: Vt,
      ...s == null ? void 0 : s.value
    }), i != null && i.value && (e.value.depthTexture = new xa(
      (n == null ? void 0 : n.value) || u.width.value,
      (t == null ? void 0 : t.value) || u.height.value,
      si
    )), p();
  }, { immediate: !0 }), a(() => {
    r.value && (c.value.setRenderTarget(e.value), c.value.clear(), c.value.render(h.value, l.value), c.value.setRenderTarget(null));
  }, Number.POSITIVE_INFINITY), Sr(() => {
    var f;
    (f = e.value) == null || f.dispose();
  }), e;
}
const Lg = /* @__PURE__ */ me({
  __name: "component",
  props: {
    width: {},
    height: {},
    depth: { type: Boolean, default: !1 },
    settings: { default: void 0 },
    autoRender: { type: Boolean, default: !0 }
  },
  setup(o, { expose: e }) {
    const n = cf(o);
    return e({
      instance: n
    }), () => {
    };
  }
}), uf = (o, e = 16, t, n, s) => {
  const i = new Float32Array(e * 16), r = fe(new Tr(i, 16));
  return (() => {
    if (!o)
      return;
    const l = new mh(o);
    n && l.setWeightAttribute(n), l.build();
    const c = new $(), h = new $(), u = new Pe(), p = new Pt();
    o.updateMatrixWorld(!0);
    for (let f = 0; f < e; f++)
      l.sample(c, h, u), typeof s == "function" ? s(
        {
          dummy: p,
          sampledMesh: o,
          position: c,
          normal: h,
          color: u
        },
        f
      ) : p.position.copy(c), p.updateMatrix(), t && t.setMatrixAt(f, p.matrix), p.matrix.toArray(r.value.array, f * 16);
    t && (t.instanceMatrix.needsUpdate = !0), r.value.needsUpdate = !0;
  })(), { buffer: r };
}, Fg = /* @__PURE__ */ me({
  __name: "component",
  props: {
    transform: { type: Function },
    weight: {},
    count: {},
    mesh: {},
    instanceMesh: {}
  },
  setup(o, { expose: e }) {
    const t = o, n = fe(), s = fe(), i = fe(), { invalidate: r } = ve();
    return ee(t, () => r()), Ft(() => {
      var a, l;
      s.value = t.instanceMesh ?? ((a = n.value) == null ? void 0 : a.children.find((c) => Object.prototype.hasOwnProperty.call(c, "instanceMatrix"))), i.value = t.mesh ?? ((l = n.value) == null ? void 0 : l.children.find((c) => c.type === "Mesh")), uf(i.value, t.count, s.value, t.weight, t.transform);
    }), e({
      samplerRef: n
    }), (a, l) => (ue(), de("TresGroup", {
      ref_key: "samplerRef",
      ref: n
    }, [
      je(a.$slots, "default")
    ], 512));
  }
}), Ws = {
  sunset: "venice/venice_sunset_1k.hdr",
  studio: "studio/poly_haven_studio_1k.hdr",
  city: "city/canary_wharf_1k.hdr",
  umbrellas: "outdoor/outdoor_umbrellas_1k.hdr",
  night: "outdoor/satara_night_1k.hdr",
  forest: "outood/mossy_forest_1k.hdr",
  snow: "outdoor/snowy_forest_path_01_1k.hdr",
  dawn: "kiara/kiara_1_dawn_1k.hdr",
  hangar: "indoor/small_hangar_01_1k.hdr",
  urban: "indoor/abandoned_games_room_02_1k.hdr",
  modern: "city/modern_buildings_2_1k.hdr",
  shangai: "city/shanghai_bund_1k.hdr"
}, hf = "https://raw.githubusercontent.com/Tresjs/assets/main/textures/hdr/";
async function ff(o, e) {
  const { scene: t, invalidate: n } = ve(), {
    preset: s,
    blur: i,
    files: r = fe([]),
    path: a = fe(""),
    background: l
  } = De(o);
  ee(o, () => {
    n();
  });
  const c = fe(null), h = Fe(() => Array.isArray(r.value)), u = Fe(() => h.value ? Hl : vo);
  return ee([r, a], async ([p, f]) => {
    if (p && p.length > 0 && !(s != null && s.value)) {
      try {
        c.value = await Nn(
          u.value,
          h.value ? [...U(p)] : U(p),
          (g) => {
            f && g.setPath(U(f));
          }
        );
      } catch (g) {
        throw new Error(`Failed to load environment map: ${g}`);
      }
      c.value && (c.value.mapping = h.value ? Gl : sr);
    }
  }, {
    immediate: !0
  }), ee(c, (p) => {
    t.value && p && (t.value.environment = p);
  }, {
    immediate: !0
  }), ee([l, c], ([p, f]) => {
    if (t.value) {
      const g = e != null && e.value ? e.value.texture : f;
      g && (t.value.background = p ? g : null);
    }
  }, {
    immediate: !0
  }), ee(() => i == null ? void 0 : i.value, (p) => {
    t.value && p && (t.value.backgroundBlurriness = p);
  }, {
    immediate: !0
  }), ee(() => s == null ? void 0 : s.value, async (p) => {
    if (p && p in Ws) {
      const f = hf, g = Ws[p];
      try {
        c.value = await Nn(
          vo,
          g,
          (m) => {
            f && m.setPath(f);
          }
        );
      } catch (m) {
        throw new Error(`Failed to load environment map: ${m}`);
      }
      c.value && c.value && (c.value.mapping = sr), n();
    } else if (p && !(p in Ws))
      throw new Error(`Preset must be one of: ${Object.keys(Ws).join(", ")}`);
  }, {
    immediate: !0
  }), c;
}
/*!
 * camera-controls
 * https://github.com/yomotsu/camera-controls
 * (c) 2017 @yomotsu
 * Released under the MIT License.
 */
const $e = {
  LEFT: 1,
  RIGHT: 2,
  MIDDLE: 4
}, J = Object.freeze({
  NONE: 0,
  ROTATE: 1,
  TRUCK: 2,
  OFFSET: 4,
  DOLLY: 8,
  ZOOM: 16,
  TOUCH_ROTATE: 32,
  TOUCH_TRUCK: 64,
  TOUCH_OFFSET: 128,
  TOUCH_DOLLY: 256,
  TOUCH_ZOOM: 512,
  TOUCH_DOLLY_TRUCK: 1024,
  TOUCH_DOLLY_OFFSET: 2048,
  TOUCH_DOLLY_ROTATE: 4096,
  TOUCH_ZOOM_TRUCK: 8192,
  TOUCH_ZOOM_OFFSET: 16384,
  TOUCH_ZOOM_ROTATE: 32768
}), Vn = {
  NONE: 0,
  IN: 1,
  OUT: -1
};
function In(o) {
  return o.isPerspectiveCamera;
}
function yn(o) {
  return o.isOrthographicCamera;
}
const Yn = Math.PI * 2, _o = Math.PI / 2, nl = 1e-5, ls = Math.PI / 180;
function Dt(o, e, t) {
  return Math.max(e, Math.min(t, o));
}
function Ge(o, e = nl) {
  return Math.abs(o) < e;
}
function Ne(o, e, t = nl) {
  return Ge(o - e, t);
}
function xo(o, e) {
  return Math.round(o / e) * e;
}
function cs(o) {
  return isFinite(o) ? o : o < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
}
function us(o) {
  return Math.abs(o) < Number.MAX_VALUE ? o : o * (1 / 0);
}
function $s(o, e, t, n, s = 1 / 0, i) {
  n = Math.max(1e-4, n);
  const r = 2 / n, a = r * i, l = 1 / (1 + a + 0.48 * a * a + 0.235 * a * a * a);
  let c = o - e;
  const h = e, u = s * n;
  c = Dt(c, -u, u), e = o - c;
  const p = (t.value + r * c) * i;
  t.value = (t.value - r * p) * l;
  let f = e + (c + p) * l;
  return h - o > 0 == f > h && (f = h, t.value = (f - h) / i), f;
}
function wo(o, e, t, n, s = 1 / 0, i, r) {
  n = Math.max(1e-4, n);
  const a = 2 / n, l = a * i, c = 1 / (1 + l + 0.48 * l * l + 0.235 * l * l * l);
  let h = e.x, u = e.y, p = e.z, f = o.x - h, g = o.y - u, m = o.z - p;
  const y = h, d = u, w = p, v = s * n, E = v * v, P = f * f + g * g + m * m;
  if (P > E) {
    const j = Math.sqrt(P);
    f = f / j * v, g = g / j * v, m = m / j * v;
  }
  h = o.x - f, u = o.y - g, p = o.z - m;
  const T = (t.x + a * f) * i, b = (t.y + a * g) * i, x = (t.z + a * m) * i;
  t.x = (t.x - a * T) * c, t.y = (t.y - a * b) * c, t.z = (t.z - a * x) * c, r.x = h + (f + T) * c, r.y = u + (g + b) * c, r.z = p + (m + x) * c;
  const M = y - o.x, _ = d - o.y, C = w - o.z, R = r.x - y, B = r.y - d, N = r.z - w;
  return M * R + _ * B + C * N > 0 && (r.x = y, r.y = d, r.z = w, t.x = (r.x - y) / i, t.y = (r.y - d) / i, t.z = (r.z - w) / i), r;
}
function Di(o, e) {
  e.set(0, 0), o.forEach((t) => {
    e.x += t.clientX, e.y += t.clientY;
  }), e.x /= o.length, e.y /= o.length;
}
function Li(o, e) {
  return yn(o) ? (console.warn(`${e} is not supported in OrthographicCamera`), !0) : !1;
}
class df {
  constructor() {
    this._listeners = {};
  }
  /**
   * Adds the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(e, t) {
    const n = this._listeners;
    n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t);
  }
  /**
   * Presence of the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  hasEventListener(e, t) {
    const n = this._listeners;
    return n[e] !== void 0 && n[e].indexOf(t) !== -1;
  }
  /**
   * Removes the specified event listener
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(e, t) {
    const s = this._listeners[e];
    if (s !== void 0) {
      const i = s.indexOf(t);
      i !== -1 && s.splice(i, 1);
    }
  }
  /**
   * Removes all event listeners
   * @param type event name
   * @category Methods
   */
  removeAllEventListeners(e) {
    if (!e) {
      this._listeners = {};
      return;
    }
    Array.isArray(this._listeners[e]) && (this._listeners[e].length = 0);
  }
  /**
   * Fire an event type.
   * @param event DispatcherEvent
   * @category Methods
   */
  dispatchEvent(e) {
    const n = this._listeners[e.type];
    if (n !== void 0) {
      e.target = this;
      const s = n.slice(0);
      for (let i = 0, r = s.length; i < r; i++)
        s[i].call(this, e);
    }
  }
}
var Fi;
const pf = "2.9.0", Zs = 1 / 8, mf = /Mac/.test((Fi = globalThis == null ? void 0 : globalThis.navigator) === null || Fi === void 0 ? void 0 : Fi.platform);
let we, To, Ks, ki, ct, Se, ke, Xn, hs, kt, Bt, On, bo, Eo, bt, fs, Wn, Mo, Bi, So, Ni, Ui, qs;
class at extends df {
  /**
       * Injects THREE as the dependency. You can then proceed to use CameraControls.
       *
       * e.g
       * ```javascript
       * CameraControls.install( { THREE: THREE } );
       * ```
       *
       * Note: If you do not wish to use enter three.js to reduce file size(tree-shaking for example), make a subset to install.
       *
       * ```js
       * import {
       * 	Vector2,
       * 	Vector3,
       * 	Vector4,
       * 	Quaternion,
       * 	Matrix4,
       * 	Spherical,
       * 	Box3,
       * 	Sphere,
       * 	Raycaster,
       * 	MathUtils,
       * } from 'three';
       *
       * const subsetOfTHREE = {
       * 	Vector2   : Vector2,
       * 	Vector3   : Vector3,
       * 	Vector4   : Vector4,
       * 	Quaternion: Quaternion,
       * 	Matrix4   : Matrix4,
       * 	Spherical : Spherical,
       * 	Box3      : Box3,
       * 	Sphere    : Sphere,
       * 	Raycaster : Raycaster,
       * };
  
       * CameraControls.install( { THREE: subsetOfTHREE } );
       * ```
       * @category Statics
       */
  static install(e) {
    we = e.THREE, To = Object.freeze(new we.Vector3(0, 0, 0)), Ks = Object.freeze(new we.Vector3(0, 1, 0)), ki = Object.freeze(new we.Vector3(0, 0, 1)), ct = new we.Vector2(), Se = new we.Vector3(), ke = new we.Vector3(), Xn = new we.Vector3(), hs = new we.Vector3(), kt = new we.Vector3(), Bt = new we.Vector3(), On = new we.Vector3(), bo = new we.Vector3(), Eo = new we.Vector3(), bt = new we.Spherical(), fs = new we.Spherical(), Wn = new we.Box3(), Mo = new we.Box3(), Bi = new we.Sphere(), So = new we.Quaternion(), Ni = new we.Quaternion(), Ui = new we.Matrix4(), qs = new we.Raycaster();
  }
  /**
   * list all ACTIONs
   * @category Statics
   */
  static get ACTION() {
    return J;
  }
  /**
   * Creates a `CameraControls` instance.
   *
   * Note:
   * You **must install** three.js before using camera-controls. see [#install](#install)
   * Not doing so will lead to runtime errors (`undefined` references to THREE).
   *
   * e.g.
   * ```
   * CameraControls.install( { THREE } );
   * const cameraControls = new CameraControls( camera, domElement );
   * ```
   *
   * @param camera A `THREE.PerspectiveCamera` or `THREE.OrthographicCamera` to be controlled.
   * @param domElement A `HTMLElement` for the draggable area, usually `renderer.domElement`.
   * @category Constructor
   */
  constructor(e, t) {
    super(), this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.minDistance = Number.EPSILON, this.maxDistance = 1 / 0, this.infinityDolly = !1, this.minZoom = 0.01, this.maxZoom = 1 / 0, this.smoothTime = 0.25, this.draggingSmoothTime = 0.125, this.maxSpeed = 1 / 0, this.azimuthRotateSpeed = 1, this.polarRotateSpeed = 1, this.dollySpeed = 1, this.dollyDragInverted = !1, this.truckSpeed = 2, this.dollyToCursor = !1, this.dragToOffset = !1, this.verticalDragToForward = !1, this.boundaryFriction = 0, this.restThreshold = 0.01, this.colliderMeshes = [], this.cancel = () => {
    }, this._enabled = !0, this._state = J.NONE, this._viewport = null, this._changedDolly = 0, this._changedZoom = 0, this._hasRested = !0, this._boundaryEnclosesCamera = !1, this._needsUpdate = !0, this._updatedLastTime = !1, this._elementRect = new DOMRect(), this._isDragging = !1, this._dragNeedsUpdate = !0, this._activePointers = [], this._lockedPointer = null, this._interactiveArea = new DOMRect(0, 0, 1, 1), this._isUserControllingRotate = !1, this._isUserControllingDolly = !1, this._isUserControllingTruck = !1, this._isUserControllingOffset = !1, this._isUserControllingZoom = !1, this._lastDollyDirection = Vn.NONE, this._thetaVelocity = { value: 0 }, this._phiVelocity = { value: 0 }, this._radiusVelocity = { value: 0 }, this._targetVelocity = new we.Vector3(), this._focalOffsetVelocity = new we.Vector3(), this._zoomVelocity = { value: 0 }, this._truckInternal = (d, w, v) => {
      let E, P;
      if (In(this._camera)) {
        const T = Se.copy(this._camera.position).sub(this._target), b = this._camera.getEffectiveFOV() * ls, x = T.length() * Math.tan(b * 0.5);
        E = this.truckSpeed * d * x / this._elementRect.height, P = this.truckSpeed * w * x / this._elementRect.height;
      } else if (yn(this._camera)) {
        const T = this._camera;
        E = d * (T.right - T.left) / T.zoom / this._elementRect.width, P = w * (T.top - T.bottom) / T.zoom / this._elementRect.height;
      } else
        return;
      this.verticalDragToForward ? (v ? this.setFocalOffset(this._focalOffsetEnd.x + E, this._focalOffsetEnd.y, this._focalOffsetEnd.z, !0) : this.truck(E, 0, !0), this.forward(-P, !0)) : v ? this.setFocalOffset(this._focalOffsetEnd.x + E, this._focalOffsetEnd.y + P, this._focalOffsetEnd.z, !0) : this.truck(E, P, !0);
    }, this._rotateInternal = (d, w) => {
      const v = Yn * this.azimuthRotateSpeed * d / this._elementRect.height, E = Yn * this.polarRotateSpeed * w / this._elementRect.height;
      this.rotate(v, E, !0);
    }, this._dollyInternal = (d, w, v) => {
      const E = Math.pow(0.95, -d * this.dollySpeed), P = this._sphericalEnd.radius, T = this._sphericalEnd.radius * E, b = Dt(T, this.minDistance, this.maxDistance), x = b - T;
      this.infinityDolly && this.dollyToCursor ? this._dollyToNoClamp(T, !0) : this.infinityDolly && !this.dollyToCursor ? (this.dollyInFixed(x, !0), this._dollyToNoClamp(b, !0)) : this._dollyToNoClamp(b, !0), this.dollyToCursor && (this._changedDolly += (this.infinityDolly ? T : b) - P, this._dollyControlCoord.set(w, v)), this._lastDollyDirection = Math.sign(-d);
    }, this._zoomInternal = (d, w, v) => {
      const E = Math.pow(0.95, d * this.dollySpeed), P = this._zoom, T = this._zoom * E;
      this.zoomTo(T, !0), this.dollyToCursor && (this._changedZoom += T - P, this._dollyControlCoord.set(w, v));
    }, typeof we > "u" && console.error("camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information."), this._camera = e, this._yAxisUpSpace = new we.Quaternion().setFromUnitVectors(this._camera.up, Ks), this._yAxisUpSpaceInverse = this._yAxisUpSpace.clone().invert(), this._state = J.NONE, this._target = new we.Vector3(), this._targetEnd = this._target.clone(), this._focalOffset = new we.Vector3(), this._focalOffsetEnd = this._focalOffset.clone(), this._spherical = new we.Spherical().setFromVector3(Se.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace)), this._sphericalEnd = this._spherical.clone(), this._lastDistance = this._spherical.radius, this._zoom = this._camera.zoom, this._zoomEnd = this._zoom, this._lastZoom = this._zoom, this._nearPlaneCorners = [
      new we.Vector3(),
      new we.Vector3(),
      new we.Vector3(),
      new we.Vector3()
    ], this._updateNearPlaneCorners(), this._boundary = new we.Box3(new we.Vector3(-1 / 0, -1 / 0, -1 / 0), new we.Vector3(1 / 0, 1 / 0, 1 / 0)), this._cameraUp0 = this._camera.up.clone(), this._target0 = this._target.clone(), this._position0 = this._camera.position.clone(), this._zoom0 = this._zoom, this._focalOffset0 = this._focalOffset.clone(), this._dollyControlCoord = new we.Vector2(), this.mouseButtons = {
      left: J.ROTATE,
      middle: J.DOLLY,
      right: J.TRUCK,
      wheel: In(this._camera) ? J.DOLLY : yn(this._camera) ? J.ZOOM : J.NONE
    }, this.touches = {
      one: J.TOUCH_ROTATE,
      two: In(this._camera) ? J.TOUCH_DOLLY_TRUCK : yn(this._camera) ? J.TOUCH_ZOOM_TRUCK : J.NONE,
      three: J.TOUCH_TRUCK
    };
    const n = new we.Vector2(), s = new we.Vector2(), i = new we.Vector2(), r = (d) => {
      if (!this._enabled || !this._domElement)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const E = this._domElement.getBoundingClientRect(), P = d.clientX / E.width, T = d.clientY / E.height;
        if (P < this._interactiveArea.left || P > this._interactiveArea.right || T < this._interactiveArea.top || T > this._interactiveArea.bottom)
          return;
      }
      const w = d.pointerType !== "mouse" ? null : (d.buttons & $e.LEFT) === $e.LEFT ? $e.LEFT : (d.buttons & $e.MIDDLE) === $e.MIDDLE ? $e.MIDDLE : (d.buttons & $e.RIGHT) === $e.RIGHT ? $e.RIGHT : null;
      if (w !== null) {
        const E = this._findPointerByMouseButton(w);
        E && this._disposePointer(E);
      }
      if ((d.buttons & $e.LEFT) === $e.LEFT && this._lockedPointer)
        return;
      const v = {
        pointerId: d.pointerId,
        clientX: d.clientX,
        clientY: d.clientY,
        deltaX: 0,
        deltaY: 0,
        mouseButton: w
      };
      this._activePointers.push(v), this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", l), this._domElement.ownerDocument.addEventListener("pointermove", a, { passive: !1 }), this._domElement.ownerDocument.addEventListener("pointerup", l), this._isDragging = !0, p(d);
    }, a = (d) => {
      d.cancelable && d.preventDefault();
      const w = d.pointerId, v = this._lockedPointer || this._findPointerById(w);
      if (v) {
        if (v.clientX = d.clientX, v.clientY = d.clientY, v.deltaX = d.movementX, v.deltaY = d.movementY, this._state = 0, d.pointerType === "touch")
          switch (this._activePointers.length) {
            case 1:
              this._state = this.touches.one;
              break;
            case 2:
              this._state = this.touches.two;
              break;
            case 3:
              this._state = this.touches.three;
              break;
          }
        else
          (!this._isDragging && this._lockedPointer || this._isDragging && (d.buttons & $e.LEFT) === $e.LEFT) && (this._state = this._state | this.mouseButtons.left), this._isDragging && (d.buttons & $e.MIDDLE) === $e.MIDDLE && (this._state = this._state | this.mouseButtons.middle), this._isDragging && (d.buttons & $e.RIGHT) === $e.RIGHT && (this._state = this._state | this.mouseButtons.right);
        f();
      }
    }, l = (d) => {
      const w = this._findPointerById(d.pointerId);
      if (!(w && w === this._lockedPointer)) {
        if (w && this._disposePointer(w), d.pointerType === "touch")
          switch (this._activePointers.length) {
            case 0:
              this._state = J.NONE;
              break;
            case 1:
              this._state = this.touches.one;
              break;
            case 2:
              this._state = this.touches.two;
              break;
            case 3:
              this._state = this.touches.three;
              break;
          }
        else
          this._state = J.NONE;
        g();
      }
    };
    let c = -1;
    const h = (d) => {
      if (!this._domElement || !this._enabled || this.mouseButtons.wheel === J.NONE)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const T = this._domElement.getBoundingClientRect(), b = d.clientX / T.width, x = d.clientY / T.height;
        if (b < this._interactiveArea.left || b > this._interactiveArea.right || x < this._interactiveArea.top || x > this._interactiveArea.bottom)
          return;
      }
      if (d.preventDefault(), this.dollyToCursor || this.mouseButtons.wheel === J.ROTATE || this.mouseButtons.wheel === J.TRUCK) {
        const T = performance.now();
        c - T < 1e3 && this._getClientRect(this._elementRect), c = T;
      }
      const w = mf ? -1 : -3, v = d.deltaMode === 1 ? d.deltaY / w : d.deltaY / (w * 10), E = this.dollyToCursor ? (d.clientX - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, P = this.dollyToCursor ? (d.clientY - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
      switch (this.mouseButtons.wheel) {
        case J.ROTATE: {
          this._rotateInternal(d.deltaX, d.deltaY), this._isUserControllingRotate = !0;
          break;
        }
        case J.TRUCK: {
          this._truckInternal(d.deltaX, d.deltaY, !1), this._isUserControllingTruck = !0;
          break;
        }
        case J.OFFSET: {
          this._truckInternal(d.deltaX, d.deltaY, !0), this._isUserControllingOffset = !0;
          break;
        }
        case J.DOLLY: {
          this._dollyInternal(-v, E, P), this._isUserControllingDolly = !0;
          break;
        }
        case J.ZOOM: {
          this._zoomInternal(-v, E, P), this._isUserControllingZoom = !0;
          break;
        }
      }
      this.dispatchEvent({ type: "control" });
    }, u = (d) => {
      if (!(!this._domElement || !this._enabled)) {
        if (this.mouseButtons.right === at.ACTION.NONE) {
          const w = d instanceof PointerEvent ? d.pointerId : 0, v = this._findPointerById(w);
          v && this._disposePointer(v), this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", l);
          return;
        }
        d.preventDefault();
      }
    }, p = (d) => {
      if (!this._enabled)
        return;
      if (Di(this._activePointers, ct), this._getClientRect(this._elementRect), n.copy(ct), s.copy(ct), this._activePointers.length >= 2) {
        const v = ct.x - this._activePointers[1].clientX, E = ct.y - this._activePointers[1].clientY, P = Math.sqrt(v * v + E * E);
        i.set(0, P);
        const T = (this._activePointers[0].clientX + this._activePointers[1].clientX) * 0.5, b = (this._activePointers[0].clientY + this._activePointers[1].clientY) * 0.5;
        s.set(T, b);
      }
      if (this._state = 0, !d)
        this._lockedPointer && (this._state = this._state | this.mouseButtons.left);
      else if ("pointerType" in d && d.pointerType === "touch")
        switch (this._activePointers.length) {
          case 1:
            this._state = this.touches.one;
            break;
          case 2:
            this._state = this.touches.two;
            break;
          case 3:
            this._state = this.touches.three;
            break;
        }
      else
        !this._lockedPointer && (d.buttons & $e.LEFT) === $e.LEFT && (this._state = this._state | this.mouseButtons.left), (d.buttons & $e.MIDDLE) === $e.MIDDLE && (this._state = this._state | this.mouseButtons.middle), (d.buttons & $e.RIGHT) === $e.RIGHT && (this._state = this._state | this.mouseButtons.right);
      ((this._state & J.ROTATE) === J.ROTATE || (this._state & J.TOUCH_ROTATE) === J.TOUCH_ROTATE || (this._state & J.TOUCH_DOLLY_ROTATE) === J.TOUCH_DOLLY_ROTATE || (this._state & J.TOUCH_ZOOM_ROTATE) === J.TOUCH_ZOOM_ROTATE) && (this._sphericalEnd.theta = this._spherical.theta, this._sphericalEnd.phi = this._spherical.phi, this._thetaVelocity.value = 0, this._phiVelocity.value = 0), ((this._state & J.TRUCK) === J.TRUCK || (this._state & J.TOUCH_TRUCK) === J.TOUCH_TRUCK || (this._state & J.TOUCH_DOLLY_TRUCK) === J.TOUCH_DOLLY_TRUCK || (this._state & J.TOUCH_ZOOM_TRUCK) === J.TOUCH_ZOOM_TRUCK) && (this._targetEnd.copy(this._target), this._targetVelocity.set(0, 0, 0)), ((this._state & J.DOLLY) === J.DOLLY || (this._state & J.TOUCH_DOLLY) === J.TOUCH_DOLLY || (this._state & J.TOUCH_DOLLY_TRUCK) === J.TOUCH_DOLLY_TRUCK || (this._state & J.TOUCH_DOLLY_OFFSET) === J.TOUCH_DOLLY_OFFSET || (this._state & J.TOUCH_DOLLY_ROTATE) === J.TOUCH_DOLLY_ROTATE) && (this._sphericalEnd.radius = this._spherical.radius, this._radiusVelocity.value = 0), ((this._state & J.ZOOM) === J.ZOOM || (this._state & J.TOUCH_ZOOM) === J.TOUCH_ZOOM || (this._state & J.TOUCH_ZOOM_TRUCK) === J.TOUCH_ZOOM_TRUCK || (this._state & J.TOUCH_ZOOM_OFFSET) === J.TOUCH_ZOOM_OFFSET || (this._state & J.TOUCH_ZOOM_ROTATE) === J.TOUCH_ZOOM_ROTATE) && (this._zoomEnd = this._zoom, this._zoomVelocity.value = 0), ((this._state & J.OFFSET) === J.OFFSET || (this._state & J.TOUCH_OFFSET) === J.TOUCH_OFFSET || (this._state & J.TOUCH_DOLLY_OFFSET) === J.TOUCH_DOLLY_OFFSET || (this._state & J.TOUCH_ZOOM_OFFSET) === J.TOUCH_ZOOM_OFFSET) && (this._focalOffsetEnd.copy(this._focalOffset), this._focalOffsetVelocity.set(0, 0, 0)), this.dispatchEvent({ type: "controlstart" });
    }, f = () => {
      if (!this._enabled || !this._dragNeedsUpdate)
        return;
      this._dragNeedsUpdate = !1, Di(this._activePointers, ct);
      const w = this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement ? this._lockedPointer || this._activePointers[0] : null, v = w ? -w.deltaX : s.x - ct.x, E = w ? -w.deltaY : s.y - ct.y;
      if (s.copy(ct), ((this._state & J.ROTATE) === J.ROTATE || (this._state & J.TOUCH_ROTATE) === J.TOUCH_ROTATE || (this._state & J.TOUCH_DOLLY_ROTATE) === J.TOUCH_DOLLY_ROTATE || (this._state & J.TOUCH_ZOOM_ROTATE) === J.TOUCH_ZOOM_ROTATE) && (this._rotateInternal(v, E), this._isUserControllingRotate = !0), (this._state & J.DOLLY) === J.DOLLY || (this._state & J.ZOOM) === J.ZOOM) {
        const P = this.dollyToCursor ? (n.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, T = this.dollyToCursor ? (n.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0, b = this.dollyDragInverted ? -1 : 1;
        (this._state & J.DOLLY) === J.DOLLY ? (this._dollyInternal(b * E * Zs, P, T), this._isUserControllingDolly = !0) : (this._zoomInternal(b * E * Zs, P, T), this._isUserControllingZoom = !0);
      }
      if ((this._state & J.TOUCH_DOLLY) === J.TOUCH_DOLLY || (this._state & J.TOUCH_ZOOM) === J.TOUCH_ZOOM || (this._state & J.TOUCH_DOLLY_TRUCK) === J.TOUCH_DOLLY_TRUCK || (this._state & J.TOUCH_ZOOM_TRUCK) === J.TOUCH_ZOOM_TRUCK || (this._state & J.TOUCH_DOLLY_OFFSET) === J.TOUCH_DOLLY_OFFSET || (this._state & J.TOUCH_ZOOM_OFFSET) === J.TOUCH_ZOOM_OFFSET || (this._state & J.TOUCH_DOLLY_ROTATE) === J.TOUCH_DOLLY_ROTATE || (this._state & J.TOUCH_ZOOM_ROTATE) === J.TOUCH_ZOOM_ROTATE) {
        const P = ct.x - this._activePointers[1].clientX, T = ct.y - this._activePointers[1].clientY, b = Math.sqrt(P * P + T * T), x = i.y - b;
        i.set(0, b);
        const M = this.dollyToCursor ? (s.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, _ = this.dollyToCursor ? (s.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
        (this._state & J.TOUCH_DOLLY) === J.TOUCH_DOLLY || (this._state & J.TOUCH_DOLLY_ROTATE) === J.TOUCH_DOLLY_ROTATE || (this._state & J.TOUCH_DOLLY_TRUCK) === J.TOUCH_DOLLY_TRUCK || (this._state & J.TOUCH_DOLLY_OFFSET) === J.TOUCH_DOLLY_OFFSET ? (this._dollyInternal(x * Zs, M, _), this._isUserControllingDolly = !0) : (this._zoomInternal(x * Zs, M, _), this._isUserControllingZoom = !0);
      }
      ((this._state & J.TRUCK) === J.TRUCK || (this._state & J.TOUCH_TRUCK) === J.TOUCH_TRUCK || (this._state & J.TOUCH_DOLLY_TRUCK) === J.TOUCH_DOLLY_TRUCK || (this._state & J.TOUCH_ZOOM_TRUCK) === J.TOUCH_ZOOM_TRUCK) && (this._truckInternal(v, E, !1), this._isUserControllingTruck = !0), ((this._state & J.OFFSET) === J.OFFSET || (this._state & J.TOUCH_OFFSET) === J.TOUCH_OFFSET || (this._state & J.TOUCH_DOLLY_OFFSET) === J.TOUCH_DOLLY_OFFSET || (this._state & J.TOUCH_ZOOM_OFFSET) === J.TOUCH_ZOOM_OFFSET) && (this._truckInternal(v, E, !0), this._isUserControllingOffset = !0), this.dispatchEvent({ type: "control" });
    }, g = () => {
      Di(this._activePointers, ct), s.copy(ct), this._dragNeedsUpdate = !1, (this._activePointers.length === 0 || this._activePointers.length === 1 && this._activePointers[0] === this._lockedPointer) && (this._isDragging = !1), this._activePointers.length === 0 && this._domElement && (this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", l), this.dispatchEvent({ type: "controlend" }));
    };
    this.lockPointer = () => {
      !this._enabled || !this._domElement || (this.cancel(), this._lockedPointer = {
        pointerId: -1,
        clientX: 0,
        clientY: 0,
        deltaX: 0,
        deltaY: 0,
        mouseButton: null
      }, this._activePointers.push(this._lockedPointer), this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", l), this._domElement.requestPointerLock(), this._domElement.ownerDocument.addEventListener("pointerlockchange", m), this._domElement.ownerDocument.addEventListener("pointerlockerror", y), this._domElement.ownerDocument.addEventListener("pointermove", a, { passive: !1 }), this._domElement.ownerDocument.addEventListener("pointerup", l), p());
    }, this.unlockPointer = () => {
      var d, w, v;
      this._lockedPointer !== null && (this._disposePointer(this._lockedPointer), this._lockedPointer = null), (d = this._domElement) === null || d === void 0 || d.ownerDocument.exitPointerLock(), (w = this._domElement) === null || w === void 0 || w.ownerDocument.removeEventListener("pointerlockchange", m), (v = this._domElement) === null || v === void 0 || v.ownerDocument.removeEventListener("pointerlockerror", y), this.cancel();
    };
    const m = () => {
      this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement || this.unlockPointer();
    }, y = () => {
      this.unlockPointer();
    };
    this._addAllEventListeners = (d) => {
      this._domElement = d, this._domElement.style.touchAction = "none", this._domElement.style.userSelect = "none", this._domElement.style.webkitUserSelect = "none", this._domElement.addEventListener("pointerdown", r), this._domElement.addEventListener("pointercancel", l), this._domElement.addEventListener("wheel", h, { passive: !1 }), this._domElement.addEventListener("contextmenu", u);
    }, this._removeAllEventListeners = () => {
      this._domElement && (this._domElement.style.touchAction = "", this._domElement.style.userSelect = "", this._domElement.style.webkitUserSelect = "", this._domElement.removeEventListener("pointerdown", r), this._domElement.removeEventListener("pointercancel", l), this._domElement.removeEventListener("wheel", h, { passive: !1 }), this._domElement.removeEventListener("contextmenu", u), this._domElement.ownerDocument.removeEventListener("pointermove", a, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", l), this._domElement.ownerDocument.removeEventListener("pointerlockchange", m), this._domElement.ownerDocument.removeEventListener("pointerlockerror", y));
    }, this.cancel = () => {
      this._state !== J.NONE && (this._state = J.NONE, this._activePointers.length = 0, g());
    }, t && this.connect(t), this.update(0);
  }
  /**
   * The camera to be controlled
   * @category Properties
   */
  get camera() {
    return this._camera;
  }
  set camera(e) {
    this._camera = e, this.updateCameraUp(), this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = !0;
  }
  /**
   * Whether or not the controls are enabled.
   * `false` to disable user dragging/touch-move, but all methods works.
   * @category Properties
   */
  get enabled() {
    return this._enabled;
  }
  set enabled(e) {
    this._enabled = e, this._domElement && (e ? (this._domElement.style.touchAction = "none", this._domElement.style.userSelect = "none", this._domElement.style.webkitUserSelect = "none") : (this.cancel(), this._domElement.style.touchAction = "", this._domElement.style.userSelect = "", this._domElement.style.webkitUserSelect = ""));
  }
  /**
   * Returns `true` if the controls are active updating.
   * readonly value.
   * @category Properties
   */
  get active() {
    return !this._hasRested;
  }
  /**
   * Getter for the current `ACTION`.
   * readonly value.
   * @category Properties
   */
  get currentAction() {
    return this._state;
  }
  /**
   * get/set Current distance.
   * @category Properties
   */
  get distance() {
    return this._spherical.radius;
  }
  set distance(e) {
    this._spherical.radius === e && this._sphericalEnd.radius === e || (this._spherical.radius = e, this._sphericalEnd.radius = e, this._needsUpdate = !0);
  }
  // horizontal angle
  /**
   * get/set the azimuth angle (horizontal) in radians.
   * Every 360 degrees turn is added to `.azimuthAngle` value, which is accumulative.
   * @category Properties
   */
  get azimuthAngle() {
    return this._spherical.theta;
  }
  set azimuthAngle(e) {
    this._spherical.theta === e && this._sphericalEnd.theta === e || (this._spherical.theta = e, this._sphericalEnd.theta = e, this._needsUpdate = !0);
  }
  // vertical angle
  /**
   * get/set the polar angle (vertical) in radians.
   * @category Properties
   */
  get polarAngle() {
    return this._spherical.phi;
  }
  set polarAngle(e) {
    this._spherical.phi === e && this._sphericalEnd.phi === e || (this._spherical.phi = e, this._sphericalEnd.phi = e, this._needsUpdate = !0);
  }
  /**
   * Whether camera position should be enclosed in the boundary or not.
   * @category Properties
   */
  get boundaryEnclosesCamera() {
    return this._boundaryEnclosesCamera;
  }
  set boundaryEnclosesCamera(e) {
    this._boundaryEnclosesCamera = e, this._needsUpdate = !0;
  }
  /**
   * Set drag-start, touches and wheel enable area in the domElement.
   * each values are between `0` and `1` inclusive, where `0` is left/top and `1` is right/bottom of the screen.
   * e.g. `{ x: 0, y: 0, width: 1, height: 1 }` for entire area.
   * @category Properties
   */
  set interactiveArea(e) {
    this._interactiveArea.width = Dt(e.width, 0, 1), this._interactiveArea.height = Dt(e.height, 0, 1), this._interactiveArea.x = Dt(e.x, 0, 1 - this._interactiveArea.width), this._interactiveArea.y = Dt(e.y, 0, 1 - this._interactiveArea.height);
  }
  /**
   * Adds the specified event listener.
   * Applicable event types (which is `K`) are:
   * | Event name          | Timing |
   * | ------------------- | ------ |
   * | `'controlstart'`    | When the user starts to control the camera via mouse / touches. ¹ |
   * | `'control'`         | When the user controls the camera (dragging). |
   * | `'controlend'`      | When the user ends to control the camera. ¹ |
   * | `'transitionstart'` | When any kind of transition starts, either user control or using a method with `enableTransition = true` |
   * | `'update'`          | When the camera position is updated. |
   * | `'wake'`            | When the camera starts moving. |
   * | `'rest'`            | When the camera movement is below `.restThreshold` ². |
   * | `'sleep'`           | When the camera end moving. |
   *
   * 1. `mouseButtons.wheel` (Mouse wheel control) does not emit `'controlstart'` and `'controlend'`. `mouseButtons.wheel` uses scroll-event internally, and scroll-event happens intermittently. That means "start" and "end" cannot be detected.
   * 2. Due to damping, `sleep` will usually fire a few seconds after the camera _appears_ to have stopped moving. If you want to do something (e.g. enable UI, perform another transition) at the point when the camera has stopped, you probably want the `rest` event. This can be fine tuned using the `.restThreshold` parameter. See the [Rest and Sleep Example](https://yomotsu.github.io/camera-controls/examples/rest-and-sleep.html).
   *
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(e, t) {
    super.addEventListener(e, t);
  }
  /**
   * Removes the specified event listener
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(e, t) {
    super.removeEventListener(e, t);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical).
   * Every value is added to the current value.
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotate(e, t, n = !1) {
    return this.rotateTo(this._sphericalEnd.theta + e, this._sphericalEnd.phi + t, n);
  }
  /**
   * Rotate azimuthal angle(horizontal) to the given angle and keep the same polar angle(vertical) target.
   *
   * e.g.
   * ```
   * cameraControls.rotateAzimuthTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotateAzimuthTo(e, t = !1) {
    return this.rotateTo(e, this._sphericalEnd.phi, t);
  }
  /**
   * Rotate polar angle(vertical) to the given angle and keep the same azimuthal angle(horizontal) target.
   *
   * e.g.
   * ```
   * cameraControls.rotatePolarTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotatePolarTo(e, t = !1) {
    return this.rotateTo(this._sphericalEnd.theta, e, t);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical) to the given angle.
   * Camera view will rotate over the orbit pivot absolutely:
   *
   * azimuthAngle
   * ```
   *       0º
   *         \
   * 90º -----+----- -90º
   *           \
   *           180º
   * ```
   * | direction | angle                  |
   * | --------- | ---------------------- |
   * | front     | 0º                     |
   * | left      | 90º (`Math.PI / 2`)    |
   * | right     | -90º (`- Math.PI / 2`) |
   * | back      | 180º (`Math.PI`)       |
   *
   * polarAngle
   * ```
   *     180º
   *      |
   *      90º
   *      |
   *      0º
   * ```
   * | direction            | angle                  |
   * | -------------------- | ---------------------- |
   * | top/sky              | 180º (`Math.PI`)       |
   * | horizontal from view | 90º (`Math.PI / 2`)    |
   * | bottom/floor         | 0º                     |
   *
   * @param azimuthAngle Azimuth rotate angle to. In radian.
   * @param polarAngle Polar rotate angle to. In radian.
   * @param enableTransition  Whether to move smoothly or immediately
   * @category Methods
   */
  rotateTo(e, t, n = !1) {
    this._isUserControllingRotate = !1;
    const s = Dt(e, this.minAzimuthAngle, this.maxAzimuthAngle), i = Dt(t, this.minPolarAngle, this.maxPolarAngle);
    this._sphericalEnd.theta = s, this._sphericalEnd.phi = i, this._sphericalEnd.makeSafe(), this._needsUpdate = !0, n || (this._spherical.theta = this._sphericalEnd.theta, this._spherical.phi = this._sphericalEnd.phi);
    const r = !n || Ne(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && Ne(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold);
    return this._createOnRestPromise(r);
  }
  /**
   * Dolly in/out camera position.
   * @param distance Distance of dollyIn. Negative number for dollyOut.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dolly(e, t = !1) {
    return this.dollyTo(this._sphericalEnd.radius - e, t);
  }
  /**
   * Dolly in/out camera position to given distance.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyTo(e, t = !1) {
    return this._isUserControllingDolly = !1, this._lastDollyDirection = Vn.NONE, this._changedDolly = 0, this._dollyToNoClamp(Dt(e, this.minDistance, this.maxDistance), t);
  }
  _dollyToNoClamp(e, t = !1) {
    const n = this._sphericalEnd.radius;
    if (this.colliderMeshes.length >= 1) {
      const r = this._collisionTest(), a = Ne(r, this._spherical.radius);
      if (!(n > e) && a)
        return Promise.resolve();
      this._sphericalEnd.radius = Math.min(e, r);
    } else
      this._sphericalEnd.radius = e;
    this._needsUpdate = !0, t || (this._spherical.radius = this._sphericalEnd.radius);
    const i = !t || Ne(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(i);
  }
  /**
   * Dolly in, but does not change the distance between the target and the camera, and moves the target position instead.
   * Specify a negative value for dolly out.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyInFixed(e, t = !1) {
    this._targetEnd.add(this._getCameraDirection(hs).multiplyScalar(e)), t || this._target.copy(this._targetEnd);
    const n = !t || Ne(this._target.x, this._targetEnd.x, this.restThreshold) && Ne(this._target.y, this._targetEnd.y, this.restThreshold) && Ne(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(n);
  }
  /**
   * Zoom in/out camera. The value is added to camera zoom.
   * Limits set with `.minZoom` and `.maxZoom`
   * @param zoomStep zoom scale
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  zoom(e, t = !1) {
    return this.zoomTo(this._zoomEnd + e, t);
  }
  /**
   * Zoom in/out camera to given scale. The value overwrites camera zoom.
   * Limits set with .minZoom and .maxZoom
   * @param zoom
   * @param enableTransition
   * @category Methods
   */
  zoomTo(e, t = !1) {
    this._isUserControllingZoom = !1, this._zoomEnd = Dt(e, this.minZoom, this.maxZoom), this._needsUpdate = !0, t || (this._zoom = this._zoomEnd);
    const n = !t || Ne(this._zoom, this._zoomEnd, this.restThreshold);
    return this._changedZoom = 0, this._createOnRestPromise(n);
  }
  /**
   * @deprecated `pan()` has been renamed to `truck()`
   * @category Methods
   */
  pan(e, t, n = !1) {
    return console.warn("`pan` has been renamed to `truck`"), this.truck(e, t, n);
  }
  /**
   * Truck and pedestal camera using current azimuthal angle
   * @param x Horizontal translate amount
   * @param y Vertical translate amount
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  truck(e, t, n = !1) {
    this._camera.updateMatrix(), kt.setFromMatrixColumn(this._camera.matrix, 0), Bt.setFromMatrixColumn(this._camera.matrix, 1), kt.multiplyScalar(e), Bt.multiplyScalar(-t);
    const s = Se.copy(kt).add(Bt), i = ke.copy(this._targetEnd).add(s);
    return this.moveTo(i.x, i.y, i.z, n);
  }
  /**
   * Move forward / backward.
   * @param distance Amount to move forward / backward. Negative value to move backward
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  forward(e, t = !1) {
    Se.setFromMatrixColumn(this._camera.matrix, 0), Se.crossVectors(this._camera.up, Se), Se.multiplyScalar(e);
    const n = ke.copy(this._targetEnd).add(Se);
    return this.moveTo(n.x, n.y, n.z, t);
  }
  /**
   * Move up / down.
   * @param height Amount to move up / down. Negative value to move down
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  elevate(e, t = !1) {
    return Se.copy(this._camera.up).multiplyScalar(e), this.moveTo(this._targetEnd.x + Se.x, this._targetEnd.y + Se.y, this._targetEnd.z + Se.z, t);
  }
  /**
   * Move target position to given point.
   * @param x x coord to move center position
   * @param y y coord to move center position
   * @param z z coord to move center position
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  moveTo(e, t, n, s = !1) {
    this._isUserControllingTruck = !1;
    const i = Se.set(e, t, n).sub(this._targetEnd);
    this._encloseToBoundary(this._targetEnd, i, this.boundaryFriction), this._needsUpdate = !0, s || this._target.copy(this._targetEnd);
    const r = !s || Ne(this._target.x, this._targetEnd.x, this.restThreshold) && Ne(this._target.y, this._targetEnd.y, this.restThreshold) && Ne(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(r);
  }
  /**
   * Look in the given point direction.
   * @param x point x.
   * @param y point y.
   * @param z point z.
   * @param enableTransition Whether to move smoothly or immediately.
   * @returns Transition end promise
   * @category Methods
   */
  lookInDirectionOf(e, t, n, s = !1) {
    const a = Se.set(e, t, n).sub(this._targetEnd).normalize().multiplyScalar(-this._sphericalEnd.radius).add(this._targetEnd);
    return this.setPosition(a.x, a.y, a.z, s);
  }
  /**
   * Fit the viewport to the box or the bounding box of the object, using the nearest axis. paddings are in unit.
   * set `cover: true` to fill enter screen.
   * e.g.
   * ```
   * cameraControls.fitToBox( myMesh );
   * ```
   * @param box3OrObject Axis aligned bounding box to fit the view.
   * @param enableTransition Whether to move smoothly or immediately.
   * @param options | `<object>` { cover: boolean, paddingTop: number, paddingLeft: number, paddingBottom: number, paddingRight: number }
   * @returns Transition end promise
   * @category Methods
   */
  fitToBox(e, t, { cover: n = !1, paddingLeft: s = 0, paddingRight: i = 0, paddingBottom: r = 0, paddingTop: a = 0 } = {}) {
    const l = [], c = e.isBox3 ? Wn.copy(e) : Wn.setFromObject(e);
    c.isEmpty() && (console.warn("camera-controls: fitTo() cannot be used with an empty box. Aborting"), Promise.resolve());
    const h = xo(this._sphericalEnd.theta, _o), u = xo(this._sphericalEnd.phi, _o);
    l.push(this.rotateTo(h, u, t));
    const p = Se.setFromSpherical(this._sphericalEnd).normalize(), f = So.setFromUnitVectors(p, ki), g = Ne(Math.abs(p.y), 1);
    g && f.multiply(Ni.setFromAxisAngle(Ks, h)), f.multiply(this._yAxisUpSpaceInverse);
    const m = Mo.makeEmpty();
    ke.copy(c.min).applyQuaternion(f), m.expandByPoint(ke), ke.copy(c.min).setX(c.max.x).applyQuaternion(f), m.expandByPoint(ke), ke.copy(c.min).setY(c.max.y).applyQuaternion(f), m.expandByPoint(ke), ke.copy(c.max).setZ(c.min.z).applyQuaternion(f), m.expandByPoint(ke), ke.copy(c.min).setZ(c.max.z).applyQuaternion(f), m.expandByPoint(ke), ke.copy(c.max).setY(c.min.y).applyQuaternion(f), m.expandByPoint(ke), ke.copy(c.max).setX(c.min.x).applyQuaternion(f), m.expandByPoint(ke), ke.copy(c.max).applyQuaternion(f), m.expandByPoint(ke), m.min.x -= s, m.min.y -= r, m.max.x += i, m.max.y += a, f.setFromUnitVectors(ki, p), g && f.premultiply(Ni.invert()), f.premultiply(this._yAxisUpSpace);
    const y = m.getSize(Se), d = m.getCenter(ke).applyQuaternion(f);
    if (In(this._camera)) {
      const w = this.getDistanceToFitBox(y.x, y.y, y.z, n);
      l.push(this.moveTo(d.x, d.y, d.z, t)), l.push(this.dollyTo(w, t)), l.push(this.setFocalOffset(0, 0, 0, t));
    } else if (yn(this._camera)) {
      const w = this._camera, v = w.right - w.left, E = w.top - w.bottom, P = n ? Math.max(v / y.x, E / y.y) : Math.min(v / y.x, E / y.y);
      l.push(this.moveTo(d.x, d.y, d.z, t)), l.push(this.zoomTo(P, t)), l.push(this.setFocalOffset(0, 0, 0, t));
    }
    return Promise.all(l);
  }
  /**
   * Fit the viewport to the sphere or the bounding sphere of the object.
   * @param sphereOrMesh
   * @param enableTransition
   * @category Methods
   */
  fitToSphere(e, t) {
    const n = [], i = "isObject3D" in e ? at.createBoundingSphere(e, Bi) : Bi.copy(e);
    if (n.push(this.moveTo(i.center.x, i.center.y, i.center.z, t)), In(this._camera)) {
      const r = this.getDistanceToFitSphere(i.radius);
      n.push(this.dollyTo(r, t));
    } else if (yn(this._camera)) {
      const r = this._camera.right - this._camera.left, a = this._camera.top - this._camera.bottom, l = 2 * i.radius, c = Math.min(r / l, a / l);
      n.push(this.zoomTo(c, t));
    }
    return n.push(this.setFocalOffset(0, 0, 0, t)), Promise.all(n);
  }
  /**
   * Look at the `target` from the `position`.
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setLookAt(e, t, n, s, i, r, a = !1) {
    this._isUserControllingRotate = !1, this._isUserControllingDolly = !1, this._isUserControllingTruck = !1, this._lastDollyDirection = Vn.NONE, this._changedDolly = 0;
    const l = ke.set(s, i, r), c = Se.set(e, t, n);
    this._targetEnd.copy(l), this._sphericalEnd.setFromVector3(c.sub(l).applyQuaternion(this._yAxisUpSpace)), this.normalizeRotations(), this._needsUpdate = !0, a || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));
    const h = !a || Ne(this._target.x, this._targetEnd.x, this.restThreshold) && Ne(this._target.y, this._targetEnd.y, this.restThreshold) && Ne(this._target.z, this._targetEnd.z, this.restThreshold) && Ne(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && Ne(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && Ne(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(h);
  }
  /**
   * Similar to setLookAt, but it interpolates between two states.
   * @param positionAX
   * @param positionAY
   * @param positionAZ
   * @param targetAX
   * @param targetAY
   * @param targetAZ
   * @param positionBX
   * @param positionBY
   * @param positionBZ
   * @param targetBX
   * @param targetBY
   * @param targetBZ
   * @param t
   * @param enableTransition
   * @category Methods
   */
  lerpLookAt(e, t, n, s, i, r, a, l, c, h, u, p, f, g = !1) {
    this._isUserControllingRotate = !1, this._isUserControllingDolly = !1, this._isUserControllingTruck = !1, this._lastDollyDirection = Vn.NONE, this._changedDolly = 0;
    const m = Se.set(s, i, r), y = ke.set(e, t, n);
    bt.setFromVector3(y.sub(m).applyQuaternion(this._yAxisUpSpace));
    const d = Xn.set(h, u, p), w = ke.set(a, l, c);
    fs.setFromVector3(w.sub(d).applyQuaternion(this._yAxisUpSpace)), this._targetEnd.copy(m.lerp(d, f));
    const v = fs.theta - bt.theta, E = fs.phi - bt.phi, P = fs.radius - bt.radius;
    this._sphericalEnd.set(bt.radius + P * f, bt.phi + E * f, bt.theta + v * f), this.normalizeRotations(), this._needsUpdate = !0, g || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));
    const T = !g || Ne(this._target.x, this._targetEnd.x, this.restThreshold) && Ne(this._target.y, this._targetEnd.y, this.restThreshold) && Ne(this._target.z, this._targetEnd.z, this.restThreshold) && Ne(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && Ne(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && Ne(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(T);
  }
  /**
   * Set angle and distance by given position.
   * An alias of `setLookAt()`, without target change. Thus keep gazing at the current target
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param enableTransition
   * @category Methods
   */
  setPosition(e, t, n, s = !1) {
    return this.setLookAt(e, t, n, this._targetEnd.x, this._targetEnd.y, this._targetEnd.z, s);
  }
  /**
   * Set the target position where gaze at.
   * An alias of `setLookAt()`, without position change. Thus keep the same position.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setTarget(e, t, n, s = !1) {
    const i = this.getPosition(Se), r = this.setLookAt(i.x, i.y, i.z, e, t, n, s);
    return this._sphericalEnd.phi = Dt(this._sphericalEnd.phi, this.minPolarAngle, this.maxPolarAngle), r;
  }
  /**
   * Set focal offset using the screen parallel coordinates. z doesn't affect in Orthographic as with Dolly.
   * @param x
   * @param y
   * @param z
   * @param enableTransition
   * @category Methods
   */
  setFocalOffset(e, t, n, s = !1) {
    this._isUserControllingOffset = !1, this._focalOffsetEnd.set(e, t, n), this._needsUpdate = !0, s || this._focalOffset.copy(this._focalOffsetEnd);
    const i = !s || Ne(this._focalOffset.x, this._focalOffsetEnd.x, this.restThreshold) && Ne(this._focalOffset.y, this._focalOffsetEnd.y, this.restThreshold) && Ne(this._focalOffset.z, this._focalOffsetEnd.z, this.restThreshold);
    return this._createOnRestPromise(i);
  }
  /**
   * Set orbit point without moving the camera.
   * SHOULD NOT RUN DURING ANIMATIONS. `setOrbitPoint()` will immediately fix the positions.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @category Methods
   */
  setOrbitPoint(e, t, n) {
    this._camera.updateMatrixWorld(), kt.setFromMatrixColumn(this._camera.matrixWorldInverse, 0), Bt.setFromMatrixColumn(this._camera.matrixWorldInverse, 1), On.setFromMatrixColumn(this._camera.matrixWorldInverse, 2);
    const s = Se.set(e, t, n), i = s.distanceTo(this._camera.position), r = s.sub(this._camera.position);
    kt.multiplyScalar(r.x), Bt.multiplyScalar(r.y), On.multiplyScalar(r.z), Se.copy(kt).add(Bt).add(On), Se.z = Se.z + i, this.dollyTo(i, !1), this.setFocalOffset(-Se.x, Se.y, -Se.z, !1), this.moveTo(e, t, n, !1);
  }
  /**
   * Set the boundary box that encloses the target of the camera. box3 is in THREE.Box3
   * @param box3
   * @category Methods
   */
  setBoundary(e) {
    if (!e) {
      this._boundary.min.set(-1 / 0, -1 / 0, -1 / 0), this._boundary.max.set(1 / 0, 1 / 0, 1 / 0), this._needsUpdate = !0;
      return;
    }
    this._boundary.copy(e), this._boundary.clampPoint(this._targetEnd, this._targetEnd), this._needsUpdate = !0;
  }
  /**
   * Set (or unset) the current viewport.
   * Set this when you want to use renderer viewport and .dollyToCursor feature at the same time.
   * @param viewportOrX
   * @param y
   * @param width
   * @param height
   * @category Methods
   */
  setViewport(e, t, n, s) {
    if (e === null) {
      this._viewport = null;
      return;
    }
    this._viewport = this._viewport || new we.Vector4(), typeof e == "number" ? this._viewport.set(e, t, n, s) : this._viewport.copy(e);
  }
  /**
   * Calculate the distance to fit the box.
   * @param width box width
   * @param height box height
   * @param depth box depth
   * @returns distance
   * @category Methods
   */
  getDistanceToFitBox(e, t, n, s = !1) {
    if (Li(this._camera, "getDistanceToFitBox"))
      return this._spherical.radius;
    const i = e / t, r = this._camera.getEffectiveFOV() * ls, a = this._camera.aspect;
    return ((s ? i > a : i < a) ? t : e / a) * 0.5 / Math.tan(r * 0.5) + n * 0.5;
  }
  /**
   * Calculate the distance to fit the sphere.
   * @param radius sphere radius
   * @returns distance
   * @category Methods
   */
  getDistanceToFitSphere(e) {
    if (Li(this._camera, "getDistanceToFitSphere"))
      return this._spherical.radius;
    const t = this._camera.getEffectiveFOV() * ls, n = Math.atan(Math.tan(t * 0.5) * this._camera.aspect) * 2, s = 1 < this._camera.aspect ? t : n;
    return e / Math.sin(s * 0.5);
  }
  /**
   * Returns the orbit center position, where the camera looking at.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getTarget(e, t = !0) {
    return (e && e.isVector3 ? e : new we.Vector3()).copy(t ? this._targetEnd : this._target);
  }
  /**
   * Returns the camera position.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getPosition(e, t = !0) {
    return (e && e.isVector3 ? e : new we.Vector3()).setFromSpherical(t ? this._sphericalEnd : this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(t ? this._targetEnd : this._target);
  }
  /**
   * Returns the spherical coordinates of the orbit.
   * @param out The receiving Spherical instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getSpherical(e, t = !0) {
    return (e || new we.Spherical()).copy(t ? this._sphericalEnd : this._spherical);
  }
  /**
   * Returns the focal offset, which is how much the camera appears to be translated in screen parallel coordinates.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getFocalOffset(e, t = !0) {
    return (e && e.isVector3 ? e : new we.Vector3()).copy(t ? this._focalOffsetEnd : this._focalOffset);
  }
  /**
   * Normalize camera azimuth angle rotation between 0 and 360 degrees.
   * @category Methods
   */
  normalizeRotations() {
    this._sphericalEnd.theta = this._sphericalEnd.theta % Yn, this._sphericalEnd.theta < 0 && (this._sphericalEnd.theta += Yn), this._spherical.theta += Yn * Math.round((this._sphericalEnd.theta - this._spherical.theta) / Yn);
  }
  /**
   * stop all transitions.
   */
  stop() {
    this._focalOffset.copy(this._focalOffsetEnd), this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd), this._zoom = this._zoomEnd;
  }
  /**
   * Reset all rotation and position to defaults.
   * @param enableTransition
   * @category Methods
   */
  reset(e = !1) {
    if (!Ne(this._camera.up.x, this._cameraUp0.x) || !Ne(this._camera.up.y, this._cameraUp0.y) || !Ne(this._camera.up.z, this._cameraUp0.z)) {
      this._camera.up.copy(this._cameraUp0);
      const n = this.getPosition(Se);
      this.updateCameraUp(), this.setPosition(n.x, n.y, n.z);
    }
    const t = [
      this.setLookAt(this._position0.x, this._position0.y, this._position0.z, this._target0.x, this._target0.y, this._target0.z, e),
      this.setFocalOffset(this._focalOffset0.x, this._focalOffset0.y, this._focalOffset0.z, e),
      this.zoomTo(this._zoom0, e)
    ];
    return Promise.all(t);
  }
  /**
   * Set current camera position as the default position.
   * @category Methods
   */
  saveState() {
    this._cameraUp0.copy(this._camera.up), this.getTarget(this._target0), this.getPosition(this._position0), this._zoom0 = this._zoom, this._focalOffset0.copy(this._focalOffset);
  }
  /**
   * Sync camera-up direction.
   * When camera-up vector is changed, `.updateCameraUp()` must be called.
   * @category Methods
   */
  updateCameraUp() {
    this._yAxisUpSpace.setFromUnitVectors(this._camera.up, Ks), this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace).invert();
  }
  /**
   * Apply current camera-up direction to the camera.
   * The orbit system will be re-initialized with the current position.
   * @category Methods
   */
  applyCameraUp() {
    const e = Se.subVectors(this._target, this._camera.position).normalize(), t = ke.crossVectors(e, this._camera.up);
    this._camera.up.crossVectors(t, e).normalize(), this._camera.updateMatrixWorld();
    const n = this.getPosition(Se);
    this.updateCameraUp(), this.setPosition(n.x, n.y, n.z);
  }
  /**
   * Update camera position and directions.
   * This should be called in your tick loop every time, and returns true if re-rendering is needed.
   * @param delta
   * @returns updated
   * @category Methods
   */
  update(e) {
    const t = this._sphericalEnd.theta - this._spherical.theta, n = this._sphericalEnd.phi - this._spherical.phi, s = this._sphericalEnd.radius - this._spherical.radius, i = bo.subVectors(this._targetEnd, this._target), r = Eo.subVectors(this._focalOffsetEnd, this._focalOffset), a = this._zoomEnd - this._zoom;
    if (Ge(t))
      this._thetaVelocity.value = 0, this._spherical.theta = this._sphericalEnd.theta;
    else {
      const u = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.theta = $s(this._spherical.theta, this._sphericalEnd.theta, this._thetaVelocity, u, 1 / 0, e), this._needsUpdate = !0;
    }
    if (Ge(n))
      this._phiVelocity.value = 0, this._spherical.phi = this._sphericalEnd.phi;
    else {
      const u = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.phi = $s(this._spherical.phi, this._sphericalEnd.phi, this._phiVelocity, u, 1 / 0, e), this._needsUpdate = !0;
    }
    if (Ge(s))
      this._radiusVelocity.value = 0, this._spherical.radius = this._sphericalEnd.radius;
    else {
      const u = this._isUserControllingDolly ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.radius = $s(this._spherical.radius, this._sphericalEnd.radius, this._radiusVelocity, u, this.maxSpeed, e), this._needsUpdate = !0;
    }
    if (Ge(i.x) && Ge(i.y) && Ge(i.z))
      this._targetVelocity.set(0, 0, 0), this._target.copy(this._targetEnd);
    else {
      const u = this._isUserControllingTruck ? this.draggingSmoothTime : this.smoothTime;
      wo(this._target, this._targetEnd, this._targetVelocity, u, this.maxSpeed, e, this._target), this._needsUpdate = !0;
    }
    if (Ge(r.x) && Ge(r.y) && Ge(r.z))
      this._focalOffsetVelocity.set(0, 0, 0), this._focalOffset.copy(this._focalOffsetEnd);
    else {
      const u = this._isUserControllingOffset ? this.draggingSmoothTime : this.smoothTime;
      wo(this._focalOffset, this._focalOffsetEnd, this._focalOffsetVelocity, u, this.maxSpeed, e, this._focalOffset), this._needsUpdate = !0;
    }
    if (Ge(a))
      this._zoomVelocity.value = 0, this._zoom = this._zoomEnd;
    else {
      const u = this._isUserControllingZoom ? this.draggingSmoothTime : this.smoothTime;
      this._zoom = $s(this._zoom, this._zoomEnd, this._zoomVelocity, u, 1 / 0, e);
    }
    if (this.dollyToCursor) {
      if (In(this._camera) && this._changedDolly !== 0) {
        const u = this._spherical.radius - this._lastDistance, p = this._camera, f = this._getCameraDirection(hs), g = Se.copy(f).cross(p.up).normalize();
        g.lengthSq() === 0 && (g.x = 1);
        const m = ke.crossVectors(g, f), y = this._sphericalEnd.radius * Math.tan(p.getEffectiveFOV() * ls * 0.5), w = (this._sphericalEnd.radius - u - this._sphericalEnd.radius) / this._sphericalEnd.radius, v = Xn.copy(this._targetEnd).add(g.multiplyScalar(this._dollyControlCoord.x * y * p.aspect)).add(m.multiplyScalar(this._dollyControlCoord.y * y)), E = Se.copy(this._targetEnd).lerp(v, w), P = this._lastDollyDirection === Vn.IN && this._spherical.radius <= this.minDistance, T = this._lastDollyDirection === Vn.OUT && this.maxDistance <= this._spherical.radius;
        if (this.infinityDolly && (P || T)) {
          this._sphericalEnd.radius -= u, this._spherical.radius -= u;
          const x = ke.copy(f).multiplyScalar(-u);
          E.add(x);
        }
        this._boundary.clampPoint(E, E);
        const b = ke.subVectors(E, this._targetEnd);
        this._targetEnd.copy(E), this._target.add(b), this._changedDolly -= u, Ge(this._changedDolly) && (this._changedDolly = 0);
      } else if (yn(this._camera) && this._changedZoom !== 0) {
        const u = this._zoom - this._lastZoom, p = this._camera, f = Se.set(this._dollyControlCoord.x, this._dollyControlCoord.y, (p.near + p.far) / (p.near - p.far)).unproject(p), g = ke.set(0, 0, -1).applyQuaternion(p.quaternion), m = Xn.copy(f).add(g.multiplyScalar(-f.dot(p.up))), d = -(this._zoom - u - this._zoom) / this._zoom, w = this._getCameraDirection(hs), v = this._targetEnd.dot(w), E = Se.copy(this._targetEnd).lerp(m, d), P = E.dot(w), T = w.multiplyScalar(P - v);
        E.sub(T), this._boundary.clampPoint(E, E);
        const b = ke.subVectors(E, this._targetEnd);
        this._targetEnd.copy(E), this._target.add(b), this._changedZoom -= u, Ge(this._changedZoom) && (this._changedZoom = 0);
      }
    }
    this._camera.zoom !== this._zoom && (this._camera.zoom = this._zoom, this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = !0), this._dragNeedsUpdate = !0;
    const l = this._collisionTest();
    this._spherical.radius = Math.min(this._spherical.radius, l), this._spherical.makeSafe(), this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target), this._camera.lookAt(this._target), (!Ge(this._focalOffset.x) || !Ge(this._focalOffset.y) || !Ge(this._focalOffset.z)) && (this._camera.updateMatrixWorld(), kt.setFromMatrixColumn(this._camera.matrix, 0), Bt.setFromMatrixColumn(this._camera.matrix, 1), On.setFromMatrixColumn(this._camera.matrix, 2), kt.multiplyScalar(this._focalOffset.x), Bt.multiplyScalar(-this._focalOffset.y), On.multiplyScalar(this._focalOffset.z), Se.copy(kt).add(Bt).add(On), this._camera.position.add(Se)), this._boundaryEnclosesCamera && this._encloseToBoundary(this._camera.position.copy(this._target), Se.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse), 1);
    const h = this._needsUpdate;
    return h && !this._updatedLastTime ? (this._hasRested = !1, this.dispatchEvent({ type: "wake" }), this.dispatchEvent({ type: "update" })) : h ? (this.dispatchEvent({ type: "update" }), Ge(t, this.restThreshold) && Ge(n, this.restThreshold) && Ge(s, this.restThreshold) && Ge(i.x, this.restThreshold) && Ge(i.y, this.restThreshold) && Ge(i.z, this.restThreshold) && Ge(r.x, this.restThreshold) && Ge(r.y, this.restThreshold) && Ge(r.z, this.restThreshold) && Ge(a, this.restThreshold) && !this._hasRested && (this._hasRested = !0, this.dispatchEvent({ type: "rest" }))) : !h && this._updatedLastTime && this.dispatchEvent({ type: "sleep" }), this._lastDistance = this._spherical.radius, this._lastZoom = this._zoom, this._updatedLastTime = h, this._needsUpdate = !1, h;
  }
  /**
   * Get all state in JSON string
   * @category Methods
   */
  toJSON() {
    return JSON.stringify({
      enabled: this._enabled,
      minDistance: this.minDistance,
      maxDistance: cs(this.maxDistance),
      minZoom: this.minZoom,
      maxZoom: cs(this.maxZoom),
      minPolarAngle: this.minPolarAngle,
      maxPolarAngle: cs(this.maxPolarAngle),
      minAzimuthAngle: cs(this.minAzimuthAngle),
      maxAzimuthAngle: cs(this.maxAzimuthAngle),
      smoothTime: this.smoothTime,
      draggingSmoothTime: this.draggingSmoothTime,
      dollySpeed: this.dollySpeed,
      truckSpeed: this.truckSpeed,
      dollyToCursor: this.dollyToCursor,
      verticalDragToForward: this.verticalDragToForward,
      target: this._targetEnd.toArray(),
      position: Se.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(),
      zoom: this._zoomEnd,
      focalOffset: this._focalOffsetEnd.toArray(),
      target0: this._target0.toArray(),
      position0: this._position0.toArray(),
      zoom0: this._zoom0,
      focalOffset0: this._focalOffset0.toArray()
    });
  }
  /**
   * Reproduce the control state with JSON. enableTransition is where anim or not in a boolean.
   * @param json
   * @param enableTransition
   * @category Methods
   */
  fromJSON(e, t = !1) {
    const n = JSON.parse(e);
    this.enabled = n.enabled, this.minDistance = n.minDistance, this.maxDistance = us(n.maxDistance), this.minZoom = n.minZoom, this.maxZoom = us(n.maxZoom), this.minPolarAngle = n.minPolarAngle, this.maxPolarAngle = us(n.maxPolarAngle), this.minAzimuthAngle = us(n.minAzimuthAngle), this.maxAzimuthAngle = us(n.maxAzimuthAngle), this.smoothTime = n.smoothTime, this.draggingSmoothTime = n.draggingSmoothTime, this.dollySpeed = n.dollySpeed, this.truckSpeed = n.truckSpeed, this.dollyToCursor = n.dollyToCursor, this.verticalDragToForward = n.verticalDragToForward, this._target0.fromArray(n.target0), this._position0.fromArray(n.position0), this._zoom0 = n.zoom0, this._focalOffset0.fromArray(n.focalOffset0), this.moveTo(n.target[0], n.target[1], n.target[2], t), bt.setFromVector3(Se.fromArray(n.position).sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace)), this.rotateTo(bt.theta, bt.phi, t), this.dollyTo(bt.radius, t), this.zoomTo(n.zoom, t), this.setFocalOffset(n.focalOffset[0], n.focalOffset[1], n.focalOffset[2], t), this._needsUpdate = !0;
  }
  /**
   * Attach all internal event handlers to enable drag control.
   * @category Methods
   */
  connect(e) {
    if (this._domElement) {
      console.warn("camera-controls is already connected.");
      return;
    }
    e.setAttribute("data-camera-controls-version", pf), this._addAllEventListeners(e), this._getClientRect(this._elementRect);
  }
  /**
   * Detach all internal event handlers to disable drag control.
   */
  disconnect() {
    this.cancel(), this._removeAllEventListeners(), this._domElement && (this._domElement.removeAttribute("data-camera-controls-version"), this._domElement = void 0);
  }
  /**
   * Dispose the cameraControls instance itself, remove all eventListeners.
   * @category Methods
   */
  dispose() {
    this.removeAllEventListeners(), this.disconnect();
  }
  // it's okay to expose public though
  _getTargetDirection(e) {
    return e.setFromSpherical(this._spherical).divideScalar(this._spherical.radius).applyQuaternion(this._yAxisUpSpaceInverse);
  }
  // it's okay to expose public though
  _getCameraDirection(e) {
    return this._getTargetDirection(e).negate();
  }
  _findPointerById(e) {
    return this._activePointers.find((t) => t.pointerId === e);
  }
  _findPointerByMouseButton(e) {
    return this._activePointers.find((t) => t.mouseButton === e);
  }
  _disposePointer(e) {
    this._activePointers.splice(this._activePointers.indexOf(e), 1);
  }
  _encloseToBoundary(e, t, n) {
    const s = t.lengthSq();
    if (s === 0)
      return e;
    const i = ke.copy(t).add(e), a = this._boundary.clampPoint(i, Xn).sub(i), l = a.lengthSq();
    if (l === 0)
      return e.add(t);
    if (l === s)
      return e;
    if (n === 0)
      return e.add(t).add(a);
    {
      const c = 1 + n * l / t.dot(a);
      return e.add(ke.copy(t).multiplyScalar(c)).add(a.multiplyScalar(1 - n));
    }
  }
  _updateNearPlaneCorners() {
    if (In(this._camera)) {
      const e = this._camera, t = e.near, n = e.getEffectiveFOV() * ls, s = Math.tan(n * 0.5) * t, i = s * e.aspect;
      this._nearPlaneCorners[0].set(-i, -s, 0), this._nearPlaneCorners[1].set(i, -s, 0), this._nearPlaneCorners[2].set(i, s, 0), this._nearPlaneCorners[3].set(-i, s, 0);
    } else if (yn(this._camera)) {
      const e = this._camera, t = 1 / e.zoom, n = e.left * t, s = e.right * t, i = e.top * t, r = e.bottom * t;
      this._nearPlaneCorners[0].set(n, i, 0), this._nearPlaneCorners[1].set(s, i, 0), this._nearPlaneCorners[2].set(s, r, 0), this._nearPlaneCorners[3].set(n, r, 0);
    }
  }
  // lateUpdate
  _collisionTest() {
    let e = 1 / 0;
    if (!(this.colliderMeshes.length >= 1) || Li(this._camera, "_collisionTest"))
      return e;
    const n = this._getTargetDirection(hs);
    Ui.lookAt(To, n, this._camera.up);
    for (let s = 0; s < 4; s++) {
      const i = ke.copy(this._nearPlaneCorners[s]);
      i.applyMatrix4(Ui);
      const r = Xn.addVectors(this._target, i);
      qs.set(r, n), qs.far = this._spherical.radius + 1;
      const a = qs.intersectObjects(this.colliderMeshes);
      a.length !== 0 && a[0].distance < e && (e = a[0].distance);
    }
    return e;
  }
  /**
   * Get its client rect and package into given `DOMRect` .
   */
  _getClientRect(e) {
    if (!this._domElement)
      return;
    const t = this._domElement.getBoundingClientRect();
    return e.x = t.left, e.y = t.top, this._viewport ? (e.x += this._viewport.x, e.y += t.height - this._viewport.w - this._viewport.y, e.width = this._viewport.z, e.height = this._viewport.w) : (e.width = t.width, e.height = t.height), e;
  }
  _createOnRestPromise(e) {
    return e ? Promise.resolve() : (this._hasRested = !1, this.dispatchEvent({ type: "transitionstart" }), new Promise((t) => {
      const n = () => {
        this.removeEventListener("rest", n), t();
      };
      this.addEventListener("rest", n);
    }));
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _addAllEventListeners(e) {
  }
  _removeAllEventListeners() {
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  get dampingFactor() {
    return console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead."), 0;
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  set dampingFactor(e) {
    console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead.");
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  get draggingDampingFactor() {
    return console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead."), 0;
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  set draggingDampingFactor(e) {
    console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.");
  }
  static createBoundingSphere(e, t = new we.Sphere()) {
    const n = t, s = n.center;
    Wn.makeEmpty(), e.traverseVisible((r) => {
      r.isMesh && Wn.expandByObject(r);
    }), Wn.getCenter(s);
    let i = 0;
    return e.traverseVisible((r) => {
      if (!r.isMesh)
        return;
      const a = r, l = a.geometry.clone();
      l.applyMatrix4(a.matrixWorld);
      const h = l.attributes.position;
      for (let u = 0, p = h.count; u < p; u++)
        Se.fromBufferAttribute(h, u), i = Math.max(i, s.distanceToSquared(Se));
    }), n.radius = Math.sqrt(i), n;
  }
}
const sl = (o) => !!(o && o.isPerspectiveCamera), il = (o) => !!(o && o.isOrthographicCamera), gf = ["min-polar-angle", "max-polar-angle", "min-azimuth-angle", "max-azimuth-angle", "distance", "min-distance", "max-distance", "infinity-dolly", "min-zoom", "max-zoom", "smooth-time", "dragging-smooth-time", "max-speed", "azimuth-rotate-speed", "polar-rotate-speed", "dolly-speed", "dolly-drag-inverted", "truck-speed", "dolly-to-cursor", "drag-to-offset", "vertical-drag-to-forward", "boundary-friction", "rest-threshold", "collider-meshes", "args", "mouse-buttons", "touches"], Ao = (o, e) => ({
  left: at.ACTION.ROTATE,
  middle: at.ACTION.DOLLY,
  right: at.ACTION.TRUCK,
  wheel: sl(o) ? at.ACTION.DOLLY : il(o) ? at.ACTION.ZOOM : at.ACTION.NONE,
  ...e
}), Po = (o, e) => ({
  one: at.ACTION.TOUCH_ROTATE,
  two: sl(o) ? at.ACTION.TOUCH_DOLLY_TRUCK : il(o) ? at.ACTION.TOUCH_ZOOM_TRUCK : at.ACTION.NONE,
  three: at.ACTION.TOUCH_TRUCK,
  ...e
}), kg = /* @__PURE__ */ me({
  __name: "CameraControls",
  props: {
    makeDefault: { type: Boolean, default: !1 },
    camera: {},
    domElement: {},
    minPolarAngle: { default: 0 },
    maxPolarAngle: { default: Math.PI },
    minAzimuthAngle: { default: Number.NEGATIVE_INFINITY },
    maxAzimuthAngle: { default: Number.POSITIVE_INFINITY },
    distance: { default: () => ve().camera.value.position.z },
    minDistance: { default: Number.EPSILON },
    maxDistance: { default: Number.POSITIVE_INFINITY },
    infinityDolly: { type: Boolean, default: !1 },
    minZoom: { default: 0.01 },
    maxZoom: { default: Number.POSITIVE_INFINITY },
    smoothTime: { default: 0.25 },
    draggingSmoothTime: { default: 0.125 },
    maxSpeed: { default: Number.POSITIVE_INFINITY },
    azimuthRotateSpeed: { default: 1 },
    polarRotateSpeed: { default: 1 },
    dollySpeed: { default: 1 },
    dollyDragInverted: { type: Boolean, default: !1 },
    truckSpeed: { default: 2 },
    dollyToCursor: { type: Boolean, default: !1 },
    dragToOffset: { type: Boolean, default: !1 },
    verticalDragToForward: { type: Boolean, default: !1 },
    boundaryFriction: { default: 0 },
    restThreshold: { default: 0.01 },
    colliderMeshes: { default: () => [] },
    mouseButtons: { default: () => Ao(ve().camera.value) },
    touches: { default: () => Po(ve().camera.value) }
  },
  emits: ["change", "start", "end"],
  setup(o, { expose: e, emit: t }) {
    const n = o, s = t, {
      makeDefault: i,
      minPolarAngle: r,
      maxPolarAngle: a,
      minAzimuthAngle: l,
      maxAzimuthAngle: c,
      distance: h,
      minDistance: u,
      maxDistance: p,
      infinityDolly: f,
      minZoom: g,
      maxZoom: m,
      smoothTime: y,
      draggingSmoothTime: d,
      maxSpeed: w,
      azimuthRotateSpeed: v,
      polarRotateSpeed: E,
      dollySpeed: P,
      dollyDragInverted: T,
      truckSpeed: b,
      dollyToCursor: x,
      dragToOffset: M,
      verticalDragToForward: _,
      boundaryFriction: C,
      restThreshold: R,
      colliderMeshes: B
    } = De(n), N = {
      Box3: Mt,
      MathUtils: {
        clamp: Ze.clamp
      },
      Matrix4: Re,
      Quaternion: ze,
      Raycaster: da,
      Sphere: mi,
      Spherical: oi,
      Vector2: ge,
      Vector3: $,
      Vector4: it
    };
    at.install({ THREE: N });
    const { camera: j, renderer: V, extend: Q, controls: Z, invalidate: ne } = ve();
    ee(n, () => {
      ne();
    });
    const te = Fe(() => Ao(
      n.camera || j.value,
      n.mouseButtons
    )), le = Fe(() => Po(
      n.camera || j.value,
      n.touches
    )), ae = fe(null);
    Q({ CameraControls: at }), Ft(() => {
      Te(), ae.value && i.value ? Z.value = ae.value : Z.value = null;
    });
    function Te() {
      He(ae.value, "update", () => {
        s("change", ae.value), ne();
      }), He(ae.value, "controlend", () => s("end", ae.value)), He(ae.value, "controlstart", () => s("start", ae.value));
    }
    const { onBeforeRender: I } = Ke();
    return I(({ delta: k, invalidate: D }) => {
      var O, z;
      (O = ae.value) != null && O.enabled && ((z = ae.value) == null || z.update(k), D());
    }), rt(() => {
      ae.value && ae.value.disconnect();
    }), e({
      instance: ae
    }), (k, D) => (k.camera || U(j)) && (k.domElement || U(V)) ? (ue(), de("TresCameraControls", {
      key: 0,
      ref_key: "controlsRef",
      ref: ae,
      "min-polar-angle": U(r),
      "max-polar-angle": U(a),
      "min-azimuth-angle": U(l),
      "max-azimuth-angle": U(c),
      distance: U(h),
      "min-distance": U(u),
      "max-distance": U(p),
      "infinity-dolly": U(f),
      "min-zoom": U(g),
      "max-zoom": U(m),
      "smooth-time": U(y),
      "dragging-smooth-time": U(d),
      "max-speed": U(w),
      "azimuth-rotate-speed": U(v),
      "polar-rotate-speed": U(E),
      "dolly-speed": U(P),
      "dolly-drag-inverted": U(T),
      "truck-speed": U(b),
      "dolly-to-cursor": U(x),
      "drag-to-offset": U(M),
      "vertical-drag-to-forward": U(_),
      "boundary-friction": U(C),
      "rest-threshold": U(R),
      "collider-meshes": U(B),
      args: [k.camera || U(j), k.domElement || U(V).domElement],
      "mouse-buttons": te.value,
      touches: le.value
    }, null, 8, gf)) : rn("", !0);
  }
}), Bg = /* @__PURE__ */ me({
  __name: "KeyboardControls",
  props: {
    makeDefault: { type: Boolean, default: !0 },
    camera: {},
    domElement: {},
    moveSpeed: { default: 0.2 },
    selector: {}
  },
  emits: ["isLock", "change"],
  setup(o, { expose: e, emit: t }) {
    const n = o, s = t, { moveSpeed: i } = De(n), { camera: r, controls: a, renderer: l, invalidate: c } = ve();
    ee(n, () => {
      c();
    });
    const h = fe(0), u = fe(0), { w: p, s: f, a: g, d: m, Up: y, Down: d, Left: w, Right: v } = tu();
    Ft(() => {
      g.value || w.value ? h.value = -i.value : m.value || v.value ? h.value = i.value : h.value = 0, p.value || y.value ? u.value = i.value : f.value || d.value ? u.value = -i.value : u.value = 0;
    }), e({
      instance: a
    });
    const E = (C) => s("isLock", C), P = (C) => s("change", C), T = new $(), b = new $(), x = new ze(), M = (C, R) => {
      var j;
      if (!((j = r.value) != null && j.position) && !T)
        return;
      const B = r.value, N = C * 1e-3;
      B == null || B.translateZ(-R), x.set(b.x * N, b.y * N, b.z * N, 1).normalize(), B == null || B.quaternion.multiply(x), (h.value || u.value) && s("change", a.value);
    }, { onBeforeRender: _ } = Ke();
    return _(({ delta: C, invalidate: R }) => {
      var B;
      a.value instanceof $a && ((B = a.value) != null && B.isLocked) && (M(C, u.value), a.value.moveRight(h.value), R());
    }), (C, R) => (ue(), Pr(U(xf), {
      selector: C.selector,
      "make-default": C.makeDefault,
      camera: C.camera || U(r),
      "dom-element": C.domElement || U(l).domElement,
      onIsLock: E,
      onChange: P
    }, null, 8, ["selector", "make-default", "camera", "dom-element"]));
  }
}), yf = ["args", "auto-rotate", "auto-rotate-speed", "enable-damping", "damping-factor", "enable-pan", "key-pan-speed", "keys", "max-azimuth-angle", "min-azimuth-angle", "max-polar-angle", "min-polar-angle", "min-distance", "max-distance", "min-zoom", "max-zoom", "enable-zoom", "zoom-speed", "enable-rotate", "rotate-speed"], Ng = /* @__PURE__ */ me({
  __name: "MapControls",
  props: {
    makeDefault: { type: Boolean, default: !1 },
    camera: {},
    domElement: {},
    target: {},
    enableDamping: { type: Boolean, default: !0 },
    dampingFactor: { default: 0.05 },
    autoRotate: { type: Boolean, default: !1 },
    autoRotateSpeed: { default: 2 },
    enablePan: { type: Boolean, default: !0 },
    keyPanSpeed: { default: 7 },
    keys: {},
    maxAzimuthAngle: { default: Number.POSITIVE_INFINITY },
    minAzimuthAngle: { default: Number.NEGATIVE_INFINITY },
    maxPolarAngle: { default: Math.PI },
    minPolarAngle: { default: 0 },
    minDistance: { default: 0 },
    maxDistance: { default: Number.POSITIVE_INFINITY },
    minZoom: { default: 0 },
    maxZoom: { default: Number.POSITIVE_INFINITY },
    touches: {},
    enableZoom: { type: Boolean, default: !0 },
    zoomSpeed: { default: 1 },
    enableRotate: { type: Boolean, default: !0 },
    rotateSpeed: { default: 1 }
  },
  emits: ["change", "start", "end"],
  setup(o, { expose: e, emit: t }) {
    const n = o, {
      autoRotate: s,
      autoRotateSpeed: i,
      enableDamping: r,
      dampingFactor: a,
      enablePan: l,
      keyPanSpeed: c,
      maxAzimuthAngle: h,
      minAzimuthAngle: u,
      maxPolarAngle: p,
      minPolarAngle: f,
      minDistance: g,
      maxDistance: m,
      minZoom: y,
      maxZoom: d,
      enableZoom: w,
      zoomSpeed: v,
      enableRotate: E,
      rotateSpeed: P
    } = De(n), { camera: T, renderer: b, extend: x, controls: M, invalidate: _ } = ve();
    ee(n, () => {
      _();
    });
    const C = fe(null);
    x({ MapControls: Ch }), ee(M, (B) => {
      B && n.makeDefault ? M.value = B : M.value = null;
    });
    const { onBeforeRender: R } = Ke();
    return R(({ invalidate: B }) => {
      C.value && (r.value || s.value) && (C.value.update(), B());
    }), rt(() => {
      C.value && C.value.dispose();
    }), e({
      instance: C
    }), (B, N) => (B.camera || U(T)) && (B.domElement || U(b)) ? (ue(), de("TresMapControls", {
      key: 0,
      ref_key: "controlsRef",
      ref: C,
      args: [B.camera || U(T), B.domElement || U(b).domElement],
      "auto-rotate": U(s),
      "auto-rotate-speed": U(i),
      "enable-damping": U(r),
      "damping-factor": U(a),
      "enable-pan": U(l),
      "key-pan-speed": U(c),
      keys: B.keys,
      "max-azimuth-angle": U(h),
      "min-azimuth-angle": U(u),
      "max-polar-angle": U(p),
      "min-polar-angle": U(f),
      "min-distance": U(g),
      "max-distance": U(m),
      "min-zoom": U(y),
      "max-zoom": U(d),
      "enable-zoom": U(w),
      "zoom-speed": U(v),
      "enable-rotate": U(E),
      "rotate-speed": U(P)
    }, null, 8, yf)) : rn("", !0);
  }
}), vf = ["target", "auto-rotate", "auto-rotate-speed", "enable-damping", "damping-factor", "enable-pan", "key-pan-speed", "keys", "max-azimuth-angle", "min-azimuth-angle", "max-polar-angle", "min-polar-angle", "min-distance", "max-distance", "min-zoom", "max-zoom", "touches", "enable-zoom", "zoom-speed", "enable-rotate", "rotate-speed", "args"], Ug = /* @__PURE__ */ me({
  __name: "OrbitControls",
  props: {
    makeDefault: { type: Boolean, default: !1 },
    camera: {},
    domElement: {},
    target: { default: () => [0, 0, 0] },
    enableDamping: { type: Boolean, default: !0 },
    dampingFactor: { default: 0.05 },
    autoRotate: { type: Boolean, default: !1 },
    autoRotateSpeed: { default: 2 },
    enablePan: { type: Boolean, default: !0 },
    keyPanSpeed: { default: 7 },
    keys: {},
    maxAzimuthAngle: { default: Number.POSITIVE_INFINITY },
    minAzimuthAngle: { default: Number.NEGATIVE_INFINITY },
    maxPolarAngle: { default: Math.PI },
    minPolarAngle: { default: 0 },
    minDistance: { default: 0 },
    maxDistance: { default: Number.POSITIVE_INFINITY },
    minZoom: { default: 0 },
    maxZoom: { default: Number.POSITIVE_INFINITY },
    touches: { default: () => ({ ONE: Ht.ROTATE, TWO: Ht.DOLLY_PAN }) },
    enableZoom: { type: Boolean, default: !0 },
    zoomSpeed: { default: 1 },
    enableRotate: { type: Boolean, default: !0 },
    rotateSpeed: { default: 1 }
  },
  emits: ["change", "start", "end"],
  setup(o, { expose: e, emit: t }) {
    const n = o, s = t, {
      makeDefault: i,
      autoRotate: r,
      autoRotateSpeed: a,
      enableDamping: l,
      dampingFactor: c,
      enablePan: h,
      keyPanSpeed: u,
      maxAzimuthAngle: p,
      minAzimuthAngle: f,
      maxPolarAngle: g,
      minPolarAngle: m,
      minDistance: y,
      maxDistance: d,
      minZoom: w,
      maxZoom: v,
      enableZoom: E,
      zoomSpeed: P,
      enableRotate: T,
      touches: b,
      rotateSpeed: x,
      target: M
    } = De(n), { camera: _, renderer: C, extend: R, controls: B, invalidate: N } = ve(), j = fe(null);
    R({ OrbitControls: Za }), ee(j, (Z) => {
      V(), Z && i.value ? B.value = Z : B.value = null;
    });
    function V() {
      He(j.value, "change", () => {
        s("change", j.value), N();
      }), He(j.value, "start", () => s("start", j.value)), He(j.value, "end", () => s("end", j.value));
    }
    const { onBeforeRender: Q } = Ke();
    return Q(({ invalidate: Z }) => {
      j.value && (l.value || r.value) && (j.value.update(), r.value && Z());
    }), rt(() => {
      j.value && j.value.dispose();
    }), e({ instance: j }), (Z, ne) => (Z.camera || U(_)) && (Z.domElement || U(C)) ? (ue(), de("TresOrbitControls", {
      key: 0,
      ref_key: "controlsRef",
      ref: j,
      target: U(M),
      "auto-rotate": U(r),
      "auto-rotate-speed": U(a),
      "enable-damping": U(l),
      "damping-factor": U(c),
      "enable-pan": U(h),
      "key-pan-speed": U(u),
      keys: Z.keys,
      "max-azimuth-angle": U(p),
      "min-azimuth-angle": U(f),
      "max-polar-angle": U(g),
      "min-polar-angle": U(m),
      "min-distance": U(y),
      "max-distance": U(d),
      "min-zoom": U(w),
      "max-zoom": U(v),
      touches: U(b),
      "enable-zoom": U(E),
      "zoom-speed": U(P),
      "enable-rotate": U(T),
      "rotate-speed": U(x),
      args: [Z.camera || U(_), Z.domElement || U(C).domElement]
    }, null, 8, vf)) : rn("", !0);
  }
}), _f = ["args"], xf = /* @__PURE__ */ me({
  __name: "PointerLockControls",
  props: {
    makeDefault: { type: Boolean, default: !1 },
    camera: {},
    domElement: {},
    selector: {}
  },
  emits: ["isLock", "change"],
  setup(o, { expose: e, emit: t }) {
    const n = o, s = t, { camera: i, renderer: r, extend: a, controls: l, invalidate: c } = ve();
    ee(n, () => {
      c();
    });
    const h = fe(null);
    let u;
    a({ PointerLockControls: $a });
    const p = (f) => {
      s("isLock", f);
    };
    return ee(h, (f) => {
      f && n.makeDefault ? l.value = f : l.value = null, u = document.getElementById(n.selector || "") || r.value.domElement, He(l.value, "change", () => {
        s("change", l.value), c();
      }), He(u, "click", () => {
        var m, y, d;
        (m = h.value) == null || m.lock(), (y = h.value) == null || y.addEventListener("lock", () => p(!0)), (d = h.value) == null || d.addEventListener("unlock", () => p(!1)), c();
      });
    }), rt(() => {
      var f, g;
      (f = l.value) == null || f.removeEventListener("lock", () => p(!0)), (g = l.value) == null || g.removeEventListener("unlock", () => p(!1)), h.value && h.value.dispose();
    }), e({
      instance: l
    }), (f, g) => (f.camera || U(i)) && (f.domElement || U(r)) ? (ue(), de("TresPointerLockControls", {
      key: 0,
      ref_key: "controlsRef",
      ref: h,
      args: [f.camera || U(i), f.domElement || U(r).domElement]
    }, null, 8, _f)) : rn("", !0);
  }
}), zg = /* @__PURE__ */ me({
  __name: "ScrollControls",
  props: {
    pages: { default: 4 },
    distance: { default: 4 },
    smoothScroll: { default: 0.1 },
    horizontal: { type: Boolean, default: !1 },
    htmlScroll: { type: Boolean, default: !1 }
  },
  emits: ["update:modelValue"],
  setup(o, { expose: e, emit: t }) {
    const n = o, s = t, { logWarning: i } = yt();
    n.smoothScroll < 0 && i("SmoothControl must be greater than zero"), n.pages < 0 && i("Pages must be greater than zero");
    const { camera: r, controls: a, renderer: l, invalidate: c } = ve();
    ee(n, () => {
      c();
    });
    const h = ye(), u = document.createElement("div"), { y: p } = iu(), { x: f, y: g, isScrolling: m } = Jc(u), { height: y, width: d } = Oa();
    let w = 0;
    const v = fe(!1), E = fe(0), P = fe(0), T = fe(0), b = n.horizontal ? "x" : "y", x = ee(
      r,
      (_) => {
        if (v.value) {
          x();
          return;
        }
        w = n.horizontal ? (_ == null ? void 0 : _.position.x) || 0 : (_ == null ? void 0 : _.position.y) || 0, v.value = !0;
      },
      {
        immediate: !0
      }
    );
    ee(
      m,
      (_) => {
        a.value && (a.value.enabled = !_);
      },
      {
        immediate: !0
      }
    ), ee(p, (_) => {
      !m.value && !n.htmlScroll || (P.value = _ / y.value / (T.value / y.value - 1), E.value = -1 * P.value, s("update:modelValue", P.value));
    }), ee(g, (_) => {
      P.value = _ / y.value / (T.value / y.value), E.value = -1 * P.value, s("update:modelValue", P.value);
    }), ee(f, (_) => {
      P.value = _ / d.value / (T.value / d.value - 1), E.value = +P.value, s("update:modelValue", P.value);
    }), ee(
      l,
      (_) => {
        var R, B;
        const C = _ == null ? void 0 : _.domElement;
        if (n.htmlScroll && (_ != null && _.domElement))
          C != null && C.style.width && (C != null && C.style.position) && (C != null && C.style.top) && (C != null && C.style.left) && (C.style.width = "100%", C.style.position = "fixed", C.style.zIndex = " -99999", C.style.top = "0", C.style.left = "0"), T.value = document.body.scrollHeight;
        else {
          const N = document.createElement("div"), j = document.createElement("div");
          u.style[n.horizontal ? "overflowX" : "overflowY"] = "auto", u.style[n.horizontal ? "overflowY" : "overflowX"] = "hidden", u.style.position = "absolute", u.style.width = "100%", u.style.height = " 100%", u.style.top = "0", u.style.left = "0", u.classList.add("scrollContainer"), N.style.position = "sticky", N.style.top = "0px", N.style.left = "0px", N.style.width = "100%", N.style.height = "100%", N.style.overflow = "hidden", u.appendChild(N), j.style.height = n.horizontal ? "100%" : `${y.value * n.pages}px`, j.style.width = n.horizontal ? `${d.value * n.pages}px` : "100vw", j.style.pointerEvents = "none", C.style.position = "fixed", C.style.zIndex = "0", C != null && C.style.width && (C.style.width = "100%"), u.appendChild(j), _ != null && _.domElement.parentNode && (_.domElement.parentNode.style.position = "relative"), (B = (R = _ == null ? void 0 : _.domElement) == null ? void 0 : R.parentNode) == null || B.appendChild(u), T.value = n.horizontal ? d.value * n.pages : y.value * n.pages;
        }
      },
      {
        immediate: !0
      }
    );
    const { onBeforeRender: M } = Ke();
    return M(({ invalidate: _ }) => {
      var C;
      if ((C = r.value) != null && C.position) {
        const R = (E.value * n.distance - r.value.position[b] + w) * n.smoothScroll;
        r.value.position[b] += R, h.value.children.length > 0 && (h.value.position[b] += R), _();
      }
    }), e({
      instance: h
    }), (_, C) => (ue(), de("TresGroup", {
      ref_key: "wrapperRef",
      ref: h
    }, [
      je(_.$slots, "default")
    ], 512));
  }
}), wf = ["object", "args", "mode", "enabled", "axis", "translation-snap", "rotation-snap", "scale-snap", "space", "size", "show-x", "show-y", "show-z"], Hg = /* @__PURE__ */ me({
  __name: "TransformControls",
  props: {
    object: {},
    camera: {},
    mode: { default: "translate" },
    enabled: { type: Boolean, default: !0 },
    axis: { default: "XYZ" },
    translationSnap: {},
    rotationSnap: {},
    scaleSnap: {},
    space: { default: "world" },
    size: { default: 1 },
    showX: { type: Boolean, default: !0 },
    showY: { type: Boolean, default: !0 },
    showZ: { type: Boolean, default: !0 }
  },
  emits: ["dragging", "change", "mouseDown", "mouseUp", "objectChange"],
  setup(o, { expose: e, emit: t }) {
    const n = o, s = t, { object: i, mode: r, enabled: a, axis: l, translationSnap: c, rotationSnap: h, scaleSnap: u, space: p, size: f, showX: g, showY: m, showZ: y } = De(n), d = ye(null), { controls: w, camera: v, renderer: E, extend: P, invalidate: T } = ve();
    ee([i, r, a, l, c, h, u, p, f, g, m, y], () => {
      T();
    }), P({ TransformControls: vh });
    const b = () => {
      T(), s("change");
    }, x = (B) => {
      w.value && (w.value.enabled = !B.value), T(), s("dragging", B.value);
    }, M = () => {
      T(), s("mouseDown");
    }, _ = () => {
      T(), s("mouseDown");
    }, C = () => {
      T(), s("objectChange");
    };
    function R() {
      He(d.value, "change", b), He(d.value, "dragging-changed", x), He(d.value, "mouseDown", M), He(d.value, "mouseUp", _), He(d.value, "objectChange", C);
    }
    return ee(d, (B) => {
      B && R();
    }), rt(() => {
      d.value && d.value.dispose();
    }), e({
      instance: d
    }), (B, N) => {
      var j;
      return (B.camera || U(v)) && U(E) ? (ue(), de("TresTransformControls", {
        ref_key: "controlsRef",
        ref: d,
        key: (j = B.camera || U(v)) == null ? void 0 : j.uuid,
        object: U(i),
        args: [B.camera || U(v), U(E).domElement],
        mode: U(r),
        enabled: U(a),
        axis: U(l),
        "translation-snap": U(c),
        "rotation-snap": U(h),
        "scale-snap": U(u),
        space: U(p),
        size: U(f),
        "show-x": U(g),
        "show-y": U(m),
        "show-z": U(y),
        visible: !0
      }, null, 8, wf)) : rn("", !0);
    };
  }
}), Tf = ["geometry", "render-order"], Gg = /* @__PURE__ */ me({
  __name: "component",
  props: {
    src: {},
    skipStrokes: { type: Boolean, default: !1 },
    skipFills: { type: Boolean, default: !1 },
    fillMaterial: {},
    strokeMaterial: {},
    fillMeshProps: {},
    strokeMeshProps: {},
    depth: { default: "renderOrder" }
  },
  setup(o, { expose: e }) {
    const t = o, { src: n, skipStrokes: s, skipFills: i, fillMaterial: r, strokeMaterial: a, fillMeshProps: l, strokeMeshProps: c, depth: h } = De(t), u = ye(), p = ye([]), f = ye([]);
    e({ instance: u }), Ft(async () => g(n.value).then((d) => f.value = d.paths)), ee([i, s, r, a, f], y);
    async function g(d) {
      const w = d.startsWith("<svg") ? encodeURI(`data:image/svg+xml;utf8,${d}`) : d;
      return Nn(xs, w);
    }
    rt(m);
    function m() {
      p.value.forEach((d) => d.geometry.dispose());
    }
    function y() {
      var P, T, b;
      m();
      const d = [], [w, v] = (() => {
        const x = { flat: !1, renderOrder: !1, offsetZ: !0 }, M = { flat: 0, renderOrder: 0, offsetZ: 0.025 }, _ = h.value;
        return typeof _ == "number" ? [!0, _] : [x[_], M[_]];
      })();
      let E = 0;
      for (const x of f.value) {
        const M = ((P = x.userData) == null ? void 0 : P.style) ?? {}, _ = Object.assign({
          color: M.fill,
          opacity: M.fillOpacity,
          transparent: !0,
          side: tn,
          depthWrite: w
        }, t.fillMaterial);
        if (!i.value && M.fill !== void 0 && M.fill !== "none")
          for (const C of xs.createShapes(x)) {
            const R = new jl(C);
            R.scale(1, -1, 1), v && R.translate(0, 0, E++ * v), d.push({
              geometry: R,
              material: _,
              isStroke: !1
            });
          }
        if (!s.value && M.stroke !== void 0 && M.stroke !== "none") {
          const C = Object.assign({
            color: (T = x.userData) == null ? void 0 : T.style.stroke,
            opacity: (b = x.userData) == null ? void 0 : b.style.strokeOpacity,
            transparent: !0,
            side: tn,
            depthWrite: w
          }, t.strokeMaterial);
          for (const R of x.subPaths) {
            const B = R.getPoints().map((j) => new ge(j.x, -j.y)), N = xs.pointsToStroke(B, M || "none");
            v && N.translate(0, 0, E++ * v), d.push({
              geometry: N,
              material: C,
              isStroke: !0
            });
          }
        }
      }
      p.value = d;
    }
    return (d, w) => (ue(), de("TresGroup", {
      ref_key: "svgRef",
      ref: u
    }, [
      (ue(!0), de(Sa, null, Aa(p.value, ({ geometry: v, material: E, isStroke: P }, T) => (ue(), de("TresMesh", Xe({
        key: `${T}`,
        ref_for: !0
      }, P ? U(c) : U(l), {
        geometry: v,
        "render-order": U(h) === "renderOrder" ? T : 0
      }), [
        _e("TresMeshBasicMaterial", Xe({ ref_for: !0 }, E), null, 16)
      ], 16, Tf))), 128))
    ], 512));
  }
});
async function bf(o) {
  return await Nn(zh, o);
}
const Ef = ["object"], jg = /* @__PURE__ */ me({
  __name: "component",
  props: {
    path: {},
    castShadow: { type: Boolean, default: !1 },
    receiveShadow: { type: Boolean, default: !1 }
  },
  async setup(o, { expose: e }) {
    let t, n;
    const s = o, i = fe();
    e({
      instance: i
    });
    const r = ([t, n] = Pn(() => bf(s.path)), t = await t, n(), t);
    return (s.castShadow || s.receiveShadow) && r.traverse((a) => {
      a.isMesh && (a.castShadow = s.castShadow, a.receiveShadow = s.receiveShadow);
    }), (a, l) => (ue(), de("primitive", Xe({
      ref_key: "modelRef",
      ref: i,
      object: U(r)
    }, a.$attrs), null, 16, Ef));
  }
});
function Co(o, e) {
  if (e === Vl)
    return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), o;
  if (e === cr || e === wa) {
    let t = o.getIndex();
    if (t === null) {
      const r = [], a = o.getAttribute("position");
      if (a !== void 0) {
        for (let l = 0; l < a.count; l++)
          r.push(l);
        o.setIndex(r), t = o.getIndex();
      } else
        return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), o;
    }
    const n = t.count - 2, s = [];
    if (e === cr)
      for (let r = 1; r <= n; r++)
        s.push(t.getX(0)), s.push(t.getX(r)), s.push(t.getX(r + 1));
    else
      for (let r = 0; r < n; r++)
        r % 2 === 0 ? (s.push(t.getX(r)), s.push(t.getX(r + 1)), s.push(t.getX(r + 2))) : (s.push(t.getX(r + 2)), s.push(t.getX(r + 1)), s.push(t.getX(r)));
    s.length / 3 !== n && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    const i = o.clone();
    return i.setIndex(s), i.clearGroups(), i;
  } else
    return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e), o;
}
class Mf extends As {
  constructor(e) {
    super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(t) {
      return new Rf(t);
    }), this.register(function(t) {
      return new If(t);
    }), this.register(function(t) {
      return new zf(t);
    }), this.register(function(t) {
      return new Hf(t);
    }), this.register(function(t) {
      return new Gf(t);
    }), this.register(function(t) {
      return new Df(t);
    }), this.register(function(t) {
      return new Lf(t);
    }), this.register(function(t) {
      return new Ff(t);
    }), this.register(function(t) {
      return new kf(t);
    }), this.register(function(t) {
      return new Cf(t);
    }), this.register(function(t) {
      return new Bf(t);
    }), this.register(function(t) {
      return new Of(t);
    }), this.register(function(t) {
      return new Uf(t);
    }), this.register(function(t) {
      return new Nf(t);
    }), this.register(function(t) {
      return new Af(t);
    }), this.register(function(t) {
      return new jf(t);
    }), this.register(function(t) {
      return new Vf(t);
    });
  }
  load(e, t, n, s) {
    const i = this;
    let r;
    if (this.resourcePath !== "")
      r = this.resourcePath;
    else if (this.path !== "") {
      const c = Qn.extractUrlBase(e);
      r = Qn.resolveURL(c, this.path);
    } else
      r = Qn.extractUrlBase(e);
    this.manager.itemStart(e);
    const a = function(c) {
      s ? s(c) : console.error(c), i.manager.itemError(e), i.manager.itemEnd(e);
    }, l = new Bn(this.manager);
    l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(e, function(c) {
      try {
        i.parse(c, r, function(h) {
          t(h), i.manager.itemEnd(e);
        }, a);
      } catch (h) {
        a(h);
      }
    }, n, a);
  }
  setDRACOLoader(e) {
    return this.dracoLoader = e, this;
  }
  setDDSLoader() {
    throw new Error(
      'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
    );
  }
  setKTX2Loader(e) {
    return this.ktx2Loader = e, this;
  }
  setMeshoptDecoder(e) {
    return this.meshoptDecoder = e, this;
  }
  register(e) {
    return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this;
  }
  unregister(e) {
    return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this;
  }
  parse(e, t, n, s) {
    let i;
    const r = {}, a = {}, l = new TextDecoder();
    if (typeof e == "string")
      i = JSON.parse(e);
    else if (e instanceof ArrayBuffer)
      if (l.decode(new Uint8Array(e, 0, 4)) === rl) {
        try {
          r[Ie.KHR_BINARY_GLTF] = new Yf(e);
        } catch (u) {
          s && s(u);
          return;
        }
        i = JSON.parse(r[Ie.KHR_BINARY_GLTF].content);
      } else
        i = JSON.parse(l.decode(e));
    else
      i = e;
    if (i.asset === void 0 || i.asset.version[0] < 2) {
      s && s(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
      return;
    }
    const c = new id(i, {
      path: t || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder
    });
    c.fileLoader.setRequestHeader(this.requestHeader);
    for (let h = 0; h < this.pluginCallbacks.length; h++) {
      const u = this.pluginCallbacks[h](c);
      u.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"), a[u.name] = u, r[u.name] = !0;
    }
    if (i.extensionsUsed)
      for (let h = 0; h < i.extensionsUsed.length; ++h) {
        const u = i.extensionsUsed[h], p = i.extensionsRequired || [];
        switch (u) {
          case Ie.KHR_MATERIALS_UNLIT:
            r[u] = new Pf();
            break;
          case Ie.KHR_DRACO_MESH_COMPRESSION:
            r[u] = new Xf(i, this.dracoLoader);
            break;
          case Ie.KHR_TEXTURE_TRANSFORM:
            r[u] = new Wf();
            break;
          case Ie.KHR_MESH_QUANTIZATION:
            r[u] = new $f();
            break;
          default:
            p.indexOf(u) >= 0 && a[u] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + u + '".');
        }
      }
    c.setExtensions(r), c.setPlugins(a), c.parse(n, s);
  }
  parseAsync(e, t) {
    const n = this;
    return new Promise(function(s, i) {
      n.parse(e, t, s, i);
    });
  }
}
function Sf() {
  let o = {};
  return {
    get: function(e) {
      return o[e];
    },
    add: function(e, t) {
      o[e] = t;
    },
    remove: function(e) {
      delete o[e];
    },
    removeAll: function() {
      o = {};
    }
  };
}
const Ie = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_MATERIALS_BUMP: "EXT_materials_bump",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
class Af {
  constructor(e) {
    this.parser = e, this.name = Ie.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} };
  }
  _markDefs() {
    const e = this.parser, t = this.parser.json.nodes || [];
    for (let n = 0, s = t.length; n < s; n++) {
      const i = t[n];
      i.extensions && i.extensions[this.name] && i.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, i.extensions[this.name].light);
    }
  }
  _loadLight(e) {
    const t = this.parser, n = "light:" + e;
    let s = t.cache.get(n);
    if (s) return s;
    const i = t.json, l = ((i.extensions && i.extensions[this.name] || {}).lights || [])[e];
    let c;
    const h = new Pe(16777215);
    l.color !== void 0 && h.setRGB(l.color[0], l.color[1], l.color[2], sn);
    const u = l.range !== void 0 ? l.range : 0;
    switch (l.type) {
      case "directional":
        c = new ga(h), c.target.position.set(0, 0, -1), c.add(c.target);
        break;
      case "point":
        c = new rr(h), c.distance = u;
        break;
      case "spot":
        c = new ma(h), c.distance = u, l.spot = l.spot || {}, l.spot.innerConeAngle = l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0, l.spot.outerConeAngle = l.spot.outerConeAngle !== void 0 ? l.spot.outerConeAngle : Math.PI / 4, c.angle = l.spot.outerConeAngle, c.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle, c.target.position.set(0, 0, -1), c.add(c.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + l.type);
    }
    return c.position.set(0, 0, 0), c.decay = 2, qt(c, l), l.intensity !== void 0 && (c.intensity = l.intensity), c.name = t.createUniqueName(l.name || "light_" + e), s = Promise.resolve(c), t.cache.add(n, s), s;
  }
  getDependency(e, t) {
    if (e === "light")
      return this._loadLight(t);
  }
  createNodeAttachment(e) {
    const t = this, n = this.parser, i = n.json.nodes[e], a = (i.extensions && i.extensions[this.name] || {}).light;
    return a === void 0 ? null : this._loadLight(a).then(function(l) {
      return n._getNodeRef(t.cache, a, l);
    });
  }
}
class Pf {
  constructor() {
    this.name = Ie.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return Qt;
  }
  extendParams(e, t, n) {
    const s = [];
    e.color = new Pe(1, 1, 1), e.opacity = 1;
    const i = t.pbrMetallicRoughness;
    if (i) {
      if (Array.isArray(i.baseColorFactor)) {
        const r = i.baseColorFactor;
        e.color.setRGB(r[0], r[1], r[2], sn), e.opacity = r[3];
      }
      i.baseColorTexture !== void 0 && s.push(n.assignTexture(e, "map", i.baseColorTexture, bs));
    }
    return Promise.all(s);
  }
}
class Cf {
  constructor(e) {
    this.parser = e, this.name = Ie.KHR_MATERIALS_EMISSIVE_STRENGTH;
  }
  extendMaterialParams(e, t) {
    const s = this.parser.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const i = s.extensions[this.name].emissiveStrength;
    return i !== void 0 && (t.emissiveIntensity = i), Promise.resolve();
  }
}
class Rf {
  constructor(e) {
    this.parser = e, this.name = Ie.KHR_MATERIALS_CLEARCOAT;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Yt;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, s = n.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const i = [], r = s.extensions[this.name];
    if (r.clearcoatFactor !== void 0 && (t.clearcoat = r.clearcoatFactor), r.clearcoatTexture !== void 0 && i.push(n.assignTexture(t, "clearcoatMap", r.clearcoatTexture)), r.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = r.clearcoatRoughnessFactor), r.clearcoatRoughnessTexture !== void 0 && i.push(n.assignTexture(t, "clearcoatRoughnessMap", r.clearcoatRoughnessTexture)), r.clearcoatNormalTexture !== void 0 && (i.push(n.assignTexture(t, "clearcoatNormalMap", r.clearcoatNormalTexture)), r.clearcoatNormalTexture.scale !== void 0)) {
      const a = r.clearcoatNormalTexture.scale;
      t.clearcoatNormalScale = new ge(a, a);
    }
    return Promise.all(i);
  }
}
class If {
  constructor(e) {
    this.parser = e, this.name = Ie.KHR_MATERIALS_DISPERSION;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Yt;
  }
  extendMaterialParams(e, t) {
    const s = this.parser.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const i = s.extensions[this.name];
    return t.dispersion = i.dispersion !== void 0 ? i.dispersion : 0, Promise.resolve();
  }
}
class Of {
  constructor(e) {
    this.parser = e, this.name = Ie.KHR_MATERIALS_IRIDESCENCE;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Yt;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, s = n.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const i = [], r = s.extensions[this.name];
    return r.iridescenceFactor !== void 0 && (t.iridescence = r.iridescenceFactor), r.iridescenceTexture !== void 0 && i.push(n.assignTexture(t, "iridescenceMap", r.iridescenceTexture)), r.iridescenceIor !== void 0 && (t.iridescenceIOR = r.iridescenceIor), t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [100, 400]), r.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = r.iridescenceThicknessMinimum), r.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = r.iridescenceThicknessMaximum), r.iridescenceThicknessTexture !== void 0 && i.push(n.assignTexture(t, "iridescenceThicknessMap", r.iridescenceThicknessTexture)), Promise.all(i);
  }
}
class Df {
  constructor(e) {
    this.parser = e, this.name = Ie.KHR_MATERIALS_SHEEN;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Yt;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, s = n.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const i = [];
    t.sheenColor = new Pe(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
    const r = s.extensions[this.name];
    if (r.sheenColorFactor !== void 0) {
      const a = r.sheenColorFactor;
      t.sheenColor.setRGB(a[0], a[1], a[2], sn);
    }
    return r.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = r.sheenRoughnessFactor), r.sheenColorTexture !== void 0 && i.push(n.assignTexture(t, "sheenColorMap", r.sheenColorTexture, bs)), r.sheenRoughnessTexture !== void 0 && i.push(n.assignTexture(t, "sheenRoughnessMap", r.sheenRoughnessTexture)), Promise.all(i);
  }
}
class Lf {
  constructor(e) {
    this.parser = e, this.name = Ie.KHR_MATERIALS_TRANSMISSION;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Yt;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, s = n.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const i = [], r = s.extensions[this.name];
    return r.transmissionFactor !== void 0 && (t.transmission = r.transmissionFactor), r.transmissionTexture !== void 0 && i.push(n.assignTexture(t, "transmissionMap", r.transmissionTexture)), Promise.all(i);
  }
}
class Ff {
  constructor(e) {
    this.parser = e, this.name = Ie.KHR_MATERIALS_VOLUME;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Yt;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, s = n.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const i = [], r = s.extensions[this.name];
    t.thickness = r.thicknessFactor !== void 0 ? r.thicknessFactor : 0, r.thicknessTexture !== void 0 && i.push(n.assignTexture(t, "thicknessMap", r.thicknessTexture)), t.attenuationDistance = r.attenuationDistance || 1 / 0;
    const a = r.attenuationColor || [1, 1, 1];
    return t.attenuationColor = new Pe().setRGB(a[0], a[1], a[2], sn), Promise.all(i);
  }
}
class kf {
  constructor(e) {
    this.parser = e, this.name = Ie.KHR_MATERIALS_IOR;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Yt;
  }
  extendMaterialParams(e, t) {
    const s = this.parser.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const i = s.extensions[this.name];
    return t.ior = i.ior !== void 0 ? i.ior : 1.5, Promise.resolve();
  }
}
class Bf {
  constructor(e) {
    this.parser = e, this.name = Ie.KHR_MATERIALS_SPECULAR;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Yt;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, s = n.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const i = [], r = s.extensions[this.name];
    t.specularIntensity = r.specularFactor !== void 0 ? r.specularFactor : 1, r.specularTexture !== void 0 && i.push(n.assignTexture(t, "specularIntensityMap", r.specularTexture));
    const a = r.specularColorFactor || [1, 1, 1];
    return t.specularColor = new Pe().setRGB(a[0], a[1], a[2], sn), r.specularColorTexture !== void 0 && i.push(n.assignTexture(t, "specularColorMap", r.specularColorTexture, bs)), Promise.all(i);
  }
}
class Nf {
  constructor(e) {
    this.parser = e, this.name = Ie.EXT_MATERIALS_BUMP;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Yt;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, s = n.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const i = [], r = s.extensions[this.name];
    return t.bumpScale = r.bumpFactor !== void 0 ? r.bumpFactor : 1, r.bumpTexture !== void 0 && i.push(n.assignTexture(t, "bumpMap", r.bumpTexture)), Promise.all(i);
  }
}
class Uf {
  constructor(e) {
    this.parser = e, this.name = Ie.KHR_MATERIALS_ANISOTROPY;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Yt;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, s = n.json.materials[e];
    if (!s.extensions || !s.extensions[this.name])
      return Promise.resolve();
    const i = [], r = s.extensions[this.name];
    return r.anisotropyStrength !== void 0 && (t.anisotropy = r.anisotropyStrength), r.anisotropyRotation !== void 0 && (t.anisotropyRotation = r.anisotropyRotation), r.anisotropyTexture !== void 0 && i.push(n.assignTexture(t, "anisotropyMap", r.anisotropyTexture)), Promise.all(i);
  }
}
class zf {
  constructor(e) {
    this.parser = e, this.name = Ie.KHR_TEXTURE_BASISU;
  }
  loadTexture(e) {
    const t = this.parser, n = t.json, s = n.textures[e];
    if (!s.extensions || !s.extensions[this.name])
      return null;
    const i = s.extensions[this.name], r = t.options.ktx2Loader;
    if (!r) {
      if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      return null;
    }
    return t.loadTextureImage(e, i.source, r);
  }
}
class Hf {
  constructor(e) {
    this.parser = e, this.name = Ie.EXT_TEXTURE_WEBP, this.isSupported = null;
  }
  loadTexture(e) {
    const t = this.name, n = this.parser, s = n.json, i = s.textures[e];
    if (!i.extensions || !i.extensions[t])
      return null;
    const r = i.extensions[t], a = s.images[r.source];
    let l = n.textureLoader;
    if (a.uri) {
      const c = n.options.manager.getHandler(a.uri);
      c !== null && (l = c);
    }
    return this.detectSupport().then(function(c) {
      if (c) return n.loadTextureImage(e, r.source, l);
      if (s.extensionsRequired && s.extensionsRequired.indexOf(t) >= 0)
        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      return n.loadTexture(e);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(e) {
      const t = new Image();
      t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function() {
        e(t.height === 1);
      };
    })), this.isSupported;
  }
}
class Gf {
  constructor(e) {
    this.parser = e, this.name = Ie.EXT_TEXTURE_AVIF, this.isSupported = null;
  }
  loadTexture(e) {
    const t = this.name, n = this.parser, s = n.json, i = s.textures[e];
    if (!i.extensions || !i.extensions[t])
      return null;
    const r = i.extensions[t], a = s.images[r.source];
    let l = n.textureLoader;
    if (a.uri) {
      const c = n.options.manager.getHandler(a.uri);
      c !== null && (l = c);
    }
    return this.detectSupport().then(function(c) {
      if (c) return n.loadTextureImage(e, r.source, l);
      if (s.extensionsRequired && s.extensionsRequired.indexOf(t) >= 0)
        throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
      return n.loadTexture(e);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(e) {
      const t = new Image();
      t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", t.onload = t.onerror = function() {
        e(t.height === 1);
      };
    })), this.isSupported;
  }
}
class jf {
  constructor(e) {
    this.name = Ie.EXT_MESHOPT_COMPRESSION, this.parser = e;
  }
  loadBufferView(e) {
    const t = this.parser.json, n = t.bufferViews[e];
    if (n.extensions && n.extensions[this.name]) {
      const s = n.extensions[this.name], i = this.parser.getDependency("buffer", s.buffer), r = this.parser.options.meshoptDecoder;
      if (!r || !r.supported) {
        if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)
          throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        return null;
      }
      return i.then(function(a) {
        const l = s.byteOffset || 0, c = s.byteLength || 0, h = s.count, u = s.byteStride, p = new Uint8Array(a, l, c);
        return r.decodeGltfBufferAsync ? r.decodeGltfBufferAsync(h, u, p, s.mode, s.filter).then(function(f) {
          return f.buffer;
        }) : r.ready.then(function() {
          const f = new ArrayBuffer(h * u);
          return r.decodeGltfBuffer(new Uint8Array(f), h, u, p, s.mode, s.filter), f;
        });
      });
    } else
      return null;
  }
}
class Vf {
  constructor(e) {
    this.name = Ie.EXT_MESH_GPU_INSTANCING, this.parser = e;
  }
  createNodeMesh(e) {
    const t = this.parser.json, n = t.nodes[e];
    if (!n.extensions || !n.extensions[this.name] || n.mesh === void 0)
      return null;
    const s = t.meshes[n.mesh];
    for (const c of s.primitives)
      if (c.mode !== Et.TRIANGLES && c.mode !== Et.TRIANGLE_STRIP && c.mode !== Et.TRIANGLE_FAN && c.mode !== void 0)
        return null;
    const r = n.extensions[this.name].attributes, a = [], l = {};
    for (const c in r)
      a.push(this.parser.getDependency("accessor", r[c]).then((h) => (l[c] = h, l[c])));
    return a.length < 1 ? null : (a.push(this.parser.createNodeMesh(e)), Promise.all(a).then((c) => {
      const h = c.pop(), u = h.isGroup ? h.children : [h], p = c[0].count, f = [];
      for (const g of u) {
        const m = new Re(), y = new $(), d = new ze(), w = new $(1, 1, 1), v = new Yl(g.geometry, g.material, p);
        for (let E = 0; E < p; E++)
          l.TRANSLATION && y.fromBufferAttribute(l.TRANSLATION, E), l.ROTATION && d.fromBufferAttribute(l.ROTATION, E), l.SCALE && w.fromBufferAttribute(l.SCALE, E), v.setMatrixAt(E, m.compose(y, d, w));
        for (const E in l)
          if (E === "_COLOR_0") {
            const P = l[E];
            v.instanceColor = new Xl(P.array, P.itemSize, P.normalized);
          } else E !== "TRANSLATION" && E !== "ROTATION" && E !== "SCALE" && g.geometry.setAttribute(E, l[E]);
        Pt.prototype.copy.call(v, g), this.parser.assignFinalMaterial(v), f.push(v);
      }
      return h.isGroup ? (h.clear(), h.add(...f), h) : f[0];
    }));
  }
}
const rl = "glTF", ds = 12, Ro = { JSON: 1313821514, BIN: 5130562 };
class Yf {
  constructor(e) {
    this.name = Ie.KHR_BINARY_GLTF, this.content = null, this.body = null;
    const t = new DataView(e, 0, ds), n = new TextDecoder();
    if (this.header = {
      magic: n.decode(new Uint8Array(e.slice(0, 4))),
      version: t.getUint32(4, !0),
      length: t.getUint32(8, !0)
    }, this.header.magic !== rl)
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const s = this.header.length - ds, i = new DataView(e, ds);
    let r = 0;
    for (; r < s; ) {
      const a = i.getUint32(r, !0);
      r += 4;
      const l = i.getUint32(r, !0);
      if (r += 4, l === Ro.JSON) {
        const c = new Uint8Array(e, ds + r, a);
        this.content = n.decode(c);
      } else if (l === Ro.BIN) {
        const c = ds + r;
        this.body = e.slice(c, c + a);
      }
      r += a;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class Xf {
  constructor(e, t) {
    if (!t)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    this.name = Ie.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload();
  }
  decodePrimitive(e, t) {
    const n = this.json, s = this.dracoLoader, i = e.extensions[this.name].bufferView, r = e.extensions[this.name].attributes, a = {}, l = {}, c = {};
    for (const h in r) {
      const u = mr[h] || h.toLowerCase();
      a[u] = r[h];
    }
    for (const h in e.attributes) {
      const u = mr[h] || h.toLowerCase();
      if (r[h] !== void 0) {
        const p = n.accessors[e.attributes[h]], f = Jn[p.componentType];
        c[u] = f.name, l[u] = p.normalized === !0;
      }
    }
    return t.getDependency("bufferView", i).then(function(h) {
      return new Promise(function(u, p) {
        s.decodeDracoFile(h, function(f) {
          for (const g in f.attributes) {
            const m = f.attributes[g], y = l[g];
            y !== void 0 && (m.normalized = y);
          }
          u(f);
        }, a, c, sn, p);
      });
    });
  }
}
class Wf {
  constructor() {
    this.name = Ie.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(e, t) {
    return (t.texCoord === void 0 || t.texCoord === e.channel) && t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(), t.texCoord !== void 0 && (e.channel = t.texCoord), t.offset !== void 0 && e.offset.fromArray(t.offset), t.rotation !== void 0 && (e.rotation = t.rotation), t.scale !== void 0 && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e;
  }
}
class $f {
  constructor() {
    this.name = Ie.KHR_MESH_QUANTIZATION;
  }
}
class ol extends ql {
  constructor(e, t, n, s) {
    super(e, t, n, s);
  }
  copySampleValue_(e) {
    const t = this.resultBuffer, n = this.sampleValues, s = this.valueSize, i = e * s * 3 + s;
    for (let r = 0; r !== s; r++)
      t[r] = n[i + r];
    return t;
  }
  interpolate_(e, t, n, s) {
    const i = this.resultBuffer, r = this.sampleValues, a = this.valueSize, l = a * 2, c = a * 3, h = s - t, u = (n - t) / h, p = u * u, f = p * u, g = e * c, m = g - c, y = -2 * f + 3 * p, d = f - p, w = 1 - y, v = d - p + u;
    for (let E = 0; E !== a; E++) {
      const P = r[m + E + a], T = r[m + E + l] * h, b = r[g + E + a], x = r[g + E] * h;
      i[E] = w * P + v * T + y * b + d * x;
    }
    return i;
  }
}
const Zf = new ze();
class Kf extends ol {
  interpolate_(e, t, n, s) {
    const i = super.interpolate_(e, t, n, s);
    return Zf.fromArray(i).normalize().toArray(i), i;
  }
}
const Et = {
  FLOAT: 5126,
  //FLOAT_MAT2: 35674,
  FLOAT_MAT3: 35675,
  FLOAT_MAT4: 35676,
  FLOAT_VEC2: 35664,
  FLOAT_VEC3: 35665,
  FLOAT_VEC4: 35666,
  LINEAR: 9729,
  REPEAT: 10497,
  SAMPLER_2D: 35678,
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6,
  UNSIGNED_BYTE: 5121,
  UNSIGNED_SHORT: 5123
}, Jn = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
}, Io = {
  9728: la,
  9729: vt,
  9984: ca,
  9985: ha,
  9986: ua,
  9987: Er
}, Oo = {
  33071: ts,
  33648: fa,
  10497: kn
}, zi = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, mr = {
  POSITION: "position",
  NORMAL: "normal",
  TANGENT: "tangent",
  TEXCOORD_0: "uv",
  TEXCOORD_1: "uv1",
  TEXCOORD_2: "uv2",
  TEXCOORD_3: "uv3",
  COLOR_0: "color",
  WEIGHTS_0: "skinWeight",
  JOINTS_0: "skinIndex"
}, dn = {
  scale: "scale",
  translation: "position",
  rotation: "quaternion",
  weights: "morphTargetInfluences"
}, qf = {
  CUBICSPLINE: void 0,
  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
  // keyframe track will be initialized with a default interpolation type, then modified.
  LINEAR: br,
  STEP: aa
}, Hi = {
  OPAQUE: "OPAQUE",
  MASK: "MASK",
  BLEND: "BLEND"
};
function Qf(o) {
  return o.DefaultMaterial === void 0 && (o.DefaultMaterial = new Ps({
    color: 16777215,
    emissive: 0,
    metalness: 1,
    roughness: 1,
    transparent: !1,
    depthTest: !0,
    side: Ss
  })), o.DefaultMaterial;
}
function Dn(o, e, t) {
  for (const n in t.extensions)
    o[n] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[n] = t.extensions[n]);
}
function qt(o, e) {
  e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(o.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras));
}
function Jf(o, e, t) {
  let n = !1, s = !1, i = !1;
  for (let c = 0, h = e.length; c < h; c++) {
    const u = e[c];
    if (u.POSITION !== void 0 && (n = !0), u.NORMAL !== void 0 && (s = !0), u.COLOR_0 !== void 0 && (i = !0), n && s && i) break;
  }
  if (!n && !s && !i) return Promise.resolve(o);
  const r = [], a = [], l = [];
  for (let c = 0, h = e.length; c < h; c++) {
    const u = e[c];
    if (n) {
      const p = u.POSITION !== void 0 ? t.getDependency("accessor", u.POSITION) : o.attributes.position;
      r.push(p);
    }
    if (s) {
      const p = u.NORMAL !== void 0 ? t.getDependency("accessor", u.NORMAL) : o.attributes.normal;
      a.push(p);
    }
    if (i) {
      const p = u.COLOR_0 !== void 0 ? t.getDependency("accessor", u.COLOR_0) : o.attributes.color;
      l.push(p);
    }
  }
  return Promise.all([
    Promise.all(r),
    Promise.all(a),
    Promise.all(l)
  ]).then(function(c) {
    const h = c[0], u = c[1], p = c[2];
    return n && (o.morphAttributes.position = h), s && (o.morphAttributes.normal = u), i && (o.morphAttributes.color = p), o.morphTargetsRelative = !0, o;
  });
}
function ed(o, e) {
  if (o.updateMorphTargets(), e.weights !== void 0)
    for (let t = 0, n = e.weights.length; t < n; t++)
      o.morphTargetInfluences[t] = e.weights[t];
  if (e.extras && Array.isArray(e.extras.targetNames)) {
    const t = e.extras.targetNames;
    if (o.morphTargetInfluences.length === t.length) {
      o.morphTargetDictionary = {};
      for (let n = 0, s = t.length; n < s; n++)
        o.morphTargetDictionary[t[n]] = n;
    } else
      console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
  }
}
function td(o) {
  let e;
  const t = o.extensions && o.extensions[Ie.KHR_DRACO_MESH_COMPRESSION];
  if (t ? e = "draco:" + t.bufferView + ":" + t.indices + ":" + Gi(t.attributes) : e = o.indices + ":" + Gi(o.attributes) + ":" + o.mode, o.targets !== void 0)
    for (let n = 0, s = o.targets.length; n < s; n++)
      e += ":" + Gi(o.targets[n]);
  return e;
}
function Gi(o) {
  let e = "";
  const t = Object.keys(o).sort();
  for (let n = 0, s = t.length; n < s; n++)
    e += t[n] + ":" + o[t[n]] + ";";
  return e;
}
function gr(o) {
  switch (o) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
  }
}
function nd(o) {
  return o.search(/\.jpe?g($|\?)/i) > 0 || o.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : o.search(/\.webp($|\?)/i) > 0 || o.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png";
}
const sd = new Re();
class id {
  constructor(e = {}, t = {}) {
    this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new Sf(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
    let n = !1, s = -1, i = !1, r = -1;
    if (typeof navigator < "u") {
      const a = navigator.userAgent;
      n = /^((?!chrome|android).)*safari/i.test(a) === !0;
      const l = a.match(/Version\/(\d+)/);
      s = n && l ? parseInt(l[1], 10) : -1, i = a.indexOf("Firefox") > -1, r = i ? a.match(/Firefox\/([0-9]+)\./)[1] : -1;
    }
    typeof createImageBitmap > "u" || n && s < 17 || i && r < 98 ? this.textureLoader = new fi(this.options.manager) : this.textureLoader = new Wl(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new Bn(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(e) {
    this.extensions = e;
  }
  setPlugins(e) {
    this.plugins = e;
  }
  parse(e, t) {
    const n = this, s = this.json, i = this.extensions;
    this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function(r) {
      return r._markDefs && r._markDefs();
    }), Promise.all(this._invokeAll(function(r) {
      return r.beforeRoot && r.beforeRoot();
    })).then(function() {
      return Promise.all([
        n.getDependencies("scene"),
        n.getDependencies("animation"),
        n.getDependencies("camera")
      ]);
    }).then(function(r) {
      const a = {
        scene: r[0][s.scene || 0],
        scenes: r[0],
        animations: r[1],
        cameras: r[2],
        asset: s.asset,
        parser: n,
        userData: {}
      };
      return Dn(i, a, s), qt(a, s), Promise.all(n._invokeAll(function(l) {
        return l.afterRoot && l.afterRoot(a);
      })).then(function() {
        for (const l of a.scenes)
          l.updateMatrixWorld();
        e(a);
      });
    }).catch(t);
  }
  /**
   * Marks the special nodes/meshes in json for efficient parse.
   */
  _markDefs() {
    const e = this.json.nodes || [], t = this.json.skins || [], n = this.json.meshes || [];
    for (let s = 0, i = t.length; s < i; s++) {
      const r = t[s].joints;
      for (let a = 0, l = r.length; a < l; a++)
        e[r[a]].isBone = !0;
    }
    for (let s = 0, i = e.length; s < i; s++) {
      const r = e[s];
      r.mesh !== void 0 && (this._addNodeRef(this.meshCache, r.mesh), r.skin !== void 0 && (n[r.mesh].isSkinnedMesh = !0)), r.camera !== void 0 && this._addNodeRef(this.cameraCache, r.camera);
    }
  }
  /**
   * Counts references to shared node / Object3D resources. These resources
   * can be reused, or "instantiated", at multiple nodes in the scene
   * hierarchy. Mesh, Camera, and Light instances are instantiated and must
   * be marked. Non-scenegraph resources (like Materials, Geometries, and
   * Textures) can be reused directly and are not marked here.
   *
   * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
   */
  _addNodeRef(e, t) {
    t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
  }
  /** Returns a reference to a shared resource, cloning it if necessary. */
  _getNodeRef(e, t, n) {
    if (e.refs[t] <= 1) return n;
    const s = n.clone(), i = (r, a) => {
      const l = this.associations.get(r);
      l != null && this.associations.set(a, l);
      for (const [c, h] of r.children.entries())
        i(h, a.children[c]);
    };
    return i(n, s), s.name += "_instance_" + e.uses[t]++, s;
  }
  _invokeOne(e) {
    const t = Object.values(this.plugins);
    t.push(this);
    for (let n = 0; n < t.length; n++) {
      const s = e(t[n]);
      if (s) return s;
    }
    return null;
  }
  _invokeAll(e) {
    const t = Object.values(this.plugins);
    t.unshift(this);
    const n = [];
    for (let s = 0; s < t.length; s++) {
      const i = e(t[s]);
      i && n.push(i);
    }
    return n;
  }
  /**
   * Requests the specified dependency asynchronously, with caching.
   * @param {string} type
   * @param {number} index
   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
   */
  getDependency(e, t) {
    const n = e + ":" + t;
    let s = this.cache.get(n);
    if (!s) {
      switch (e) {
        case "scene":
          s = this.loadScene(t);
          break;
        case "node":
          s = this._invokeOne(function(i) {
            return i.loadNode && i.loadNode(t);
          });
          break;
        case "mesh":
          s = this._invokeOne(function(i) {
            return i.loadMesh && i.loadMesh(t);
          });
          break;
        case "accessor":
          s = this.loadAccessor(t);
          break;
        case "bufferView":
          s = this._invokeOne(function(i) {
            return i.loadBufferView && i.loadBufferView(t);
          });
          break;
        case "buffer":
          s = this.loadBuffer(t);
          break;
        case "material":
          s = this._invokeOne(function(i) {
            return i.loadMaterial && i.loadMaterial(t);
          });
          break;
        case "texture":
          s = this._invokeOne(function(i) {
            return i.loadTexture && i.loadTexture(t);
          });
          break;
        case "skin":
          s = this.loadSkin(t);
          break;
        case "animation":
          s = this._invokeOne(function(i) {
            return i.loadAnimation && i.loadAnimation(t);
          });
          break;
        case "camera":
          s = this.loadCamera(t);
          break;
        default:
          if (s = this._invokeOne(function(i) {
            return i != this && i.getDependency && i.getDependency(e, t);
          }), !s)
            throw new Error("Unknown type: " + e);
          break;
      }
      this.cache.add(n, s);
    }
    return s;
  }
  /**
   * Requests all dependencies of the specified type asynchronously, with caching.
   * @param {string} type
   * @return {Promise<Array<Object>>}
   */
  getDependencies(e) {
    let t = this.cache.get(e);
    if (!t) {
      const n = this, s = this.json[e + (e === "mesh" ? "es" : "s")] || [];
      t = Promise.all(s.map(function(i, r) {
        return n.getDependency(e, r);
      })), this.cache.add(e, t);
    }
    return t;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBuffer(e) {
    const t = this.json.buffers[e], n = this.fileLoader;
    if (t.type && t.type !== "arraybuffer")
      throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
    if (t.uri === void 0 && e === 0)
      return Promise.resolve(this.extensions[Ie.KHR_BINARY_GLTF].body);
    const s = this.options;
    return new Promise(function(i, r) {
      n.load(Qn.resolveURL(t.uri, s.path), i, void 0, function() {
        r(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'));
      });
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferViewIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBufferView(e) {
    const t = this.json.bufferViews[e];
    return this.getDependency("buffer", t.buffer).then(function(n) {
      const s = t.byteLength || 0, i = t.byteOffset || 0;
      return n.slice(i, i + s);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
   * @param {number} accessorIndex
   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
   */
  loadAccessor(e) {
    const t = this, n = this.json, s = this.json.accessors[e];
    if (s.bufferView === void 0 && s.sparse === void 0) {
      const r = zi[s.type], a = Jn[s.componentType], l = s.normalized === !0, c = new a(s.count * r);
      return Promise.resolve(new mt(c, r, l));
    }
    const i = [];
    return s.bufferView !== void 0 ? i.push(this.getDependency("bufferView", s.bufferView)) : i.push(null), s.sparse !== void 0 && (i.push(this.getDependency("bufferView", s.sparse.indices.bufferView)), i.push(this.getDependency("bufferView", s.sparse.values.bufferView))), Promise.all(i).then(function(r) {
      const a = r[0], l = zi[s.type], c = Jn[s.componentType], h = c.BYTES_PER_ELEMENT, u = h * l, p = s.byteOffset || 0, f = s.bufferView !== void 0 ? n.bufferViews[s.bufferView].byteStride : void 0, g = s.normalized === !0;
      let m, y;
      if (f && f !== u) {
        const d = Math.floor(p / f), w = "InterleavedBuffer:" + s.bufferView + ":" + s.componentType + ":" + d + ":" + s.count;
        let v = t.cache.get(w);
        v || (m = new c(a, d * f, s.count * f / h), v = new Tr(m, f / h), t.cache.add(w, v)), y = new Jt(v, l, p % f / h, g);
      } else
        a === null ? m = new c(s.count * l) : m = new c(a, p, s.count * l), y = new mt(m, l, g);
      if (s.sparse !== void 0) {
        const d = zi.SCALAR, w = Jn[s.sparse.indices.componentType], v = s.sparse.indices.byteOffset || 0, E = s.sparse.values.byteOffset || 0, P = new w(r[1], v, s.sparse.count * d), T = new c(r[2], E, s.sparse.count * l);
        a !== null && (y = new mt(y.array.slice(), y.itemSize, y.normalized));
        for (let b = 0, x = P.length; b < x; b++) {
          const M = P[b];
          if (y.setX(M, T[b * l]), l >= 2 && y.setY(M, T[b * l + 1]), l >= 3 && y.setZ(M, T[b * l + 2]), l >= 4 && y.setW(M, T[b * l + 3]), l >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
      }
      return y;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
   * @param {number} textureIndex
   * @return {Promise<THREE.Texture|null>}
   */
  loadTexture(e) {
    const t = this.json, n = this.options, i = t.textures[e].source, r = t.images[i];
    let a = this.textureLoader;
    if (r.uri) {
      const l = n.manager.getHandler(r.uri);
      l !== null && (a = l);
    }
    return this.loadTextureImage(e, i, a);
  }
  loadTextureImage(e, t, n) {
    const s = this, i = this.json, r = i.textures[e], a = i.images[t], l = (a.uri || a.bufferView) + ":" + r.sampler;
    if (this.textureCache[l])
      return this.textureCache[l];
    const c = this.loadImageSource(t, n).then(function(h) {
      h.flipY = !1, h.name = r.name || a.name || "", h.name === "" && typeof a.uri == "string" && a.uri.startsWith("data:image/") === !1 && (h.name = a.uri);
      const p = (i.samplers || {})[r.sampler] || {};
      return h.magFilter = Io[p.magFilter] || vt, h.minFilter = Io[p.minFilter] || Er, h.wrapS = Oo[p.wrapS] || kn, h.wrapT = Oo[p.wrapT] || kn, s.associations.set(h, { textures: e }), h;
    }).catch(function() {
      return null;
    });
    return this.textureCache[l] = c, c;
  }
  loadImageSource(e, t) {
    const n = this, s = this.json, i = this.options;
    if (this.sourceCache[e] !== void 0)
      return this.sourceCache[e].then((u) => u.clone());
    const r = s.images[e], a = self.URL || self.webkitURL;
    let l = r.uri || "", c = !1;
    if (r.bufferView !== void 0)
      l = n.getDependency("bufferView", r.bufferView).then(function(u) {
        c = !0;
        const p = new Blob([u], { type: r.mimeType });
        return l = a.createObjectURL(p), l;
      });
    else if (r.uri === void 0)
      throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
    const h = Promise.resolve(l).then(function(u) {
      return new Promise(function(p, f) {
        let g = p;
        t.isImageBitmapLoader === !0 && (g = function(m) {
          const y = new es(m);
          y.needsUpdate = !0, p(y);
        }), t.load(Qn.resolveURL(u, i.path), g, void 0, f);
      });
    }).then(function(u) {
      return c === !0 && a.revokeObjectURL(l), qt(u, r), u.userData.mimeType = r.mimeType || nd(r.uri), u;
    }).catch(function(u) {
      throw console.error("THREE.GLTFLoader: Couldn't load texture", l), u;
    });
    return this.sourceCache[e] = h, h;
  }
  /**
   * Asynchronously assigns a texture to the given material parameters.
   * @param {Object} materialParams
   * @param {string} mapName
   * @param {Object} mapDef
   * @return {Promise<Texture>}
   */
  assignTexture(e, t, n, s) {
    const i = this;
    return this.getDependency("texture", n.index).then(function(r) {
      if (!r) return null;
      if (n.texCoord !== void 0 && n.texCoord > 0 && (r = r.clone(), r.channel = n.texCoord), i.extensions[Ie.KHR_TEXTURE_TRANSFORM]) {
        const a = n.extensions !== void 0 ? n.extensions[Ie.KHR_TEXTURE_TRANSFORM] : void 0;
        if (a) {
          const l = i.associations.get(r);
          r = i.extensions[Ie.KHR_TEXTURE_TRANSFORM].extendTexture(r, a), i.associations.set(r, l);
        }
      }
      return s !== void 0 && (r.colorSpace = s), e[t] = r, r;
    });
  }
  /**
   * Assigns final material to a Mesh, Line, or Points instance. The instance
   * already has a material (generated from the glTF material options alone)
   * but reuse of the same glTF material may require multiple threejs materials
   * to accommodate different primitive types, defines, etc. New materials will
   * be created if necessary, and reused from a cache.
   * @param  {Object3D} mesh Mesh, Line, or Points instance.
   */
  assignFinalMaterial(e) {
    const t = e.geometry;
    let n = e.material;
    const s = t.attributes.tangent === void 0, i = t.attributes.color !== void 0, r = t.attributes.normal === void 0;
    if (e.isPoints) {
      const a = "PointsMaterial:" + n.uuid;
      let l = this.cache.get(a);
      l || (l = new $l(), bi.prototype.copy.call(l, n), l.color.copy(n.color), l.map = n.map, l.sizeAttenuation = !1, this.cache.add(a, l)), n = l;
    } else if (e.isLine) {
      const a = "LineBasicMaterial:" + n.uuid;
      let l = this.cache.get(a);
      l || (l = new ws(), bi.prototype.copy.call(l, n), l.color.copy(n.color), l.map = n.map, this.cache.add(a, l)), n = l;
    }
    if (s || i || r) {
      let a = "ClonedMaterial:" + n.uuid + ":";
      s && (a += "derivative-tangents:"), i && (a += "vertex-colors:"), r && (a += "flat-shading:");
      let l = this.cache.get(a);
      l || (l = n.clone(), i && (l.vertexColors = !0), r && (l.flatShading = !0), s && (l.normalScale && (l.normalScale.y *= -1), l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)), this.cache.add(a, l), this.associations.set(l, this.associations.get(n))), n = l;
    }
    e.material = n;
  }
  getMaterialType() {
    return Ps;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
   * @param {number} materialIndex
   * @return {Promise<Material>}
   */
  loadMaterial(e) {
    const t = this, n = this.json, s = this.extensions, i = n.materials[e];
    let r;
    const a = {}, l = i.extensions || {}, c = [];
    if (l[Ie.KHR_MATERIALS_UNLIT]) {
      const u = s[Ie.KHR_MATERIALS_UNLIT];
      r = u.getMaterialType(), c.push(u.extendParams(a, i, t));
    } else {
      const u = i.pbrMetallicRoughness || {};
      if (a.color = new Pe(1, 1, 1), a.opacity = 1, Array.isArray(u.baseColorFactor)) {
        const p = u.baseColorFactor;
        a.color.setRGB(p[0], p[1], p[2], sn), a.opacity = p[3];
      }
      u.baseColorTexture !== void 0 && c.push(t.assignTexture(a, "map", u.baseColorTexture, bs)), a.metalness = u.metallicFactor !== void 0 ? u.metallicFactor : 1, a.roughness = u.roughnessFactor !== void 0 ? u.roughnessFactor : 1, u.metallicRoughnessTexture !== void 0 && (c.push(t.assignTexture(a, "metalnessMap", u.metallicRoughnessTexture)), c.push(t.assignTexture(a, "roughnessMap", u.metallicRoughnessTexture))), r = this._invokeOne(function(p) {
        return p.getMaterialType && p.getMaterialType(e);
      }), c.push(Promise.all(this._invokeAll(function(p) {
        return p.extendMaterialParams && p.extendMaterialParams(e, a);
      })));
    }
    i.doubleSided === !0 && (a.side = tn);
    const h = i.alphaMode || Hi.OPAQUE;
    if (h === Hi.BLEND ? (a.transparent = !0, a.depthWrite = !1) : (a.transparent = !1, h === Hi.MASK && (a.alphaTest = i.alphaCutoff !== void 0 ? i.alphaCutoff : 0.5)), i.normalTexture !== void 0 && r !== Qt && (c.push(t.assignTexture(a, "normalMap", i.normalTexture)), a.normalScale = new ge(1, 1), i.normalTexture.scale !== void 0)) {
      const u = i.normalTexture.scale;
      a.normalScale.set(u, u);
    }
    if (i.occlusionTexture !== void 0 && r !== Qt && (c.push(t.assignTexture(a, "aoMap", i.occlusionTexture)), i.occlusionTexture.strength !== void 0 && (a.aoMapIntensity = i.occlusionTexture.strength)), i.emissiveFactor !== void 0 && r !== Qt) {
      const u = i.emissiveFactor;
      a.emissive = new Pe().setRGB(u[0], u[1], u[2], sn);
    }
    return i.emissiveTexture !== void 0 && r !== Qt && c.push(t.assignTexture(a, "emissiveMap", i.emissiveTexture, bs)), Promise.all(c).then(function() {
      const u = new r(a);
      return i.name && (u.name = i.name), qt(u, i), t.associations.set(u, { materials: e }), i.extensions && Dn(s, u, i), u;
    });
  }
  /** When Object3D instances are targeted by animation, they need unique names. */
  createUniqueName(e) {
    const t = nn.sanitizeNodeName(e || "");
    return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0, t);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
   *
   * Creates BufferGeometries from primitives.
   *
   * @param {Array<GLTF.Primitive>} primitives
   * @return {Promise<Array<BufferGeometry>>}
   */
  loadGeometries(e) {
    const t = this, n = this.extensions, s = this.primitiveCache;
    function i(a) {
      return n[Ie.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a, t).then(function(l) {
        return Do(l, a, t);
      });
    }
    const r = [];
    for (let a = 0, l = e.length; a < l; a++) {
      const c = e[a], h = td(c), u = s[h];
      if (u)
        r.push(u.promise);
      else {
        let p;
        c.extensions && c.extensions[Ie.KHR_DRACO_MESH_COMPRESSION] ? p = i(c) : p = Do(new pt(), c, t), s[h] = { primitive: c, promise: p }, r.push(p);
      }
    }
    return Promise.all(r);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
   * @param {number} meshIndex
   * @return {Promise<Group|Mesh|SkinnedMesh>}
   */
  loadMesh(e) {
    const t = this, n = this.json, s = this.extensions, i = n.meshes[e], r = i.primitives, a = [];
    for (let l = 0, c = r.length; l < c; l++) {
      const h = r[l].material === void 0 ? Qf(this.cache) : this.getDependency("material", r[l].material);
      a.push(h);
    }
    return a.push(t.loadGeometries(r)), Promise.all(a).then(function(l) {
      const c = l.slice(0, l.length - 1), h = l[l.length - 1], u = [];
      for (let f = 0, g = h.length; f < g; f++) {
        const m = h[f], y = r[f];
        let d;
        const w = c[f];
        if (y.mode === Et.TRIANGLES || y.mode === Et.TRIANGLE_STRIP || y.mode === Et.TRIANGLE_FAN || y.mode === void 0)
          d = i.isSkinnedMesh === !0 ? new ya(m, w) : new he(m, w), d.isSkinnedMesh === !0 && d.normalizeSkinWeights(), y.mode === Et.TRIANGLE_STRIP ? d.geometry = Co(d.geometry, wa) : y.mode === Et.TRIANGLE_FAN && (d.geometry = Co(d.geometry, cr));
        else if (y.mode === Et.LINES)
          d = new Zl(m, w);
        else if (y.mode === Et.LINE_STRIP)
          d = new Le(m, w);
        else if (y.mode === Et.LINE_LOOP)
          d = new Kl(m, w);
        else if (y.mode === Et.POINTS)
          d = new Ta(m, w);
        else
          throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + y.mode);
        Object.keys(d.geometry.morphAttributes).length > 0 && ed(d, i), d.name = t.createUniqueName(i.name || "mesh_" + e), qt(d, i), y.extensions && Dn(s, d, y), t.assignFinalMaterial(d), u.push(d);
      }
      for (let f = 0, g = u.length; f < g; f++)
        t.associations.set(u[f], {
          meshes: e,
          primitives: f
        });
      if (u.length === 1)
        return i.extensions && Dn(s, u[0], i), u[0];
      const p = new Sn();
      i.extensions && Dn(s, p, i), t.associations.set(p, { meshes: e });
      for (let f = 0, g = u.length; f < g; f++)
        p.add(u[f]);
      return p;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
   * @param {number} cameraIndex
   * @return {Promise<THREE.Camera>}
   */
  loadCamera(e) {
    let t;
    const n = this.json.cameras[e], s = n[n.type];
    if (!s) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return n.type === "perspective" ? t = new At(Ze.radToDeg(s.yfov), s.aspectRatio || 1, s.znear || 1, s.zfar || 2e6) : n.type === "orthographic" && (t = new en(-s.xmag, s.xmag, s.ymag, -s.ymag, s.znear, s.zfar)), n.name && (t.name = this.createUniqueName(n.name)), qt(t, n), Promise.resolve(t);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
   * @param {number} skinIndex
   * @return {Promise<Skeleton>}
   */
  loadSkin(e) {
    const t = this.json.skins[e], n = [];
    for (let s = 0, i = t.joints.length; s < i; s++)
      n.push(this._loadNodeShallow(t.joints[s]));
    return t.inverseBindMatrices !== void 0 ? n.push(this.getDependency("accessor", t.inverseBindMatrices)) : n.push(null), Promise.all(n).then(function(s) {
      const i = s.pop(), r = s, a = [], l = [];
      for (let c = 0, h = r.length; c < h; c++) {
        const u = r[c];
        if (u) {
          a.push(u);
          const p = new Re();
          i !== null && p.fromArray(i.array, c * 16), l.push(p);
        } else
          console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[c]);
      }
      return new va(a, l);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
   * @param {number} animationIndex
   * @return {Promise<AnimationClip>}
   */
  loadAnimation(e) {
    const t = this.json, n = this, s = t.animations[e], i = s.name ? s.name : "animation_" + e, r = [], a = [], l = [], c = [], h = [];
    for (let u = 0, p = s.channels.length; u < p; u++) {
      const f = s.channels[u], g = s.samplers[f.sampler], m = f.target, y = m.node, d = s.parameters !== void 0 ? s.parameters[g.input] : g.input, w = s.parameters !== void 0 ? s.parameters[g.output] : g.output;
      m.node !== void 0 && (r.push(this.getDependency("node", y)), a.push(this.getDependency("accessor", d)), l.push(this.getDependency("accessor", w)), c.push(g), h.push(m));
    }
    return Promise.all([
      Promise.all(r),
      Promise.all(a),
      Promise.all(l),
      Promise.all(c),
      Promise.all(h)
    ]).then(function(u) {
      const p = u[0], f = u[1], g = u[2], m = u[3], y = u[4], d = [];
      for (let w = 0, v = p.length; w < v; w++) {
        const E = p[w], P = f[w], T = g[w], b = m[w], x = y[w];
        if (E === void 0) continue;
        E.updateMatrix && E.updateMatrix();
        const M = n._createAnimationTracks(E, P, T, b, x);
        if (M)
          for (let _ = 0; _ < M.length; _++)
            d.push(M[_]);
      }
      return new _a(i, void 0, d);
    });
  }
  createNodeMesh(e) {
    const t = this.json, n = this, s = t.nodes[e];
    return s.mesh === void 0 ? null : n.getDependency("mesh", s.mesh).then(function(i) {
      const r = n._getNodeRef(n.meshCache, s.mesh, i);
      return s.weights !== void 0 && r.traverse(function(a) {
        if (a.isMesh)
          for (let l = 0, c = s.weights.length; l < c; l++)
            a.morphTargetInfluences[l] = s.weights[l];
      }), r;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
   * @param {number} nodeIndex
   * @return {Promise<Object3D>}
   */
  loadNode(e) {
    const t = this.json, n = this, s = t.nodes[e], i = n._loadNodeShallow(e), r = [], a = s.children || [];
    for (let c = 0, h = a.length; c < h; c++)
      r.push(n.getDependency("node", a[c]));
    const l = s.skin === void 0 ? Promise.resolve(null) : n.getDependency("skin", s.skin);
    return Promise.all([
      i,
      Promise.all(r),
      l
    ]).then(function(c) {
      const h = c[0], u = c[1], p = c[2];
      p !== null && h.traverse(function(f) {
        f.isSkinnedMesh && f.bind(p, sd);
      });
      for (let f = 0, g = u.length; f < g; f++)
        h.add(u[f]);
      return h;
    });
  }
  // ._loadNodeShallow() parses a single node.
  // skin and child nodes are created and added in .loadNode() (no '_' prefix).
  _loadNodeShallow(e) {
    const t = this.json, n = this.extensions, s = this;
    if (this.nodeCache[e] !== void 0)
      return this.nodeCache[e];
    const i = t.nodes[e], r = i.name ? s.createUniqueName(i.name) : "", a = [], l = s._invokeOne(function(c) {
      return c.createNodeMesh && c.createNodeMesh(e);
    });
    return l && a.push(l), i.camera !== void 0 && a.push(s.getDependency("camera", i.camera).then(function(c) {
      return s._getNodeRef(s.cameraCache, i.camera, c);
    })), s._invokeAll(function(c) {
      return c.createNodeAttachment && c.createNodeAttachment(e);
    }).forEach(function(c) {
      a.push(c);
    }), this.nodeCache[e] = Promise.all(a).then(function(c) {
      let h;
      if (i.isBone === !0 ? h = new ir() : c.length > 1 ? h = new Sn() : c.length === 1 ? h = c[0] : h = new Pt(), h !== c[0])
        for (let u = 0, p = c.length; u < p; u++)
          h.add(c[u]);
      if (i.name && (h.userData.name = i.name, h.name = r), qt(h, i), i.extensions && Dn(n, h, i), i.matrix !== void 0) {
        const u = new Re();
        u.fromArray(i.matrix), h.applyMatrix4(u);
      } else
        i.translation !== void 0 && h.position.fromArray(i.translation), i.rotation !== void 0 && h.quaternion.fromArray(i.rotation), i.scale !== void 0 && h.scale.fromArray(i.scale);
      return s.associations.has(h) || s.associations.set(h, {}), s.associations.get(h).nodes = e, h;
    }), this.nodeCache[e];
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
   * @param {number} sceneIndex
   * @return {Promise<Group>}
   */
  loadScene(e) {
    const t = this.extensions, n = this.json.scenes[e], s = this, i = new Sn();
    n.name && (i.name = s.createUniqueName(n.name)), qt(i, n), n.extensions && Dn(t, i, n);
    const r = n.nodes || [], a = [];
    for (let l = 0, c = r.length; l < c; l++)
      a.push(s.getDependency("node", r[l]));
    return Promise.all(a).then(function(l) {
      for (let h = 0, u = l.length; h < u; h++)
        i.add(l[h]);
      const c = (h) => {
        const u = /* @__PURE__ */ new Map();
        for (const [p, f] of s.associations)
          (p instanceof bi || p instanceof es) && u.set(p, f);
        return h.traverse((p) => {
          const f = s.associations.get(p);
          f != null && u.set(p, f);
        }), u;
      };
      return s.associations = c(i), i;
    });
  }
  _createAnimationTracks(e, t, n, s, i) {
    const r = [], a = e.name ? e.name : e.uuid, l = [];
    dn[i.path] === dn.weights ? e.traverse(function(p) {
      p.morphTargetInfluences && l.push(p.name ? p.name : p.uuid);
    }) : l.push(a);
    let c;
    switch (dn[i.path]) {
      case dn.weights:
        c = lr;
        break;
      case dn.rotation:
        c = ar;
        break;
      case dn.position:
      case dn.scale:
        c = or;
        break;
      default:
        switch (n.itemSize) {
          case 1:
            c = lr;
            break;
          case 2:
          case 3:
          default:
            c = or;
            break;
        }
        break;
    }
    const h = s.interpolation !== void 0 ? qf[s.interpolation] : br, u = this._getArrayFromAccessor(n);
    for (let p = 0, f = l.length; p < f; p++) {
      const g = new c(
        l[p] + "." + dn[i.path],
        t.array,
        u,
        h
      );
      s.interpolation === "CUBICSPLINE" && this._createCubicSplineTrackInterpolant(g), r.push(g);
    }
    return r;
  }
  _getArrayFromAccessor(e) {
    let t = e.array;
    if (e.normalized) {
      const n = gr(t.constructor), s = new Float32Array(t.length);
      for (let i = 0, r = t.length; i < r; i++)
        s[i] = t[i] * n;
      t = s;
    }
    return t;
  }
  _createCubicSplineTrackInterpolant(e) {
    e.createInterpolant = function(n) {
      const s = this instanceof ar ? Kf : ol;
      return new s(this.times, this.values, this.getValueSize() / 3, n);
    }, e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0;
  }
}
function rd(o, e, t) {
  const n = e.attributes, s = new Mt();
  if (n.POSITION !== void 0) {
    const a = t.json.accessors[n.POSITION], l = a.min, c = a.max;
    if (l !== void 0 && c !== void 0) {
      if (s.set(
        new $(l[0], l[1], l[2]),
        new $(c[0], c[1], c[2])
      ), a.normalized) {
        const h = gr(Jn[a.componentType]);
        s.min.multiplyScalar(h), s.max.multiplyScalar(h);
      }
    } else {
      console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      return;
    }
  } else
    return;
  const i = e.targets;
  if (i !== void 0) {
    const a = new $(), l = new $();
    for (let c = 0, h = i.length; c < h; c++) {
      const u = i[c];
      if (u.POSITION !== void 0) {
        const p = t.json.accessors[u.POSITION], f = p.min, g = p.max;
        if (f !== void 0 && g !== void 0) {
          if (l.setX(Math.max(Math.abs(f[0]), Math.abs(g[0]))), l.setY(Math.max(Math.abs(f[1]), Math.abs(g[1]))), l.setZ(Math.max(Math.abs(f[2]), Math.abs(g[2]))), p.normalized) {
            const m = gr(Jn[p.componentType]);
            l.multiplyScalar(m);
          }
          a.max(l);
        } else
          console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      }
    }
    s.expandByVector(a);
  }
  o.boundingBox = s;
  const r = new mi();
  s.getCenter(r.center), r.radius = s.min.distanceTo(s.max) / 2, o.boundingSphere = r;
}
function Do(o, e, t) {
  const n = e.attributes, s = [];
  function i(r, a) {
    return t.getDependency("accessor", r).then(function(l) {
      o.setAttribute(a, l);
    });
  }
  for (const r in n) {
    const a = mr[r] || r.toLowerCase();
    a in o.attributes || s.push(i(n[r], a));
  }
  if (e.indices !== void 0 && !o.index) {
    const r = t.getDependency("accessor", e.indices).then(function(a) {
      o.setIndex(a);
    });
    s.push(r);
  }
  return Wr.workingColorSpace !== sn && "COLOR_0" in n && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${Wr.workingColorSpace}" not supported.`), qt(o, e), rd(o, e, t), Promise.all(s).then(function() {
    return e.targets !== void 0 ? Jf(o, e.targets, t) : o;
  });
}
let Mn = null;
function od(o, e) {
  return (t) => {
    e && e(t), o.draco && (Mn || (Mn = new rf()), Mn.setDecoderPath(o.decoderPath || "https://www.gstatic.com/draco/versioned/decoders/1.4.3/"), t.setDRACOLoader && t.setDRACOLoader(Mn));
  };
}
async function ad(o, e = {
  draco: !1
}, t) {
  const n = await Nn(Mf, o, od(e, t));
  return Mn == null || Mn.dispose(), Mn = null, n;
}
const ld = ["object"], Vg = /* @__PURE__ */ me({
  __name: "component",
  props: {
    path: {},
    draco: { type: Boolean, default: !1 },
    decoderPath: { default: "https://www.gstatic.com/draco/versioned/decoders/1.4.1/" },
    castShadow: { type: Boolean, default: !1 },
    receiveShadow: { type: Boolean, default: !1 }
  },
  async setup(o, { expose: e }) {
    let t, n;
    const s = o, i = fe();
    e({
      instance: i
    });
    const { scene: r } = ([t, n] = Pn(() => ad(s.path, {
      draco: s.draco,
      decoderPath: s.decoderPath
    })), t = await t, n(), t);
    return (s.castShadow || s.receiveShadow) && r.traverse((a) => {
      a.isMesh && (a.castShadow = s.castShadow, a.receiveShadow = s.receiveShadow);
    }), (a, l) => (ue(), de("primitive", Xe({
      ref_key: "modelRef",
      ref: i,
      object: U(r)
    }, a.$attrs), null, 16, ld));
  }
}), al = "[TresJS - Cientos ▲ ■ ♥] ";
function cd(o, e) {
  console.error(`${al} ${o}`, e || "");
}
function ud(o) {
  console.warn(`${al} ${o}`);
}
function hd(o, e) {
}
function ll() {
  return {
    logError: cd,
    logWarning: ud,
    logMessage: hd
  };
}
let ji = 0;
function Yg() {
  const o = fe(!1), e = fe(0), t = fe([]), { logError: n } = ll();
  return new Promise((s) => {
    Us.onStart = () => {
      o.value = !1;
    }, Us.onLoad = () => {
      o.value = !0;
    }, Us.onProgress = (i, r, a) => {
      r === a && (ji = a, o.value = !0, t.value.push(i)), e.value = Math.round((r - ji) / (a - ji) * 100 || 100);
    }, Us.onError = (i) => {
      n("Error loading assets", new Error(i)), o.value = !0;
    }, s({
      items: t,
      hasFinishLoading: o,
      progress: e
    });
  });
}
async function Xg(o, e) {
  const { logError: t } = ll();
  if (!o)
    return t("Error no path provided");
  const { unsuspend: n, start: s, crossOrigin: i, muted: r, loop: a, ...l } = {
    unsuspend: "loadedmetadata",
    crossOrigin: "Anonymous",
    muted: !0,
    loop: !0,
    start: !0,
    playsInline: !0,
    ...e
  };
  function c() {
    return new Promise((h, u) => {
      const p = Object.assign(document.createElement("video"), {
        src: typeof o == "string" && o || void 0,
        crossOrigin: i,
        loop: a,
        muted: r,
        autoplay: !0,
        ...l
      }), f = new Ql(p);
      return p.addEventListener(n, () => h(f)), p.addEventListener("error", () => u(new Error("Error loading video"))), f;
    });
  }
  try {
    const h = await c();
    return s && h.image && h.image.play(), h;
  } catch {
    t("Error loading resource");
  }
}
var fd = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Rs(o) {
  return o && o.__esModule && Object.prototype.hasOwnProperty.call(o, "default") ? o.default : o;
}
function Qs(o) {
  throw new Error('Could not dynamically require "' + o + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var cl = { exports: {} };
(function(o, e) {
  (function(t) {
    o.exports = t();
  })(function() {
    return function t(n, s, i) {
      function r(c, h) {
        if (!s[c]) {
          if (!n[c]) {
            var u = typeof Qs == "function" && Qs;
            if (!h && u) return u(c, !0);
            if (a) return a(c, !0);
            throw new Error("Cannot find module '" + c + "'");
          }
          h = s[c] = { exports: {} }, n[c][0].call(h.exports, function(p) {
            var f = n[c][1][p];
            return r(f || p);
          }, h, h.exports, t, n, s, i);
        }
        return s[c].exports;
      }
      for (var a = typeof Qs == "function" && Qs, l = 0; l < i.length; l++) r(i[l]);
      return r;
    }({ 1: [function(t, n, s) {
      (function(i, r, a, l, c, h, u, p, f) {
        var g = t("crypto");
        function m(T, b) {
          b = w(T, b);
          var x;
          return (x = b.algorithm !== "passthrough" ? g.createHash(b.algorithm) : new P()).write === void 0 && (x.write = x.update, x.end = x.update), E(b, x).dispatch(T), x.update || x.end(""), x.digest ? x.digest(b.encoding === "buffer" ? void 0 : b.encoding) : (T = x.read(), b.encoding !== "buffer" ? T.toString(b.encoding) : T);
        }
        (s = n.exports = m).sha1 = function(T) {
          return m(T);
        }, s.keys = function(T) {
          return m(T, { excludeValues: !0, algorithm: "sha1", encoding: "hex" });
        }, s.MD5 = function(T) {
          return m(T, { algorithm: "md5", encoding: "hex" });
        }, s.keysMD5 = function(T) {
          return m(T, { algorithm: "md5", encoding: "hex", excludeValues: !0 });
        };
        var y = g.getHashes ? g.getHashes().slice() : ["sha1", "md5"], d = (y.push("passthrough"), ["buffer", "hex", "binary", "base64"]);
        function w(T, b) {
          var x = {};
          if (x.algorithm = (b = b || {}).algorithm || "sha1", x.encoding = b.encoding || "hex", x.excludeValues = !!b.excludeValues, x.algorithm = x.algorithm.toLowerCase(), x.encoding = x.encoding.toLowerCase(), x.ignoreUnknown = b.ignoreUnknown === !0, x.respectType = b.respectType !== !1, x.respectFunctionNames = b.respectFunctionNames !== !1, x.respectFunctionProperties = b.respectFunctionProperties !== !1, x.unorderedArrays = b.unorderedArrays === !0, x.unorderedSets = b.unorderedSets !== !1, x.unorderedObjects = b.unorderedObjects !== !1, x.replacer = b.replacer || void 0, x.excludeKeys = b.excludeKeys || void 0, T === void 0) throw new Error("Object argument required.");
          for (var M = 0; M < y.length; ++M) y[M].toLowerCase() === x.algorithm.toLowerCase() && (x.algorithm = y[M]);
          if (y.indexOf(x.algorithm) === -1) throw new Error('Algorithm "' + x.algorithm + '"  not supported. supported values: ' + y.join(", "));
          if (d.indexOf(x.encoding) === -1 && x.algorithm !== "passthrough") throw new Error('Encoding "' + x.encoding + '"  not supported. supported values: ' + d.join(", "));
          return x;
        }
        function v(T) {
          if (typeof T == "function") return /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i.exec(Function.prototype.toString.call(T)) != null;
        }
        function E(T, b, x) {
          x = x || [];
          function M(_) {
            return b.update ? b.update(_, "utf8") : b.write(_, "utf8");
          }
          return { dispatch: function(_) {
            return this["_" + ((_ = T.replacer ? T.replacer(_) : _) === null ? "null" : typeof _)](_);
          }, _object: function(_) {
            var C, R = Object.prototype.toString.call(_), B = /\[object (.*)\]/i.exec(R);
            if (B = (B = B ? B[1] : "unknown:[" + R + "]").toLowerCase(), 0 <= (R = x.indexOf(_))) return this.dispatch("[CIRCULAR:" + R + "]");
            if (x.push(_), a !== void 0 && a.isBuffer && a.isBuffer(_)) return M("buffer:"), M(_);
            if (B === "object" || B === "function" || B === "asyncfunction") return R = Object.keys(_), T.unorderedObjects && (R = R.sort()), T.respectType === !1 || v(_) || R.splice(0, 0, "prototype", "__proto__", "constructor"), T.excludeKeys && (R = R.filter(function(N) {
              return !T.excludeKeys(N);
            })), M("object:" + R.length + ":"), C = this, R.forEach(function(N) {
              C.dispatch(N), M(":"), T.excludeValues || C.dispatch(_[N]), M(",");
            });
            if (!this["_" + B]) {
              if (T.ignoreUnknown) return M("[" + B + "]");
              throw new Error('Unknown object type "' + B + '"');
            }
            this["_" + B](_);
          }, _array: function(_, N) {
            N = N !== void 0 ? N : T.unorderedArrays !== !1;
            var R = this;
            if (M("array:" + _.length + ":"), !N || _.length <= 1) return _.forEach(function(j) {
              return R.dispatch(j);
            });
            var B = [], N = _.map(function(j) {
              var V = new P(), Q = x.slice();
              return E(T, V, Q).dispatch(j), B = B.concat(Q.slice(x.length)), V.read().toString();
            });
            return x = x.concat(B), N.sort(), this._array(N, !1);
          }, _date: function(_) {
            return M("date:" + _.toJSON());
          }, _symbol: function(_) {
            return M("symbol:" + _.toString());
          }, _error: function(_) {
            return M("error:" + _.toString());
          }, _boolean: function(_) {
            return M("bool:" + _.toString());
          }, _string: function(_) {
            M("string:" + _.length + ":"), M(_.toString());
          }, _function: function(_) {
            M("fn:"), v(_) ? this.dispatch("[native]") : this.dispatch(_.toString()), T.respectFunctionNames !== !1 && this.dispatch("function-name:" + String(_.name)), T.respectFunctionProperties && this._object(_);
          }, _number: function(_) {
            return M("number:" + _.toString());
          }, _xml: function(_) {
            return M("xml:" + _.toString());
          }, _null: function() {
            return M("Null");
          }, _undefined: function() {
            return M("Undefined");
          }, _regexp: function(_) {
            return M("regex:" + _.toString());
          }, _uint8array: function(_) {
            return M("uint8array:"), this.dispatch(Array.prototype.slice.call(_));
          }, _uint8clampedarray: function(_) {
            return M("uint8clampedarray:"), this.dispatch(Array.prototype.slice.call(_));
          }, _int8array: function(_) {
            return M("int8array:"), this.dispatch(Array.prototype.slice.call(_));
          }, _uint16array: function(_) {
            return M("uint16array:"), this.dispatch(Array.prototype.slice.call(_));
          }, _int16array: function(_) {
            return M("int16array:"), this.dispatch(Array.prototype.slice.call(_));
          }, _uint32array: function(_) {
            return M("uint32array:"), this.dispatch(Array.prototype.slice.call(_));
          }, _int32array: function(_) {
            return M("int32array:"), this.dispatch(Array.prototype.slice.call(_));
          }, _float32array: function(_) {
            return M("float32array:"), this.dispatch(Array.prototype.slice.call(_));
          }, _float64array: function(_) {
            return M("float64array:"), this.dispatch(Array.prototype.slice.call(_));
          }, _arraybuffer: function(_) {
            return M("arraybuffer:"), this.dispatch(new Uint8Array(_));
          }, _url: function(_) {
            return M("url:" + _.toString());
          }, _map: function(_) {
            return M("map:"), _ = Array.from(_), this._array(_, T.unorderedSets !== !1);
          }, _set: function(_) {
            return M("set:"), _ = Array.from(_), this._array(_, T.unorderedSets !== !1);
          }, _file: function(_) {
            return M("file:"), this.dispatch([_.name, _.size, _.type, _.lastModfied]);
          }, _blob: function() {
            if (T.ignoreUnknown) return M("[blob]");
            throw Error(`Hashing Blob objects is currently not supported
(see https://github.com/puleos/object-hash/issues/26)
Use "options.replacer" or "options.ignoreUnknown"
`);
          }, _domwindow: function() {
            return M("domwindow");
          }, _bigint: function(_) {
            return M("bigint:" + _.toString());
          }, _process: function() {
            return M("process");
          }, _timer: function() {
            return M("timer");
          }, _pipe: function() {
            return M("pipe");
          }, _tcp: function() {
            return M("tcp");
          }, _udp: function() {
            return M("udp");
          }, _tty: function() {
            return M("tty");
          }, _statwatcher: function() {
            return M("statwatcher");
          }, _securecontext: function() {
            return M("securecontext");
          }, _connection: function() {
            return M("connection");
          }, _zlib: function() {
            return M("zlib");
          }, _context: function() {
            return M("context");
          }, _nodescript: function() {
            return M("nodescript");
          }, _httpparser: function() {
            return M("httpparser");
          }, _dataview: function() {
            return M("dataview");
          }, _signal: function() {
            return M("signal");
          }, _fsevent: function() {
            return M("fsevent");
          }, _tlswrap: function() {
            return M("tlswrap");
          } };
        }
        function P() {
          return { buf: "", write: function(T) {
            this.buf += T;
          }, end: function(T) {
            this.buf += T;
          }, read: function() {
            return this.buf;
          } };
        }
        s.writeToStream = function(T, b, x) {
          return x === void 0 && (x = b, b = {}), E(b = w(T, b), x).dispatch(T);
        };
      }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/fake_9a5aa49d.js", "/");
    }, { buffer: 3, crypto: 5, lYpoI2: 11 }], 2: [function(t, n, s) {
      (function(i, r, a, l, c, h, u, p, f) {
        (function(g) {
          var m = typeof Uint8Array < "u" ? Uint8Array : Array, y = 43, d = 47, w = 48, v = 97, E = 65, P = 45, T = 95;
          function b(x) {
            return x = x.charCodeAt(0), x === y || x === P ? 62 : x === d || x === T ? 63 : x < w ? -1 : x < w + 10 ? x - w + 26 + 26 : x < E + 26 ? x - E : x < v + 26 ? x - v + 26 : void 0;
          }
          g.toByteArray = function(x) {
            var M, _;
            if (0 < x.length % 4) throw new Error("Invalid string. Length must be a multiple of 4");
            var C = x.length, C = x.charAt(C - 2) === "=" ? 2 : x.charAt(C - 1) === "=" ? 1 : 0, R = new m(3 * x.length / 4 - C), B = 0 < C ? x.length - 4 : x.length, N = 0;
            function j(V) {
              R[N++] = V;
            }
            for (M = 0; M < B; M += 4, 0) j((16711680 & (_ = b(x.charAt(M)) << 18 | b(x.charAt(M + 1)) << 12 | b(x.charAt(M + 2)) << 6 | b(x.charAt(M + 3)))) >> 16), j((65280 & _) >> 8), j(255 & _);
            return C == 2 ? j(255 & (_ = b(x.charAt(M)) << 2 | b(x.charAt(M + 1)) >> 4)) : C == 1 && (j((_ = b(x.charAt(M)) << 10 | b(x.charAt(M + 1)) << 4 | b(x.charAt(M + 2)) >> 2) >> 8 & 255), j(255 & _)), R;
          }, g.fromByteArray = function(x) {
            var M, _, C, R, B = x.length % 3, N = "";
            function j(V) {
              return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(V);
            }
            for (M = 0, C = x.length - B; M < C; M += 3) _ = (x[M] << 16) + (x[M + 1] << 8) + x[M + 2], N += j((R = _) >> 18 & 63) + j(R >> 12 & 63) + j(R >> 6 & 63) + j(63 & R);
            switch (B) {
              case 1:
                N = (N += j((_ = x[x.length - 1]) >> 2)) + j(_ << 4 & 63) + "==";
                break;
              case 2:
                N = (N = (N += j((_ = (x[x.length - 2] << 8) + x[x.length - 1]) >> 10)) + j(_ >> 4 & 63)) + j(_ << 2 & 63) + "=";
            }
            return N;
          };
        })(s === void 0 ? this.base64js = {} : s);
      }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js", "/node_modules/gulp-browserify/node_modules/base64-js/lib");
    }, { buffer: 3, lYpoI2: 11 }], 3: [function(t, n, s) {
      (function(i, r, y, l, c, h, u, p, f) {
        var g = t("base64-js"), m = t("ieee754");
        function y(S, A, L) {
          if (!(this instanceof y)) return new y(S, A, L);
          var X, H, G, q, se = typeof S;
          if (A === "base64" && se == "string") for (S = (q = S).trim ? q.trim() : q.replace(/^\s+|\s+$/g, ""); S.length % 4 != 0; ) S += "=";
          if (se == "number") X = Z(S);
          else if (se == "string") X = y.byteLength(S, A);
          else {
            if (se != "object") throw new Error("First argument needs to be a number, array or string.");
            X = Z(S.length);
          }
          if (y._useTypedArrays ? H = y._augment(new Uint8Array(X)) : ((H = this).length = X, H._isBuffer = !0), y._useTypedArrays && typeof S.byteLength == "number") H._set(S);
          else if (ne(q = S) || y.isBuffer(q) || q && typeof q == "object" && typeof q.length == "number") for (G = 0; G < X; G++) y.isBuffer(S) ? H[G] = S.readUInt8(G) : H[G] = S[G];
          else if (se == "string") H.write(S, 0, A);
          else if (se == "number" && !y._useTypedArrays && !L) for (G = 0; G < X; G++) H[G] = 0;
          return H;
        }
        function d(S, A, L, X) {
          return y._charsWritten = Te(function(H) {
            for (var G = [], q = 0; q < H.length; q++) G.push(255 & H.charCodeAt(q));
            return G;
          }(A), S, L, X);
        }
        function w(S, A, L, X) {
          return y._charsWritten = Te(function(H) {
            for (var G, q, se = [], ie = 0; ie < H.length; ie++) q = H.charCodeAt(ie), G = q >> 8, q = q % 256, se.push(q), se.push(G);
            return se;
          }(A), S, L, X);
        }
        function v(S, A, L) {
          var X = "";
          L = Math.min(S.length, L);
          for (var H = A; H < L; H++) X += String.fromCharCode(S[H]);
          return X;
        }
        function E(S, A, L, G) {
          G || (z(typeof L == "boolean", "missing or invalid endian"), z(A != null, "missing offset"), z(A + 1 < S.length, "Trying to read beyond buffer length"));
          var H, G = S.length;
          if (!(G <= A)) return L ? (H = S[A], A + 1 < G && (H |= S[A + 1] << 8)) : (H = S[A] << 8, A + 1 < G && (H |= S[A + 1])), H;
        }
        function P(S, A, L, G) {
          G || (z(typeof L == "boolean", "missing or invalid endian"), z(A != null, "missing offset"), z(A + 3 < S.length, "Trying to read beyond buffer length"));
          var H, G = S.length;
          if (!(G <= A)) return L ? (A + 2 < G && (H = S[A + 2] << 16), A + 1 < G && (H |= S[A + 1] << 8), H |= S[A], A + 3 < G && (H += S[A + 3] << 24 >>> 0)) : (A + 1 < G && (H = S[A + 1] << 16), A + 2 < G && (H |= S[A + 2] << 8), A + 3 < G && (H |= S[A + 3]), H += S[A] << 24 >>> 0), H;
        }
        function T(S, A, L, X) {
          if (X || (z(typeof L == "boolean", "missing or invalid endian"), z(A != null, "missing offset"), z(A + 1 < S.length, "Trying to read beyond buffer length")), !(S.length <= A)) return X = E(S, A, L, !0), 32768 & X ? -1 * (65535 - X + 1) : X;
        }
        function b(S, A, L, X) {
          if (X || (z(typeof L == "boolean", "missing or invalid endian"), z(A != null, "missing offset"), z(A + 3 < S.length, "Trying to read beyond buffer length")), !(S.length <= A)) return X = P(S, A, L, !0), 2147483648 & X ? -1 * (4294967295 - X + 1) : X;
        }
        function x(S, A, L, X) {
          return X || (z(typeof L == "boolean", "missing or invalid endian"), z(A + 3 < S.length, "Trying to read beyond buffer length")), m.read(S, A, L, 23, 4);
        }
        function M(S, A, L, X) {
          return X || (z(typeof L == "boolean", "missing or invalid endian"), z(A + 7 < S.length, "Trying to read beyond buffer length")), m.read(S, A, L, 52, 8);
        }
        function _(S, A, L, X, H) {
          if (H || (z(A != null, "missing value"), z(typeof X == "boolean", "missing or invalid endian"), z(L != null, "missing offset"), z(L + 1 < S.length, "trying to write beyond buffer length"), k(A, 65535)), H = S.length, !(H <= L)) for (var G = 0, q = Math.min(H - L, 2); G < q; G++) S[L + G] = (A & 255 << 8 * (X ? G : 1 - G)) >>> 8 * (X ? G : 1 - G);
        }
        function C(S, A, L, X, H) {
          if (H || (z(A != null, "missing value"), z(typeof X == "boolean", "missing or invalid endian"), z(L != null, "missing offset"), z(L + 3 < S.length, "trying to write beyond buffer length"), k(A, 4294967295)), H = S.length, !(H <= L)) for (var G = 0, q = Math.min(H - L, 4); G < q; G++) S[L + G] = A >>> 8 * (X ? G : 3 - G) & 255;
        }
        function R(S, A, L, X, H) {
          H || (z(A != null, "missing value"), z(typeof X == "boolean", "missing or invalid endian"), z(L != null, "missing offset"), z(L + 1 < S.length, "Trying to write beyond buffer length"), D(A, 32767, -32768)), S.length <= L || _(S, 0 <= A ? A : 65535 + A + 1, L, X, H);
        }
        function B(S, A, L, X, H) {
          H || (z(A != null, "missing value"), z(typeof X == "boolean", "missing or invalid endian"), z(L != null, "missing offset"), z(L + 3 < S.length, "Trying to write beyond buffer length"), D(A, 2147483647, -2147483648)), S.length <= L || C(S, 0 <= A ? A : 4294967295 + A + 1, L, X, H);
        }
        function N(S, A, L, X, H) {
          H || (z(A != null, "missing value"), z(typeof X == "boolean", "missing or invalid endian"), z(L != null, "missing offset"), z(L + 3 < S.length, "Trying to write beyond buffer length"), O(A, 34028234663852886e22, -34028234663852886e22)), S.length <= L || m.write(S, A, L, X, 23, 4);
        }
        function j(S, A, L, X, H) {
          H || (z(A != null, "missing value"), z(typeof X == "boolean", "missing or invalid endian"), z(L != null, "missing offset"), z(L + 7 < S.length, "Trying to write beyond buffer length"), O(A, 17976931348623157e292, -17976931348623157e292)), S.length <= L || m.write(S, A, L, X, 52, 8);
        }
        s.Buffer = y, s.SlowBuffer = y, s.INSPECT_MAX_BYTES = 50, y.poolSize = 8192, y._useTypedArrays = function() {
          try {
            var S = new ArrayBuffer(0), A = new Uint8Array(S);
            return A.foo = function() {
              return 42;
            }, A.foo() === 42 && typeof A.subarray == "function";
          } catch {
            return !1;
          }
        }(), y.isEncoding = function(S) {
          switch (String(S).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "binary":
            case "base64":
            case "raw":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return !0;
            default:
              return !1;
          }
        }, y.isBuffer = function(S) {
          return !(S == null || !S._isBuffer);
        }, y.byteLength = function(S, A) {
          var L;
          switch (S += "", A || "utf8") {
            case "hex":
              L = S.length / 2;
              break;
            case "utf8":
            case "utf-8":
              L = le(S).length;
              break;
            case "ascii":
            case "binary":
            case "raw":
              L = S.length;
              break;
            case "base64":
              L = ae(S).length;
              break;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              L = 2 * S.length;
              break;
            default:
              throw new Error("Unknown encoding");
          }
          return L;
        }, y.concat = function(S, A) {
          if (z(ne(S), `Usage: Buffer.concat(list, [totalLength])
list should be an Array.`), S.length === 0) return new y(0);
          if (S.length === 1) return S[0];
          if (typeof A != "number") for (H = A = 0; H < S.length; H++) A += S[H].length;
          for (var L = new y(A), X = 0, H = 0; H < S.length; H++) {
            var G = S[H];
            G.copy(L, X), X += G.length;
          }
          return L;
        }, y.prototype.write = function(S, A, L, X) {
          isFinite(A) ? isFinite(L) || (X = L, L = void 0) : (ie = X, X = A, A = L, L = ie), A = Number(A) || 0;
          var H, G, q, se, ie = this.length - A;
          switch ((!L || ie < (L = Number(L))) && (L = ie), X = String(X || "utf8").toLowerCase()) {
            case "hex":
              H = function(Y, F, oe, pe) {
                oe = Number(oe) || 0;
                var Ae = Y.length - oe;
                (!pe || Ae < (pe = Number(pe))) && (pe = Ae), z((Ae = F.length) % 2 == 0, "Invalid hex string"), Ae / 2 < pe && (pe = Ae / 2);
                for (var Ve = 0; Ve < pe; Ve++) {
                  var We = parseInt(F.substr(2 * Ve, 2), 16);
                  z(!isNaN(We), "Invalid hex string"), Y[oe + Ve] = We;
                }
                return y._charsWritten = 2 * Ve, Ve;
              }(this, S, A, L);
              break;
            case "utf8":
            case "utf-8":
              G = this, q = A, se = L, H = y._charsWritten = Te(le(S), G, q, se);
              break;
            case "ascii":
            case "binary":
              H = d(this, S, A, L);
              break;
            case "base64":
              G = this, q = A, se = L, H = y._charsWritten = Te(ae(S), G, q, se);
              break;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              H = w(this, S, A, L);
              break;
            default:
              throw new Error("Unknown encoding");
          }
          return H;
        }, y.prototype.toString = function(S, A, L) {
          var X, H, G, q, se = this;
          if (S = String(S || "utf8").toLowerCase(), A = Number(A) || 0, (L = L !== void 0 ? Number(L) : se.length) === A) return "";
          switch (S) {
            case "hex":
              X = function(ie, Y, F) {
                var oe = ie.length;
                (!Y || Y < 0) && (Y = 0), (!F || F < 0 || oe < F) && (F = oe);
                for (var pe = "", Ae = Y; Ae < F; Ae++) pe += te(ie[Ae]);
                return pe;
              }(se, A, L);
              break;
            case "utf8":
            case "utf-8":
              X = function(ie, Y, F) {
                var oe = "", pe = "";
                F = Math.min(ie.length, F);
                for (var Ae = Y; Ae < F; Ae++) ie[Ae] <= 127 ? (oe += I(pe) + String.fromCharCode(ie[Ae]), pe = "") : pe += "%" + ie[Ae].toString(16);
                return oe + I(pe);
              }(se, A, L);
              break;
            case "ascii":
            case "binary":
              X = v(se, A, L);
              break;
            case "base64":
              H = se, q = L, X = (G = A) === 0 && q === H.length ? g.fromByteArray(H) : g.fromByteArray(H.slice(G, q));
              break;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              X = function(ie, Y, F) {
                for (var oe = ie.slice(Y, F), pe = "", Ae = 0; Ae < oe.length; Ae += 2) pe += String.fromCharCode(oe[Ae] + 256 * oe[Ae + 1]);
                return pe;
              }(se, A, L);
              break;
            default:
              throw new Error("Unknown encoding");
          }
          return X;
        }, y.prototype.toJSON = function() {
          return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
        }, y.prototype.copy = function(S, A, L, X) {
          if (A = A || 0, (X = X || X === 0 ? X : this.length) !== (L = L || 0) && S.length !== 0 && this.length !== 0) {
            z(L <= X, "sourceEnd < sourceStart"), z(0 <= A && A < S.length, "targetStart out of bounds"), z(0 <= L && L < this.length, "sourceStart out of bounds"), z(0 <= X && X <= this.length, "sourceEnd out of bounds"), X > this.length && (X = this.length);
            var H = (X = S.length - A < X - L ? S.length - A + L : X) - L;
            if (H < 100 || !y._useTypedArrays) for (var G = 0; G < H; G++) S[G + A] = this[G + L];
            else S._set(this.subarray(L, L + H), A);
          }
        }, y.prototype.slice = function(S, A) {
          var L = this.length;
          if (S = Q(S, L, 0), A = Q(A, L, L), y._useTypedArrays) return y._augment(this.subarray(S, A));
          for (var X = A - S, H = new y(X, void 0, !0), G = 0; G < X; G++) H[G] = this[G + S];
          return H;
        }, y.prototype.get = function(S) {
          return console.log(".get() is deprecated. Access using array indexes instead."), this.readUInt8(S);
        }, y.prototype.set = function(S, A) {
          return console.log(".set() is deprecated. Access using array indexes instead."), this.writeUInt8(S, A);
        }, y.prototype.readUInt8 = function(S, A) {
          if (A || (z(S != null, "missing offset"), z(S < this.length, "Trying to read beyond buffer length")), !(S >= this.length)) return this[S];
        }, y.prototype.readUInt16LE = function(S, A) {
          return E(this, S, !0, A);
        }, y.prototype.readUInt16BE = function(S, A) {
          return E(this, S, !1, A);
        }, y.prototype.readUInt32LE = function(S, A) {
          return P(this, S, !0, A);
        }, y.prototype.readUInt32BE = function(S, A) {
          return P(this, S, !1, A);
        }, y.prototype.readInt8 = function(S, A) {
          if (A || (z(S != null, "missing offset"), z(S < this.length, "Trying to read beyond buffer length")), !(S >= this.length)) return 128 & this[S] ? -1 * (255 - this[S] + 1) : this[S];
        }, y.prototype.readInt16LE = function(S, A) {
          return T(this, S, !0, A);
        }, y.prototype.readInt16BE = function(S, A) {
          return T(this, S, !1, A);
        }, y.prototype.readInt32LE = function(S, A) {
          return b(this, S, !0, A);
        }, y.prototype.readInt32BE = function(S, A) {
          return b(this, S, !1, A);
        }, y.prototype.readFloatLE = function(S, A) {
          return x(this, S, !0, A);
        }, y.prototype.readFloatBE = function(S, A) {
          return x(this, S, !1, A);
        }, y.prototype.readDoubleLE = function(S, A) {
          return M(this, S, !0, A);
        }, y.prototype.readDoubleBE = function(S, A) {
          return M(this, S, !1, A);
        }, y.prototype.writeUInt8 = function(S, A, L) {
          L || (z(S != null, "missing value"), z(A != null, "missing offset"), z(A < this.length, "trying to write beyond buffer length"), k(S, 255)), A >= this.length || (this[A] = S);
        }, y.prototype.writeUInt16LE = function(S, A, L) {
          _(this, S, A, !0, L);
        }, y.prototype.writeUInt16BE = function(S, A, L) {
          _(this, S, A, !1, L);
        }, y.prototype.writeUInt32LE = function(S, A, L) {
          C(this, S, A, !0, L);
        }, y.prototype.writeUInt32BE = function(S, A, L) {
          C(this, S, A, !1, L);
        }, y.prototype.writeInt8 = function(S, A, L) {
          L || (z(S != null, "missing value"), z(A != null, "missing offset"), z(A < this.length, "Trying to write beyond buffer length"), D(S, 127, -128)), A >= this.length || (0 <= S ? this.writeUInt8(S, A, L) : this.writeUInt8(255 + S + 1, A, L));
        }, y.prototype.writeInt16LE = function(S, A, L) {
          R(this, S, A, !0, L);
        }, y.prototype.writeInt16BE = function(S, A, L) {
          R(this, S, A, !1, L);
        }, y.prototype.writeInt32LE = function(S, A, L) {
          B(this, S, A, !0, L);
        }, y.prototype.writeInt32BE = function(S, A, L) {
          B(this, S, A, !1, L);
        }, y.prototype.writeFloatLE = function(S, A, L) {
          N(this, S, A, !0, L);
        }, y.prototype.writeFloatBE = function(S, A, L) {
          N(this, S, A, !1, L);
        }, y.prototype.writeDoubleLE = function(S, A, L) {
          j(this, S, A, !0, L);
        }, y.prototype.writeDoubleBE = function(S, A, L) {
          j(this, S, A, !1, L);
        }, y.prototype.fill = function(S, A, L) {
          if (A = A || 0, L = L || this.length, z(typeof (S = typeof (S = S || 0) == "string" ? S.charCodeAt(0) : S) == "number" && !isNaN(S), "value is not a number"), z(A <= L, "end < start"), L !== A && this.length !== 0) {
            z(0 <= A && A < this.length, "start out of bounds"), z(0 <= L && L <= this.length, "end out of bounds");
            for (var X = A; X < L; X++) this[X] = S;
          }
        }, y.prototype.inspect = function() {
          for (var S = [], A = this.length, L = 0; L < A; L++) if (S[L] = te(this[L]), L === s.INSPECT_MAX_BYTES) {
            S[L + 1] = "...";
            break;
          }
          return "<Buffer " + S.join(" ") + ">";
        }, y.prototype.toArrayBuffer = function() {
          if (typeof Uint8Array > "u") throw new Error("Buffer.toArrayBuffer not supported in this browser");
          if (y._useTypedArrays) return new y(this).buffer;
          for (var S = new Uint8Array(this.length), A = 0, L = S.length; A < L; A += 1) S[A] = this[A];
          return S.buffer;
        };
        var V = y.prototype;
        function Q(S, A, L) {
          return typeof S != "number" ? L : A <= (S = ~~S) ? A : 0 <= S || 0 <= (S += A) ? S : 0;
        }
        function Z(S) {
          return (S = ~~Math.ceil(+S)) < 0 ? 0 : S;
        }
        function ne(S) {
          return (Array.isArray || function(A) {
            return Object.prototype.toString.call(A) === "[object Array]";
          })(S);
        }
        function te(S) {
          return S < 16 ? "0" + S.toString(16) : S.toString(16);
        }
        function le(S) {
          for (var A = [], L = 0; L < S.length; L++) {
            var X = S.charCodeAt(L);
            if (X <= 127) A.push(S.charCodeAt(L));
            else for (var H = L, G = (55296 <= X && X <= 57343 && L++, encodeURIComponent(S.slice(H, L + 1)).substr(1).split("%")), q = 0; q < G.length; q++) A.push(parseInt(G[q], 16));
          }
          return A;
        }
        function ae(S) {
          return g.toByteArray(S);
        }
        function Te(S, A, L, X) {
          for (var H = 0; H < X && !(H + L >= A.length || H >= S.length); H++) A[H + L] = S[H];
          return H;
        }
        function I(S) {
          try {
            return decodeURIComponent(S);
          } catch {
            return "�";
          }
        }
        function k(S, A) {
          z(typeof S == "number", "cannot write a non-number as a number"), z(0 <= S, "specified a negative value for writing an unsigned value"), z(S <= A, "value is larger than maximum value for type"), z(Math.floor(S) === S, "value has a fractional component");
        }
        function D(S, A, L) {
          z(typeof S == "number", "cannot write a non-number as a number"), z(S <= A, "value larger than maximum allowed value"), z(L <= S, "value smaller than minimum allowed value"), z(Math.floor(S) === S, "value has a fractional component");
        }
        function O(S, A, L) {
          z(typeof S == "number", "cannot write a non-number as a number"), z(S <= A, "value larger than maximum allowed value"), z(L <= S, "value smaller than minimum allowed value");
        }
        function z(S, A) {
          if (!S) throw new Error(A || "Failed assertion");
        }
        y._augment = function(S) {
          return S._isBuffer = !0, S._get = S.get, S._set = S.set, S.get = V.get, S.set = V.set, S.write = V.write, S.toString = V.toString, S.toLocaleString = V.toString, S.toJSON = V.toJSON, S.copy = V.copy, S.slice = V.slice, S.readUInt8 = V.readUInt8, S.readUInt16LE = V.readUInt16LE, S.readUInt16BE = V.readUInt16BE, S.readUInt32LE = V.readUInt32LE, S.readUInt32BE = V.readUInt32BE, S.readInt8 = V.readInt8, S.readInt16LE = V.readInt16LE, S.readInt16BE = V.readInt16BE, S.readInt32LE = V.readInt32LE, S.readInt32BE = V.readInt32BE, S.readFloatLE = V.readFloatLE, S.readFloatBE = V.readFloatBE, S.readDoubleLE = V.readDoubleLE, S.readDoubleBE = V.readDoubleBE, S.writeUInt8 = V.writeUInt8, S.writeUInt16LE = V.writeUInt16LE, S.writeUInt16BE = V.writeUInt16BE, S.writeUInt32LE = V.writeUInt32LE, S.writeUInt32BE = V.writeUInt32BE, S.writeInt8 = V.writeInt8, S.writeInt16LE = V.writeInt16LE, S.writeInt16BE = V.writeInt16BE, S.writeInt32LE = V.writeInt32LE, S.writeInt32BE = V.writeInt32BE, S.writeFloatLE = V.writeFloatLE, S.writeFloatBE = V.writeFloatBE, S.writeDoubleLE = V.writeDoubleLE, S.writeDoubleBE = V.writeDoubleBE, S.fill = V.fill, S.inspect = V.inspect, S.toArrayBuffer = V.toArrayBuffer, S;
        };
      }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/buffer/index.js", "/node_modules/gulp-browserify/node_modules/buffer");
    }, { "base64-js": 2, buffer: 3, ieee754: 10, lYpoI2: 11 }], 4: [function(t, n, s) {
      (function(i, r, g, l, c, h, u, p, f) {
        var g = t("buffer").Buffer, m = 4, y = new g(m);
        y.fill(0), n.exports = { hash: function(d, w, v, E) {
          for (var P = w(function(_, C) {
            _.length % m != 0 && (R = _.length + (m - _.length % m), _ = g.concat([_, y], R));
            for (var R, B = [], N = C ? _.readInt32BE : _.readInt32LE, j = 0; j < _.length; j += m) B.push(N.call(_, j));
            return B;
          }(d = g.isBuffer(d) ? d : new g(d), E), 8 * d.length), w = E, T = new g(v), b = w ? T.writeInt32BE : T.writeInt32LE, x = 0; x < P.length; x++) b.call(T, P[x], 4 * x, !0);
          return T;
        } };
      }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/helpers.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { buffer: 3, lYpoI2: 11 }], 5: [function(t, n, s) {
      (function(i, r, g, l, c, h, u, p, f) {
        var g = t("buffer").Buffer, m = t("./sha"), y = t("./sha256"), d = t("./rng"), w = { sha1: m, sha256: y, md5: t("./md5") }, v = 64, E = new g(v);
        function P(_, C) {
          var R = w[_ = _ || "sha1"], B = [];
          return R || T("algorithm:", _, "is not yet supported"), { update: function(N) {
            return g.isBuffer(N) || (N = new g(N)), B.push(N), N.length, this;
          }, digest: function(N) {
            var j = g.concat(B), j = C ? function(V, Q, Z) {
              g.isBuffer(Q) || (Q = new g(Q)), g.isBuffer(Z) || (Z = new g(Z)), Q.length > v ? Q = V(Q) : Q.length < v && (Q = g.concat([Q, E], v));
              for (var ne = new g(v), te = new g(v), le = 0; le < v; le++) ne[le] = 54 ^ Q[le], te[le] = 92 ^ Q[le];
              return Z = V(g.concat([ne, Z])), V(g.concat([te, Z]));
            }(R, C, j) : R(j);
            return B = null, N ? j.toString(N) : j;
          } };
        }
        function T() {
          var _ = [].slice.call(arguments).join(" ");
          throw new Error([_, "we accept pull requests", "http://github.com/dominictarr/crypto-browserify"].join(`
`));
        }
        E.fill(0), s.createHash = function(_) {
          return P(_);
        }, s.createHmac = P, s.randomBytes = function(_, C) {
          if (!C || !C.call) return new g(d(_));
          try {
            C.call(this, void 0, new g(d(_)));
          } catch (R) {
            C(R);
          }
        };
        var b, x = ["createCredentials", "createCipher", "createCipheriv", "createDecipher", "createDecipheriv", "createSign", "createVerify", "createDiffieHellman", "pbkdf2"], M = function(_) {
          s[_] = function() {
            T("sorry,", _, "is not implemented yet");
          };
        };
        for (b in x) M(x[b]);
      }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/index.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { "./md5": 6, "./rng": 7, "./sha": 8, "./sha256": 9, buffer: 3, lYpoI2: 11 }], 6: [function(t, n, s) {
      (function(i, r, a, l, c, h, u, p, f) {
        var g = t("./helpers");
        function m(T, b) {
          T[b >> 5] |= 128 << b % 32, T[14 + (b + 64 >>> 9 << 4)] = b;
          for (var x = 1732584193, M = -271733879, _ = -1732584194, C = 271733878, R = 0; R < T.length; R += 16) {
            var B = x, N = M, j = _, V = C, x = d(x, M, _, C, T[R + 0], 7, -680876936), C = d(C, x, M, _, T[R + 1], 12, -389564586), _ = d(_, C, x, M, T[R + 2], 17, 606105819), M = d(M, _, C, x, T[R + 3], 22, -1044525330);
            x = d(x, M, _, C, T[R + 4], 7, -176418897), C = d(C, x, M, _, T[R + 5], 12, 1200080426), _ = d(_, C, x, M, T[R + 6], 17, -1473231341), M = d(M, _, C, x, T[R + 7], 22, -45705983), x = d(x, M, _, C, T[R + 8], 7, 1770035416), C = d(C, x, M, _, T[R + 9], 12, -1958414417), _ = d(_, C, x, M, T[R + 10], 17, -42063), M = d(M, _, C, x, T[R + 11], 22, -1990404162), x = d(x, M, _, C, T[R + 12], 7, 1804603682), C = d(C, x, M, _, T[R + 13], 12, -40341101), _ = d(_, C, x, M, T[R + 14], 17, -1502002290), x = w(x, M = d(M, _, C, x, T[R + 15], 22, 1236535329), _, C, T[R + 1], 5, -165796510), C = w(C, x, M, _, T[R + 6], 9, -1069501632), _ = w(_, C, x, M, T[R + 11], 14, 643717713), M = w(M, _, C, x, T[R + 0], 20, -373897302), x = w(x, M, _, C, T[R + 5], 5, -701558691), C = w(C, x, M, _, T[R + 10], 9, 38016083), _ = w(_, C, x, M, T[R + 15], 14, -660478335), M = w(M, _, C, x, T[R + 4], 20, -405537848), x = w(x, M, _, C, T[R + 9], 5, 568446438), C = w(C, x, M, _, T[R + 14], 9, -1019803690), _ = w(_, C, x, M, T[R + 3], 14, -187363961), M = w(M, _, C, x, T[R + 8], 20, 1163531501), x = w(x, M, _, C, T[R + 13], 5, -1444681467), C = w(C, x, M, _, T[R + 2], 9, -51403784), _ = w(_, C, x, M, T[R + 7], 14, 1735328473), x = v(x, M = w(M, _, C, x, T[R + 12], 20, -1926607734), _, C, T[R + 5], 4, -378558), C = v(C, x, M, _, T[R + 8], 11, -2022574463), _ = v(_, C, x, M, T[R + 11], 16, 1839030562), M = v(M, _, C, x, T[R + 14], 23, -35309556), x = v(x, M, _, C, T[R + 1], 4, -1530992060), C = v(C, x, M, _, T[R + 4], 11, 1272893353), _ = v(_, C, x, M, T[R + 7], 16, -155497632), M = v(M, _, C, x, T[R + 10], 23, -1094730640), x = v(x, M, _, C, T[R + 13], 4, 681279174), C = v(C, x, M, _, T[R + 0], 11, -358537222), _ = v(_, C, x, M, T[R + 3], 16, -722521979), M = v(M, _, C, x, T[R + 6], 23, 76029189), x = v(x, M, _, C, T[R + 9], 4, -640364487), C = v(C, x, M, _, T[R + 12], 11, -421815835), _ = v(_, C, x, M, T[R + 15], 16, 530742520), x = E(x, M = v(M, _, C, x, T[R + 2], 23, -995338651), _, C, T[R + 0], 6, -198630844), C = E(C, x, M, _, T[R + 7], 10, 1126891415), _ = E(_, C, x, M, T[R + 14], 15, -1416354905), M = E(M, _, C, x, T[R + 5], 21, -57434055), x = E(x, M, _, C, T[R + 12], 6, 1700485571), C = E(C, x, M, _, T[R + 3], 10, -1894986606), _ = E(_, C, x, M, T[R + 10], 15, -1051523), M = E(M, _, C, x, T[R + 1], 21, -2054922799), x = E(x, M, _, C, T[R + 8], 6, 1873313359), C = E(C, x, M, _, T[R + 15], 10, -30611744), _ = E(_, C, x, M, T[R + 6], 15, -1560198380), M = E(M, _, C, x, T[R + 13], 21, 1309151649), x = E(x, M, _, C, T[R + 4], 6, -145523070), C = E(C, x, M, _, T[R + 11], 10, -1120210379), _ = E(_, C, x, M, T[R + 2], 15, 718787259), M = E(M, _, C, x, T[R + 9], 21, -343485551), x = P(x, B), M = P(M, N), _ = P(_, j), C = P(C, V);
          }
          return Array(x, M, _, C);
        }
        function y(T, b, x, M, _, C) {
          return P((b = P(P(b, T), P(M, C))) << _ | b >>> 32 - _, x);
        }
        function d(T, b, x, M, _, C, R) {
          return y(b & x | ~b & M, T, b, _, C, R);
        }
        function w(T, b, x, M, _, C, R) {
          return y(b & M | x & ~M, T, b, _, C, R);
        }
        function v(T, b, x, M, _, C, R) {
          return y(b ^ x ^ M, T, b, _, C, R);
        }
        function E(T, b, x, M, _, C, R) {
          return y(x ^ (b | ~M), T, b, _, C, R);
        }
        function P(T, b) {
          var x = (65535 & T) + (65535 & b);
          return (T >> 16) + (b >> 16) + (x >> 16) << 16 | 65535 & x;
        }
        n.exports = function(T) {
          return g.hash(T, m, 16);
        };
      }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/md5.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 7: [function(t, n, s) {
      (function(i, r, a, l, c, h, u, p, f) {
        n.exports = function(g) {
          for (var m, y = new Array(g), d = 0; d < g; d++) !(3 & d) && (m = 4294967296 * Math.random()), y[d] = m >>> ((3 & d) << 3) & 255;
          return y;
        };
      }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/rng.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { buffer: 3, lYpoI2: 11 }], 8: [function(t, n, s) {
      (function(i, r, a, l, c, h, u, p, f) {
        var g = t("./helpers");
        function m(w, v) {
          w[v >> 5] |= 128 << 24 - v % 32, w[15 + (v + 64 >> 9 << 4)] = v;
          for (var E, P, T, b = Array(80), x = 1732584193, M = -271733879, _ = -1732584194, C = 271733878, R = -1009589776, B = 0; B < w.length; B += 16) {
            for (var N = x, j = M, V = _, Q = C, Z = R, ne = 0; ne < 80; ne++) {
              b[ne] = ne < 16 ? w[B + ne] : d(b[ne - 3] ^ b[ne - 8] ^ b[ne - 14] ^ b[ne - 16], 1);
              var te = y(y(d(x, 5), (te = M, P = _, T = C, (E = ne) < 20 ? te & P | ~te & T : !(E < 40) && E < 60 ? te & P | te & T | P & T : te ^ P ^ T)), y(y(R, b[ne]), (E = ne) < 20 ? 1518500249 : E < 40 ? 1859775393 : E < 60 ? -1894007588 : -899497514)), R = C, C = _, _ = d(M, 30), M = x, x = te;
            }
            x = y(x, N), M = y(M, j), _ = y(_, V), C = y(C, Q), R = y(R, Z);
          }
          return Array(x, M, _, C, R);
        }
        function y(w, v) {
          var E = (65535 & w) + (65535 & v);
          return (w >> 16) + (v >> 16) + (E >> 16) << 16 | 65535 & E;
        }
        function d(w, v) {
          return w << v | w >>> 32 - v;
        }
        n.exports = function(w) {
          return g.hash(w, m, 20, !0);
        };
      }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 9: [function(t, n, s) {
      (function(i, r, a, l, c, h, u, p, f) {
        function g(v, E) {
          var P = (65535 & v) + (65535 & E);
          return (v >> 16) + (E >> 16) + (P >> 16) << 16 | 65535 & P;
        }
        function m(v, E) {
          var P, T = new Array(1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298), b = new Array(1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225), x = new Array(64);
          v[E >> 5] |= 128 << 24 - E % 32, v[15 + (E + 64 >> 9 << 4)] = E;
          for (var M, _, C = 0; C < v.length; C += 16) {
            for (var R = b[0], B = b[1], N = b[2], j = b[3], V = b[4], Q = b[5], Z = b[6], ne = b[7], te = 0; te < 64; te++) x[te] = te < 16 ? v[te + C] : g(g(g((_ = x[te - 2], d(_, 17) ^ d(_, 19) ^ w(_, 10)), x[te - 7]), (_ = x[te - 15], d(_, 7) ^ d(_, 18) ^ w(_, 3))), x[te - 16]), P = g(g(g(g(ne, d(_ = V, 6) ^ d(_, 11) ^ d(_, 25)), V & Q ^ ~V & Z), T[te]), x[te]), M = g(d(M = R, 2) ^ d(M, 13) ^ d(M, 22), R & B ^ R & N ^ B & N), ne = Z, Z = Q, Q = V, V = g(j, P), j = N, N = B, B = R, R = g(P, M);
            b[0] = g(R, b[0]), b[1] = g(B, b[1]), b[2] = g(N, b[2]), b[3] = g(j, b[3]), b[4] = g(V, b[4]), b[5] = g(Q, b[5]), b[6] = g(Z, b[6]), b[7] = g(ne, b[7]);
          }
          return b;
        }
        var y = t("./helpers"), d = function(v, E) {
          return v >>> E | v << 32 - E;
        }, w = function(v, E) {
          return v >>> E;
        };
        n.exports = function(v) {
          return y.hash(v, m, 32, !0);
        };
      }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha256.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 10: [function(t, n, s) {
      (function(i, r, a, l, c, h, u, p, f) {
        s.read = function(g, m, y, d, C) {
          var v, E, P = 8 * C - d - 1, T = (1 << P) - 1, b = T >> 1, x = -7, M = y ? C - 1 : 0, _ = y ? -1 : 1, C = g[m + M];
          for (M += _, v = C & (1 << -x) - 1, C >>= -x, x += P; 0 < x; v = 256 * v + g[m + M], M += _, x -= 8) ;
          for (E = v & (1 << -x) - 1, v >>= -x, x += d; 0 < x; E = 256 * E + g[m + M], M += _, x -= 8) ;
          if (v === 0) v = 1 - b;
          else {
            if (v === T) return E ? NaN : 1 / 0 * (C ? -1 : 1);
            E += Math.pow(2, d), v -= b;
          }
          return (C ? -1 : 1) * E * Math.pow(2, v - d);
        }, s.write = function(g, m, y, d, w, R) {
          var E, P, T = 8 * R - w - 1, b = (1 << T) - 1, x = b >> 1, M = w === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, _ = d ? 0 : R - 1, C = d ? 1 : -1, R = m < 0 || m === 0 && 1 / m < 0 ? 1 : 0;
          for (m = Math.abs(m), isNaN(m) || m === 1 / 0 ? (P = isNaN(m) ? 1 : 0, E = b) : (E = Math.floor(Math.log(m) / Math.LN2), m * (d = Math.pow(2, -E)) < 1 && (E--, d *= 2), 2 <= (m += 1 <= E + x ? M / d : M * Math.pow(2, 1 - x)) * d && (E++, d /= 2), b <= E + x ? (P = 0, E = b) : 1 <= E + x ? (P = (m * d - 1) * Math.pow(2, w), E += x) : (P = m * Math.pow(2, x - 1) * Math.pow(2, w), E = 0)); 8 <= w; g[y + _] = 255 & P, _ += C, P /= 256, w -= 8) ;
          for (E = E << w | P, T += w; 0 < T; g[y + _] = 255 & E, _ += C, E /= 256, T -= 8) ;
          g[y + _ - C] |= 128 * R;
        };
      }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/ieee754/index.js", "/node_modules/gulp-browserify/node_modules/ieee754");
    }, { buffer: 3, lYpoI2: 11 }], 11: [function(t, n, s) {
      (function(i, r, a, l, c, h, u, p, f) {
        var g, m, y;
        function d() {
        }
        (i = n.exports = {}).nextTick = (m = typeof window < "u" && window.setImmediate, y = typeof window < "u" && window.postMessage && window.addEventListener, m ? function(w) {
          return window.setImmediate(w);
        } : y ? (g = [], window.addEventListener("message", function(w) {
          var v = w.source;
          v !== window && v !== null || w.data !== "process-tick" || (w.stopPropagation(), 0 < g.length && g.shift()());
        }, !0), function(w) {
          g.push(w), window.postMessage("process-tick", "*");
        }) : function(w) {
          setTimeout(w, 0);
        }), i.title = "browser", i.browser = !0, i.env = {}, i.argv = [], i.on = d, i.addListener = d, i.once = d, i.off = d, i.removeListener = d, i.removeAllListeners = d, i.emit = d, i.binding = function(w) {
          throw new Error("process.binding is not supported");
        }, i.cwd = function() {
          return "/";
        }, i.chdir = function(w) {
          throw new Error("process.chdir is not supported");
        };
      }).call(this, t("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, t("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/process/browser.js", "/node_modules/gulp-browserify/node_modules/process");
    }, { buffer: 3, lYpoI2: 11 }] }, {}, [1])(1);
  });
})(cl);
var dd = cl.exports;
const pd = /* @__PURE__ */ Rs(dd);
var ul = [
  // current
  "precision",
  "highp",
  "mediump",
  "lowp",
  "attribute",
  "const",
  "uniform",
  "varying",
  "break",
  "continue",
  "do",
  "for",
  "while",
  "if",
  "else",
  "in",
  "out",
  "inout",
  "float",
  "int",
  "uint",
  "void",
  "bool",
  "true",
  "false",
  "discard",
  "return",
  "mat2",
  "mat3",
  "mat4",
  "vec2",
  "vec3",
  "vec4",
  "ivec2",
  "ivec3",
  "ivec4",
  "bvec2",
  "bvec3",
  "bvec4",
  "sampler1D",
  "sampler2D",
  "sampler3D",
  "samplerCube",
  "sampler1DShadow",
  "sampler2DShadow",
  "struct",
  "asm",
  "class",
  "union",
  "enum",
  "typedef",
  "template",
  "this",
  "packed",
  "goto",
  "switch",
  "default",
  "inline",
  "noinline",
  "volatile",
  "public",
  "static",
  "extern",
  "external",
  "interface",
  "long",
  "short",
  "double",
  "half",
  "fixed",
  "unsigned",
  "input",
  "output",
  "hvec2",
  "hvec3",
  "hvec4",
  "dvec2",
  "dvec3",
  "dvec4",
  "fvec2",
  "fvec3",
  "fvec4",
  "sampler2DRect",
  "sampler3DRect",
  "sampler2DRectShadow",
  "sizeof",
  "cast",
  "namespace",
  "using"
], md = [
  "<<=",
  ">>=",
  "++",
  "--",
  "<<",
  ">>",
  "<=",
  ">=",
  "==",
  "!=",
  "&&",
  "||",
  "+=",
  "-=",
  "*=",
  "/=",
  "%=",
  "&=",
  "^^",
  "^=",
  "|=",
  "(",
  ")",
  "[",
  "]",
  ".",
  "!",
  "~",
  "*",
  "/",
  "%",
  "+",
  "-",
  "<",
  ">",
  "&",
  "^",
  "|",
  "?",
  ":",
  "=",
  ",",
  ";",
  "{",
  "}"
], hl = [
  // Keep this list sorted
  "abs",
  "acos",
  "all",
  "any",
  "asin",
  "atan",
  "ceil",
  "clamp",
  "cos",
  "cross",
  "dFdx",
  "dFdy",
  "degrees",
  "distance",
  "dot",
  "equal",
  "exp",
  "exp2",
  "faceforward",
  "floor",
  "fract",
  "gl_BackColor",
  "gl_BackLightModelProduct",
  "gl_BackLightProduct",
  "gl_BackMaterial",
  "gl_BackSecondaryColor",
  "gl_ClipPlane",
  "gl_ClipVertex",
  "gl_Color",
  "gl_DepthRange",
  "gl_DepthRangeParameters",
  "gl_EyePlaneQ",
  "gl_EyePlaneR",
  "gl_EyePlaneS",
  "gl_EyePlaneT",
  "gl_Fog",
  "gl_FogCoord",
  "gl_FogFragCoord",
  "gl_FogParameters",
  "gl_FragColor",
  "gl_FragCoord",
  "gl_FragData",
  "gl_FragDepth",
  "gl_FragDepthEXT",
  "gl_FrontColor",
  "gl_FrontFacing",
  "gl_FrontLightModelProduct",
  "gl_FrontLightProduct",
  "gl_FrontMaterial",
  "gl_FrontSecondaryColor",
  "gl_LightModel",
  "gl_LightModelParameters",
  "gl_LightModelProducts",
  "gl_LightProducts",
  "gl_LightSource",
  "gl_LightSourceParameters",
  "gl_MaterialParameters",
  "gl_MaxClipPlanes",
  "gl_MaxCombinedTextureImageUnits",
  "gl_MaxDrawBuffers",
  "gl_MaxFragmentUniformComponents",
  "gl_MaxLights",
  "gl_MaxTextureCoords",
  "gl_MaxTextureImageUnits",
  "gl_MaxTextureUnits",
  "gl_MaxVaryingFloats",
  "gl_MaxVertexAttribs",
  "gl_MaxVertexTextureImageUnits",
  "gl_MaxVertexUniformComponents",
  "gl_ModelViewMatrix",
  "gl_ModelViewMatrixInverse",
  "gl_ModelViewMatrixInverseTranspose",
  "gl_ModelViewMatrixTranspose",
  "gl_ModelViewProjectionMatrix",
  "gl_ModelViewProjectionMatrixInverse",
  "gl_ModelViewProjectionMatrixInverseTranspose",
  "gl_ModelViewProjectionMatrixTranspose",
  "gl_MultiTexCoord0",
  "gl_MultiTexCoord1",
  "gl_MultiTexCoord2",
  "gl_MultiTexCoord3",
  "gl_MultiTexCoord4",
  "gl_MultiTexCoord5",
  "gl_MultiTexCoord6",
  "gl_MultiTexCoord7",
  "gl_Normal",
  "gl_NormalMatrix",
  "gl_NormalScale",
  "gl_ObjectPlaneQ",
  "gl_ObjectPlaneR",
  "gl_ObjectPlaneS",
  "gl_ObjectPlaneT",
  "gl_Point",
  "gl_PointCoord",
  "gl_PointParameters",
  "gl_PointSize",
  "gl_Position",
  "gl_ProjectionMatrix",
  "gl_ProjectionMatrixInverse",
  "gl_ProjectionMatrixInverseTranspose",
  "gl_ProjectionMatrixTranspose",
  "gl_SecondaryColor",
  "gl_TexCoord",
  "gl_TextureEnvColor",
  "gl_TextureMatrix",
  "gl_TextureMatrixInverse",
  "gl_TextureMatrixInverseTranspose",
  "gl_TextureMatrixTranspose",
  "gl_Vertex",
  "greaterThan",
  "greaterThanEqual",
  "inversesqrt",
  "length",
  "lessThan",
  "lessThanEqual",
  "log",
  "log2",
  "matrixCompMult",
  "max",
  "min",
  "mix",
  "mod",
  "normalize",
  "not",
  "notEqual",
  "pow",
  "radians",
  "reflect",
  "refract",
  "sign",
  "sin",
  "smoothstep",
  "sqrt",
  "step",
  "tan",
  "texture2D",
  "texture2DLod",
  "texture2DProj",
  "texture2DProjLod",
  "textureCube",
  "textureCubeLod",
  "texture2DLodEXT",
  "texture2DProjLodEXT",
  "textureCubeLodEXT",
  "texture2DGradEXT",
  "texture2DProjGradEXT",
  "textureCubeGradEXT"
], gd = ul, yd = gd.slice().concat([
  "layout",
  "centroid",
  "smooth",
  "case",
  "mat2x2",
  "mat2x3",
  "mat2x4",
  "mat3x2",
  "mat3x3",
  "mat3x4",
  "mat4x2",
  "mat4x3",
  "mat4x4",
  "uvec2",
  "uvec3",
  "uvec4",
  "samplerCubeShadow",
  "sampler2DArray",
  "sampler2DArrayShadow",
  "isampler2D",
  "isampler3D",
  "isamplerCube",
  "isampler2DArray",
  "usampler2D",
  "usampler3D",
  "usamplerCube",
  "usampler2DArray",
  "coherent",
  "restrict",
  "readonly",
  "writeonly",
  "resource",
  "atomic_uint",
  "noperspective",
  "patch",
  "sample",
  "subroutine",
  "common",
  "partition",
  "active",
  "filter",
  "image1D",
  "image2D",
  "image3D",
  "imageCube",
  "iimage1D",
  "iimage2D",
  "iimage3D",
  "iimageCube",
  "uimage1D",
  "uimage2D",
  "uimage3D",
  "uimageCube",
  "image1DArray",
  "image2DArray",
  "iimage1DArray",
  "iimage2DArray",
  "uimage1DArray",
  "uimage2DArray",
  "image1DShadow",
  "image2DShadow",
  "image1DArrayShadow",
  "image2DArrayShadow",
  "imageBuffer",
  "iimageBuffer",
  "uimageBuffer",
  "sampler1DArray",
  "sampler1DArrayShadow",
  "isampler1D",
  "isampler1DArray",
  "usampler1D",
  "usampler1DArray",
  "isampler2DRect",
  "usampler2DRect",
  "samplerBuffer",
  "isamplerBuffer",
  "usamplerBuffer",
  "sampler2DMS",
  "isampler2DMS",
  "usampler2DMS",
  "sampler2DMSArray",
  "isampler2DMSArray",
  "usampler2DMSArray"
]), yr = hl;
yr = yr.slice().filter(function(o) {
  return !/^(gl\_|texture)/.test(o);
});
var vd = yr.concat([
  // the updated gl_ constants
  "gl_VertexID",
  "gl_InstanceID",
  "gl_Position",
  "gl_PointSize",
  "gl_FragCoord",
  "gl_FrontFacing",
  "gl_FragDepth",
  "gl_PointCoord",
  "gl_MaxVertexAttribs",
  "gl_MaxVertexUniformVectors",
  "gl_MaxVertexOutputVectors",
  "gl_MaxFragmentInputVectors",
  "gl_MaxVertexTextureImageUnits",
  "gl_MaxCombinedTextureImageUnits",
  "gl_MaxTextureImageUnits",
  "gl_MaxFragmentUniformVectors",
  "gl_MaxDrawBuffers",
  "gl_MinProgramTexelOffset",
  "gl_MaxProgramTexelOffset",
  "gl_DepthRangeParameters",
  "gl_DepthRange",
  "trunc",
  "round",
  "roundEven",
  "isnan",
  "isinf",
  "floatBitsToInt",
  "floatBitsToUint",
  "intBitsToFloat",
  "uintBitsToFloat",
  "packSnorm2x16",
  "unpackSnorm2x16",
  "packUnorm2x16",
  "unpackUnorm2x16",
  "packHalf2x16",
  "unpackHalf2x16",
  "outerProduct",
  "transpose",
  "determinant",
  "inverse",
  "texture",
  "textureSize",
  "textureProj",
  "textureLod",
  "textureOffset",
  "texelFetch",
  "texelFetchOffset",
  "textureProjOffset",
  "textureLodOffset",
  "textureProjLod",
  "textureProjLodOffset",
  "textureGrad",
  "textureGradOffset",
  "textureProjGrad",
  "textureProjGradOffset"
]), _d = Cd, xd = ul, Lo = md, wd = hl, Td = yd, bd = vd, It = 999, Fo = 9999, Vi = 0, Yi = 1, ko = 2, Bo = 3, No = 4, ps = 5, Ed = 6, Md = 7, Sd = 8, Uo = 9, Ad = 10, zo = 11, Pd = [
  "block-comment",
  "line-comment",
  "preprocessor",
  "operator",
  "integer",
  "float",
  "ident",
  "builtin",
  "keyword",
  "whitespace",
  "eof",
  "integer"
];
function Cd(o) {
  var e = 0, t = 0, n = It, s, i, r = [], a = [], l = 1, c = 0, h = 0, u = !1, p = !1, f = "", g;
  o = o || {};
  var m = wd, y = xd;
  o.version === "300 es" && (m = bd, y = Td);
  for (var d = {}, w = {}, e = 0; e < m.length; e++)
    d[m[e]] = !0;
  for (var e = 0; e < y.length; e++)
    w[y[e]] = !0;
  return function(Q) {
    return a = [], Q !== null ? E(Q) : P();
  };
  function v(Q) {
    Q.length && a.push({
      type: Pd[n],
      data: Q,
      position: h,
      line: l,
      column: c
    });
  }
  function E(Q) {
    e = 0, Q.toString && (Q = Q.toString()), f += Q.replace(/\r\n/g, `
`), g = f.length;
    for (var Z; s = f[e], e < g; ) {
      switch (Z = e, n) {
        case Vi:
          e = _();
          break;
        case Yi:
          e = M();
          break;
        case ko:
          e = x();
          break;
        case Bo:
          e = C();
          break;
        case No:
          e = N();
          break;
        case zo:
          e = B();
          break;
        case ps:
          e = j();
          break;
        case Fo:
          e = V();
          break;
        case Uo:
          e = b();
          break;
        case It:
          e = T();
          break;
      }
      if (Z !== e)
        switch (f[Z]) {
          case `
`:
            c = 0, ++l;
            break;
          default:
            ++c;
            break;
        }
    }
    return t += e, f = f.slice(e), a;
  }
  function P(Q) {
    return r.length && v(r.join("")), n = Ad, v("(eof)"), a;
  }
  function T() {
    return r = r.length ? [] : r, i === "/" && s === "*" ? (h = t + e - 1, n = Vi, i = s, e + 1) : i === "/" && s === "/" ? (h = t + e - 1, n = Yi, i = s, e + 1) : s === "#" ? (n = ko, h = t + e, e) : /\s/.test(s) ? (n = Uo, h = t + e, e) : (u = /\d/.test(s), p = /[^\w_]/.test(s), h = t + e, n = u ? No : p ? Bo : Fo, e);
  }
  function b() {
    return /[^\s]/g.test(s) ? (v(r.join("")), n = It, e) : (r.push(s), i = s, e + 1);
  }
  function x() {
    return (s === "\r" || s === `
`) && i !== "\\" ? (v(r.join("")), n = It, e) : (r.push(s), i = s, e + 1);
  }
  function M() {
    return x();
  }
  function _() {
    return s === "/" && i === "*" ? (r.push(s), v(r.join("")), n = It, e + 1) : (r.push(s), i = s, e + 1);
  }
  function C() {
    if (i === "." && /\d/.test(s))
      return n = ps, e;
    if (i === "/" && s === "*")
      return n = Vi, e;
    if (i === "/" && s === "/")
      return n = Yi, e;
    if (s === "." && r.length) {
      for (; R(r); ) ;
      return n = ps, e;
    }
    if (s === ";" || s === ")" || s === "(") {
      if (r.length) for (; R(r); ) ;
      return v(s), n = It, e + 1;
    }
    var Q = r.length === 2 && s !== "=";
    if (/[\w_\d\s]/.test(s) || Q) {
      for (; R(r); ) ;
      return n = It, e;
    }
    return r.push(s), i = s, e + 1;
  }
  function R(Q) {
    var Z = 0, ne, te;
    do {
      if (ne = Lo.indexOf(Q.slice(0, Q.length + Z).join("")), te = Lo[ne], ne === -1) {
        if (Z-- + Q.length > 0) continue;
        te = Q.slice(0, 1).join("");
      }
      return v(te), h += te.length, r = r.slice(te.length), r.length;
    } while (!0);
  }
  function B() {
    return /[^a-fA-F0-9]/.test(s) ? (v(r.join("")), n = It, e) : (r.push(s), i = s, e + 1);
  }
  function N() {
    return s === "." || /[eE]/.test(s) ? (r.push(s), n = ps, i = s, e + 1) : s === "x" && r.length === 1 && r[0] === "0" ? (n = zo, r.push(s), i = s, e + 1) : /[^\d]/.test(s) ? (v(r.join("")), n = It, e) : (r.push(s), i = s, e + 1);
  }
  function j() {
    return s === "f" && (r.push(s), i = s, e += 1), /[eE]/.test(s) || (s === "-" || s === "+") && /[eE]/.test(i) ? (r.push(s), i = s, e + 1) : /[^\d]/.test(s) ? (v(r.join("")), n = It, e) : (r.push(s), i = s, e + 1);
  }
  function V() {
    if (/[^\d\w_]/.test(s)) {
      var Q = r.join("");
      return w[Q] ? n = Sd : d[Q] ? n = Md : n = Ed, v(r.join("")), n = It, e;
    }
    return r.push(s), i = s, e + 1;
  }
}
var Rd = _d, Id = Od;
function Od(o, e) {
  var t = Rd(e), n = [];
  return n = n.concat(t(o)), n = n.concat(t(null)), n;
}
const Dd = /* @__PURE__ */ Rs(Id);
var Ld = Fd;
function Fd(o) {
  for (var e = [], t = 0; t < o.length; t++)
    o[t].type !== "eof" && e.push(o[t].data);
  return e.join("");
}
const Ho = /* @__PURE__ */ Rs(Ld);
var kd = Bd;
function Bd(o) {
  var e = null, t = null, n = 0, s = 0, i = 0, r = 0, a = 0, l = [], c, h, u;
  for (c = 0, h; c < o.length; c++)
    if (u = o[c], u.data === "{") {
      if (n && n++ || (h = f(c, pn(")"), pn()), h < 0) || (r = h, h = f(h, pn("("), pn(")")), h < 0) || (a = h, h = f(h, ms), h < 0) || o[h].type !== "ident" || (t = o[h].data, h = f(h, ms), h < 0)) continue;
      n = 1, s = c, e = o[h].data, i = h;
      var p = f(h, ms);
      switch (o[p] && o[p].data) {
        case "lowp":
        case "highp":
        case "mediump":
          i = p;
      }
    } else if (n && u.data === "}") {
      if (--n) continue;
      l.push({
        name: t,
        type: e,
        body: [s + 1, c],
        args: [a, r + 1],
        outer: [i, c + 1]
      });
    }
  for (c = 0; c < o.length; c++)
    if (u = o[c], u.data === ";") {
      if (h = f(c, pn(")"), pn()), h < 0 || (r = h, h = f(h, pn("("), pn(")")), h < 0) || (a = h, h = f(h, ms), h < 0) || o[h].type !== "ident" || (t = o[h].data, h = f(h, ms), h < 0) || o[h].type === "operator" || o[h].data === "return") continue;
      e = o[h].data, l.push({
        name: t,
        type: e,
        body: !1,
        args: [a, r + 1],
        outer: [h, c + 1]
      });
    }
  return l.sort(function(g, m) {
    return g.outer[0] - m.outer[0];
  });
  function f(g, m, y) {
    for (var d = g - 1; d >= 0; d--) {
      if (m(o[d])) return d;
      if (y && y(o[d])) return -1;
    }
    return -1;
  }
}
function pn(o) {
  return function(e) {
    return e.type === "operator" && (!o || e.data === o);
  };
}
function ms(o) {
  return o.type !== "whitespace";
}
const Nd = /* @__PURE__ */ Rs(kd);
function Ud(o, e) {
  if (typeof o != "object" || o === null) return o;
  var t = o[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(o, e || "default");
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(o);
}
function fl(o) {
  var e = Ud(o, "string");
  return typeof e == "symbol" ? e : String(e);
}
function Ue(o, e, t) {
  return e = fl(e), e in o ? Object.defineProperty(o, e, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : o[e] = t, o;
}
function Go(o, e) {
  var t = Object.keys(o);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(o);
    e && (n = n.filter(function(s) {
      return Object.getOwnPropertyDescriptor(o, s).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function $n(o) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Go(Object(t), !0).forEach(function(n) {
      Ue(o, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(o, Object.getOwnPropertyDescriptors(t)) : Go(Object(t)).forEach(function(n) {
      Object.defineProperty(o, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return o;
}
function zd(o, e) {
  if (o == null) return {};
  var t = {}, n = Object.keys(o), s, i;
  for (i = 0; i < n.length; i++)
    s = n[i], !(e.indexOf(s) >= 0) && (t[s] = o[s]);
  return t;
}
function Hd(o, e) {
  if (o == null) return {};
  var t = zd(o, e), n, s;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(o);
    for (s = 0; s < i.length; s++)
      n = i[s], !(e.indexOf(n) >= 0) && Object.prototype.propertyIsEnumerable.call(o, n) && (t[n] = o[n]);
  }
  return t;
}
function Gd(o, e) {
  if (!(o instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function jd(o, e) {
  for (var t = 0; t < e.length; t++) {
    var n = e[t];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(o, fl(n.key), n);
  }
}
function Vd(o, e, t) {
  return e && jd(o.prototype, e), Object.defineProperty(o, "prototype", {
    writable: !1
  }), o;
}
function dl(o) {
  if (o === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return o;
}
function vr(o, e) {
  return vr = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, s) {
    return n.__proto__ = s, n;
  }, vr(o, e);
}
function Yd(o, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function");
  o.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: o,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(o, "prototype", {
    writable: !1
  }), e && vr(o, e);
}
function ui(o) {
  return ui = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, ui(o);
}
function Xd() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
  if (typeof Proxy == "function") return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function Wd(o, e) {
  if (e && (typeof e == "object" || typeof e == "function"))
    return e;
  if (e !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return dl(o);
}
function $d(o) {
  var e = Xd();
  return function() {
    var n = ui(o), s;
    if (e) {
      var i = ui(this).constructor;
      s = Reflect.construct(n, arguments, i);
    } else
      s = n.apply(this, arguments);
    return Wd(this, s);
  };
}
var Ee = {
  position: "csm_Position",
  positionRaw: "csm_PositionRaw",
  pointSize: "csm_PointSize",
  fragColor: "csm_FragColor",
  // PBR
  diffuseColor: "csm_DiffuseColor",
  // Color + alpha
  normal: "csm_Normal",
  // Normal
  roughness: "csm_Roughness",
  // Roughness
  metalness: "csm_Metalness",
  // Metalness
  emissive: "csm_Emissive",
  // Emissive
  ao: "csm_AO",
  // AO
  bump: "csm_Bump",
  // Bump
  depthAlpha: "csm_DepthAlpha"
  // Depth
}, ut, Zn, Zd = (ut = {}, Ue(ut, "".concat(Ee.normal), {
  "#include <beginnormal_vertex>": `
    vec3 objectNormal = `.concat(Ee.normal, `;
    #ifdef USE_TANGENT
	    vec3 objectTangent = vec3( tangent.xyz );
    #endif
    `)
}), Ue(ut, "".concat(Ee.position), {
  "#include <begin_vertex>": `
    vec3 transformed = `.concat(Ee.position, `;
  `)
}), Ue(ut, "".concat(Ee.positionRaw), {
  "#include <begin_vertex>": `
    vec4 csm_internal_positionUnprojected = `.concat(Ee.positionRaw, `;
    mat4x4 csm_internal_unprojectMatrix = projectionMatrix * modelViewMatrix;
    #ifdef USE_INSTANCING
      csm_internal_unprojectMatrix = csm_internal_unprojectMatrix * instanceMatrix;
    #endif
    csm_internal_positionUnprojected = inverse(csm_internal_unprojectMatrix) * csm_internal_positionUnprojected;
    vec3 transformed = csm_internal_positionUnprojected.xyz;
  `)
}), Ue(ut, "".concat(Ee.pointSize), {
  "gl_PointSize = size;": `
    gl_PointSize = `.concat(Ee.pointSize, `;
    `)
}), Ue(ut, "".concat(Ee.diffuseColor), {
  "#include <color_fragment>": `
    #include <color_fragment>
    diffuseColor = `.concat(Ee.diffuseColor, `;
  `)
}), Ue(ut, "".concat(Ee.fragColor), {
  "#include <dithering_fragment>": `
    #include <dithering_fragment>
    gl_FragColor  = `.concat(Ee.fragColor, `;
  `)
}), Ue(ut, "".concat(Ee.emissive), {
  "vec3 totalEmissiveRadiance = emissive;": `
    vec3 totalEmissiveRadiance = `.concat(Ee.emissive, `;
    `)
}), Ue(ut, "".concat(Ee.roughness), {
  "#include <roughnessmap_fragment>": `
    #include <roughnessmap_fragment>
    roughnessFactor = `.concat(Ee.roughness, `;
    `)
}), Ue(ut, "".concat(Ee.metalness), {
  "#include <metalnessmap_fragment>": `
    #include <metalnessmap_fragment>
    metalnessFactor = `.concat(Ee.metalness, `;
    `)
}), Ue(ut, "".concat(Ee.ao), {
  "#include <aomap_fragment>": `
    #include <aomap_fragment>
    reflectedLight.indirectDiffuse *= 1. - `.concat(Ee.ao, `;
    `)
}), Ue(ut, "".concat(Ee.bump), {
  "#include <normal_fragment_maps>": `
    #include <normal_fragment_maps>

    vec3 csm_internal_orthogonal = `.concat(Ee.bump, " - (dot(").concat(Ee.bump, `, normal) * normal);
    vec3 csm_internal_projectedbump = mat3(csm_internal_vModelViewMatrix) * csm_internal_orthogonal;
    normal = normalize(normal - csm_internal_projectedbump);
    `)
}), Ue(ut, "".concat(Ee.depthAlpha), {
  "gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );": `
      gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity * `.concat(Ee.depthAlpha, ` );
    `),
  "gl_FragColor = packDepthToRGBA( fragCoordZ );": `
      gl_FragColor = packDepthToRGBA( fragCoordZ );
      gl_FragColor.a *= `.concat(Ee.depthAlpha, `;
    `)
}), ut), Kd = (Zn = {}, Ue(Zn, "".concat(Ee.position), {
  "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );": `
    gl_Position = projectionMatrix * modelViewMatrix * vec4( `.concat(Ee.position, `, 1.0 );
  `)
}), Ue(Zn, "".concat(Ee.positionRaw), {
  "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );": `
    gl_Position = `.concat(Ee.position, `;
  `)
}), Ue(Zn, "".concat(Ee.diffuseColor), {
  "gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );": `
    gl_FragColor = `.concat(Ee.diffuseColor, `;
  `)
}), Ue(Zn, "".concat(Ee.fragColor), {
  "gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );": `
    gl_FragColor = `.concat(Ee.fragColor, `;
  `)
}), Zn), qd = (
  /* glsl */
  `

#ifdef IS_VERTEX
    // csm_Position & csm_PositionRaw
    #ifdef IS_UNKNOWN
        vec3 csm_Position = vec3(0.0);
        vec4 csm_PositionRaw = vec4(0.0);
        vec3 csm_Normal = vec3(0.0);
    #else
        vec3 csm_Position = position;
        vec4 csm_PositionRaw = projectionMatrix * modelViewMatrix * vec4(position, 1.);
        vec3 csm_Normal = normal;
    #endif

    // csm_PointSize
    #ifdef IS_POINTSMATERIAL
        float csm_PointSize = size;
    #endif
#else
    // csm_DiffuseColor & csm_FragColor
    #if defined IS_UNKNOWN || defined IS_SHADERMATERIAL || defined IS_MESHDEPTHMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_SHADOWMATERIAL
        vec4 csm_DiffuseColor = vec4(1.0, 0.0, 1.0, 1.0);
        vec4 csm_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
    #else
        #ifdef USE_MAP
            vec4 _csm_sampledDiffuseColor = texture2D(map, vMapUv);

            #ifdef DECODE_VIDEO_TEXTURE
            // inline sRGB decode (TODO: Remove this code when https://crbug.com/1256340 is solved)
            _csm_sampledDiffuseColor = vec4(mix(pow(_csm_sampledDiffuseColor.rgb * 0.9478672986 + vec3(0.0521327014), vec3(2.4)), _csm_sampledDiffuseColor.rgb * 0.0773993808, vec3(lessThanEqual(_csm_sampledDiffuseColor.rgb, vec3(0.04045)))), _csm_sampledDiffuseColor.w);
            #endif

            vec4 csm_DiffuseColor = vec4(diffuse, opacity) * _csm_sampledDiffuseColor;
            vec4 csm_FragColor = vec4(diffuse, opacity) * _csm_sampledDiffuseColor;
        #else
            vec4 csm_DiffuseColor = vec4(diffuse, opacity);
            vec4 csm_FragColor = vec4(diffuse, opacity);
        #endif
    #endif

    // csm_Emissive, csm_Roughness, csm_Metalness
    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL
        vec3 csm_Emissive = emissive;
        float csm_Roughness = roughness;
        float csm_Metalness = metalness;
    #endif

    // csm_AO
    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHBASICMATERIAL || defined IS_MESHLAMBERTMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHTOONMATERIAL
        float csm_AO = 0.0;
    #endif

    // csm_Bump
    #if defined IS_MESHLAMBERTMATERIAL || defined IS_MESHMATCAPMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHSTANDARDMATERIAL || defined IS_MESHTOONMATERIAL || defined IS_SHADOWMATERIAL 
        vec3 csm_Bump = vec3(0.0);
    #endif

    float csm_DepthAlpha = 1.0;
#endif
`
), Qd = (
  /* glsl */
  `
    varying mat4 csm_internal_vModelViewMatrix;
`
), Jd = (
  /* glsl */
  `
    csm_internal_vModelViewMatrix = modelViewMatrix;
`
), ep = (
  /* glsl */
  `
    varying mat4 csm_internal_vModelViewMatrix;
`
), tp = (
  /* glsl */
  `
    
`
), ht, np = (ht = {}, Ue(ht, "".concat(Ee.position), "*"), Ue(ht, "".concat(Ee.positionRaw), "*"), Ue(ht, "".concat(Ee.normal), "*"), Ue(ht, "".concat(Ee.pointSize), ["PointsMaterial"]), Ue(ht, "".concat(Ee.diffuseColor), "*"), Ue(ht, "".concat(Ee.fragColor), "*"), Ue(ht, "".concat(Ee.emissive), ["MeshStandardMaterial", "MeshPhysicalMaterial"]), Ue(ht, "".concat(Ee.roughness), ["MeshStandardMaterial", "MeshPhysicalMaterial"]), Ue(ht, "".concat(Ee.metalness), ["MeshStandardMaterial", "MeshPhysicalMaterial"]), Ue(ht, "".concat(Ee.ao), ["MeshStandardMaterial", "MeshPhysicalMaterial", "MeshBasicMaterial", "MeshLambertMaterial", "MeshPhongMaterial", "MeshToonMaterial"]), Ue(ht, "".concat(Ee.bump), ["MeshLambertMaterial", "MeshMatcapMaterial", "MeshNormalMaterial", "MeshPhongMaterial", "MeshPhysicalMaterial", "MeshStandardMaterial", "MeshToonMaterial", "ShadowMaterial"]), Ue(ht, "".concat(Ee.depthAlpha), "*"), ht), sp = ["baseMaterial", "fragmentShader", "vertexShader", "uniforms", "patchMap", "cacheKey", "silent"], ip = function(e, t, n) {
  return e.split(t).join(n);
}, rp = function(e) {
  return e.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
}, op = function(e, t) {
  return new RegExp("\\b".concat(rp(t), "\\b")).test(e);
};
function ap(o) {
  try {
    new o();
  } catch (e) {
    if (e.message.indexOf("is not a constructor") >= 0)
      return !1;
  }
  return !0;
}
function lp(o, e) {
  var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  Object.assign(o, e);
  var n = Object.getPrototypeOf(e);
  Object.entries(Object.getOwnPropertyDescriptors(n)).filter(function(s) {
    var i = typeof s[1].get == "function", r = typeof s[1].set == "function", a = typeof s[1].value == "function", l = s[0] === "constructor";
    return (i || r || a) && !l;
  }).forEach(function(s) {
    if (typeof o[s[0]] == "function") {
      t || console.warn("Function ".concat(s[0], " already exists on CSM, renaming to base_").concat(s[0]));
      var i = "base_".concat(s[0]);
      o[i] = s[1].value.bind(o);
      return;
    }
    Object.defineProperty(o, s[0], s[1]);
  });
}
function cp(o) {
  var e = o.toString().trim(), t = e.substring(e.indexOf("{") + 1, e.lastIndexOf("}"));
  return t.trim().length === 0;
}
function jo(o) {
  return o.replace(/\s/g, "");
}
function up(o, e, t) {
  var n = o.lastIndexOf(e);
  return n === -1 ? o : o.substring(0, n) + t + o.substring(n + e.length);
}
var hp = /* @__PURE__ */ function(o) {
  Yd(t, o);
  var e = $d(t);
  function t(n) {
    var s, i = n.baseMaterial, r = n.fragmentShader, a = n.vertexShader, l = n.uniforms, c = n.patchMap, h = n.cacheKey, u = n.silent, p = Hd(n, sp);
    Gd(this, t);
    var f;
    if (ap(i) ? f = new i(p) : (f = i, Object.assign(f, p)), f.type === "RawShaderMaterial")
      throw new Error("CustomShaderMaterial does not support RawShaderMaterial");
    s = e.call(this), lp(dl(s), f, u), s.__csm = {
      patchMap: c || {},
      fragmentShader: r || "",
      vertexShader: a || "",
      cacheKey: h,
      baseMaterial: i,
      instanceID: Yr.MathUtils.generateUUID(),
      type: f.type,
      isAlreadyExtended: !cp(f.onBeforeCompile),
      cacheHash: "",
      silent: u
    }, s.uniforms = $n($n({}, s.uniforms || {}), l || {});
    {
      var g = s.__csm, m = g.fragmentShader, y = g.vertexShader, d = s.uniforms;
      s.__csm.cacheHash = s.getCacheHash(), s.generateMaterial(m, y, d);
    }
    return s;
  }
  return Vd(t, [{
    key: "update",
    value: function() {
      var s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.uniforms = s.uniforms || this.uniforms, Object.assign(this.__csm, s);
      var i = this.__csm, r = i.fragmentShader, a = i.vertexShader, l = this.uniforms, c = this.getCacheHash();
      this.__csm.cacheHash = c, this.generateMaterial(r, a, l);
    }
    /**
     * Returns a new instance of this material with the same options.
     *
     * @returns A clone of this material.
     */
  }, {
    key: "clone",
    value: function() {
      var s = {
        baseMaterial: this.__csm.baseMaterial,
        fragmentShader: this.__csm.fragmentShader,
        vertexShader: this.__csm.vertexShader,
        uniforms: this.uniforms,
        silent: this.__csm.silent,
        patchMap: this.__csm.patchMap,
        cacheKey: this.__csm.cacheKey
      }, i = new this.constructor(s);
      return Object.assign(this, i), i;
    }
    /**
     * Internally calculates the cache key for this instance of CSM.
     * If no specific CSM inputs are provided, the cache key is the same as the default
     * cache key, i.e. `baseMaterial.onBeforeCompile.toString()`. Not meant to be called directly.
     *
     * This method is quite expensive owing to the hashing function and string manip.
     *
     * TODO:
     * - Optimize string manip.
     * - Find faster hash function
     *
     * @returns {string} A cache key for this instance of CSM.
     */
  }, {
    key: "getCacheHash",
    value: function() {
      var s = this.__csm, i = s.fragmentShader, r = s.vertexShader, a = this.uniforms, l = Object.values(a).reduce(function(h, u) {
        var p = u.value;
        return h + JSON.stringify(p);
      }, ""), c = jo(i) + jo(r) + l;
      return c.trim().length > 0 ? pd(c) : this.customProgramCacheKey();
    }
    /**
     * Does the internal shader generation. Not meant to be called directly.
     *
     * @param fragmentShader
     * @param vertexShader
     * @param uniforms
     */
  }, {
    key: "generateMaterial",
    value: function(s, i, r) {
      var a = this, l = this.parseShader(s), c = this.parseShader(i);
      this.uniforms = r || {}, this.customProgramCacheKey = function() {
        return a.__csm.cacheHash;
      };
      var h = function(f) {
        try {
          if (l) {
            var g = a.patchShader(l, f.fragmentShader, !0);
            f.fragmentShader = a.getMaterialDefine() + g;
          }
          if (c) {
            var m = a.patchShader(c, f.vertexShader);
            f.vertexShader = `#define IS_VERTEX;
` + m, f.vertexShader = a.getMaterialDefine() + f.vertexShader;
          }
          f.uniforms = $n($n({}, f.uniforms), a.uniforms), a.uniforms = f.uniforms;
        } catch (y) {
          console.error(y);
        }
      };
      if (this.__csm.isAlreadyExtended) {
        var u = this.onBeforeCompile;
        this.onBeforeCompile = function(p, f) {
          u(p, f), h(p);
        };
      } else
        this.onBeforeCompile = h;
      this.needsUpdate = !0;
    }
    /**
     * Patches input shader with custom shader. Not meant to be called directly.
     * @param customShader
     * @param shader
     * @param isFrag
     * @returns
     */
  }, {
    key: "patchShader",
    value: function(s, i, r) {
      var a = this, l = i, c = $n($n({}, this.getPatchMapForMaterial()), this.__csm.patchMap);
      Object.keys(c).forEach(function(p) {
        Object.keys(c[p]).forEach(function(f) {
          var g = np[p], m = a.__csm.type;
          if (p === "*" || op(s.main, p))
            if (!g || Array.isArray(g) && g.includes(m) || g === "*")
              l = ip(l, f, c[p][f]);
            else
              throw new Error("CSM: ".concat(p, " is not available in ").concat(m, ". Shader cannot compile."));
        });
      }), l = l.replace("void main() {", `
        #ifndef CSM_IS_HEAD_DEFAULTS_DEFINED
          `.concat(r ? ep : Qd, `
          #define CSM_IS_HEAD_DEFAULTS_DEFINED 1
        #endif

        `).concat(s.header, `
        
        void main() {
          #ifndef CSM_IS_DEFAULTS_DEFINED
            `).concat(qd, `
            #define CSM_IS_DEFAULTS_DEFINED 1
          #endif
          
          #ifndef CSM_IS_MAIN_DEFAULTS_DEFINED
            `).concat(r ? tp : Jd, `
            #define CSM_IS_MAIN_DEFAULTS_DEFINED 1
          #endif

          // CSM_START
      `));
      var h = this.__csm.isAlreadyExtended, u = l.includes("// CSM_END");
      return h && u ? l = up(l, "// CSM_END", `
          // CSM_END
          `.concat(s.main, `
          // CSM_END
        `)) : l = l.replace("// CSM_START", `
        // CSM_START
        `.concat(s.main, `
        // CSM_END
          `)), l = s.defines + l, l;
    }
    /**
     * This method is expensive owing to the tokenization and parsing of the shader.
     *
     * TODO:
     * - Replace tokenization with regex
     *
     * @param shader
     * @returns
     */
  }, {
    key: "parseShader",
    value: function(s) {
      if (s) {
        var i = s.replace(/\/\*\*(.*?)\*\/|\/\/(.*?)\n/gm, ""), r = Dd(i), a = Nd(r), l = a.map(function(u) {
          return u.name;
        }).indexOf("main"), c = Ho(r.slice(0, l >= 0 ? a[l].outer[0] : void 0)), h = l >= 0 ? this.getShaderFromIndex(r, a[l].body) : "";
        return {
          defines: "",
          header: c,
          main: h
        };
      }
    }
    /**
     * Gets the material type as a string. Not meant to be called directly.
     * @returns
     */
  }, {
    key: "getMaterialDefine",
    value: function() {
      var s = this.__csm.type;
      return s ? "#define IS_".concat(s.toUpperCase(), `;
`) : `#define IS_UNKNOWN;
`;
    }
    /**
     * Gets the right patch map for the material. Not meant to be called directly.
     * @returns
     */
  }, {
    key: "getPatchMapForMaterial",
    value: function() {
      switch (this.__csm.type) {
        case "ShaderMaterial":
          return Kd;
        default:
          return Zd;
      }
    }
    /**
     * Gets the shader from the tokens. Not meant to be called directly.
     * @param tokens
     * @param index
     * @returns
     */
  }, {
    key: "getShaderFromIndex",
    value: function(s, i) {
      return Ho(s.slice(i[0], i[1]));
    }
  }]), t;
}(Yr.Material);
const fp = ["args"], Wg = /* @__PURE__ */ me({
  __name: "index",
  props: {
    baseMaterial: {},
    vertexShader: {},
    fragmentShader: {},
    silent: { type: Boolean },
    uniforms: {}
  },
  setup(o, { expose: e }) {
    const t = o, n = ye(null), { extend: s, invalidate: i } = ve();
    return s({ CustomShaderMaterial: hp }), ee(t, () => i()), e({ instance: n }), (r, a) => (ue(), de("TresCustomShaderMaterial", {
      ref_key: "customShaderMaterialClass",
      ref: n,
      args: [t]
    }, null, 8, fp));
  }
});
class Vo extends Lt {
  /**
   * Create a HolographicMaterial.
   *
   * @param {object} parameters - The parameters to configure the material.
   * @param {number} [parameters.time] - The time uniform representing animation time.
   * @param {number} [parameters.fresnelOpacity] - The opacity for the fresnel effect.
   * @param {number} [parameters.fresnelAmount] - The strength of the fresnel effect.
   * @param {number} [parameters.scanlineSize] - The size of the scanline effect.
   * @param {number} [parameters.hologramBrightness] - The brightness of the hologram.
   * @param {number} [parameters.signalSpeed] - The speed of the signal effect.
   * @param {Color} [parameters.hologramColor] - The color of the hologram.
   * @param {boolean} [parameters.enableBlinking] - Enable/disable blinking effect.
   * @param {boolean} [parameters.blinkFresnelOnly] - Enable blinking only on the fresnel effect.
   * @param {number} [parameters.hologramOpacity] - The opacity of the hologram.
   * @param {number} [parameters.blendMode] - The blending mode. Use `THREE.NormalBlending` or `THREE.AdditiveBlending`.
   * @param {number} [parameters.side] - The rendering side. Use `THREE.FrontSide`,
   *  `THREE.BackSide`, or `THREE.DoubleSide`.
   * @param {boolean} [parameters.depthTest] - Enable or disable depthTest.
   */
  constructor(t = {}) {
    super();
    ce(this, "clock");
    this.vertexShader = `
      #define STANDARD
      varying vec3 vViewPosition;
      #ifdef USE_TRANSMISSION
      varying vec3 vWorldPosition;
      #endif
    
      varying vec2 vUv;
      varying vec4 vPos;
      varying vec3 vNormalW;
      varying vec3 vPositionW;

      #include <common>
      #include <uv_pars_vertex>
      #include <envmap_pars_vertex>
      #include <color_pars_vertex>
      #include <fog_pars_vertex>
      #include <morphtarget_pars_vertex>
      #include <skinning_pars_vertex>
      #include <logdepthbuf_pars_vertex>
      #include <clipping_planes_pars_vertex>

      void main() {
        
        #include <uv_vertex>
        #include <color_vertex>
        #include <morphcolor_vertex>
      
        #if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
      
          #include <beginnormal_vertex>
          #include <morphnormal_vertex>
          #include <skinbase_vertex>
          #include <skinnormal_vertex>
          #include <defaultnormal_vertex>
      
        #endif
      
        #include <begin_vertex>
        #include <morphtarget_vertex>
        #include <skinning_vertex>
        #include <project_vertex>
        #include <logdepthbuf_vertex>
        #include <clipping_planes_vertex>
      
        #include <worldpos_vertex>
        #include <envmap_vertex>
        #include <fog_vertex>

        mat4 modelViewProjectionMatrix = projectionMatrix * modelViewMatrix;

        vUv = uv;
        vPos = projectionMatrix * modelViewMatrix * vec4( transformed, 1.0 );
        vPositionW = vec3( vec4( transformed, 1.0 ) * modelMatrix);
        vNormalW = normalize( vec3( vec4( normal, 0.0 ) * modelMatrix ) );
        
        gl_Position = modelViewProjectionMatrix * vec4( transformed, 1.0 );

      }`, this.fragmentShader = ` 
      varying vec2 vUv;
      varying vec3 vPositionW;
      varying vec4 vPos;
      varying vec3 vNormalW;
      
      uniform float time;
      uniform float fresnelOpacity;
      uniform float scanlineSize;
      uniform float fresnelAmount;
      uniform float signalSpeed;
      uniform float hologramBrightness;
      uniform float hologramOpacity;
      uniform bool blinkFresnelOnly;
      uniform bool enableBlinking;
      uniform vec3 hologramColor;

      float flicker( float amt, float time ) {return clamp( fract( cos( time ) * 43758.5453123 ), amt, 1.0 );}
      float random(in float a, in float b) { return fract((cos(dot(vec2(a,b) ,vec2(12.9898,78.233))) * 43758.5453)); }

      void main() {
        vec2 vCoords = vPos.xy;
        vCoords /= vPos.w;
        vCoords = vCoords * 0.5 + 0.5;
        vec2 myUV = fract( vCoords );

        // Defines hologram main color
        vec4 hologramColor = vec4(hologramColor, mix(hologramBrightness, vUv.y, 0.5));

        // Add scanlines
        float scanlines = 10.;
        scanlines += 20. * sin(time *signalSpeed * 20.8 - myUV.y * 60. * scanlineSize);
        scanlines *= smoothstep(1.3 * cos(time *signalSpeed + myUV.y * scanlineSize), 0.78, 0.9);
        scanlines *= max(0.25, sin(time *signalSpeed) * 1.0);

        // Scanlines offsets
        float r = random(vUv.x, vUv.y);
        float g = random(vUv.y * 20.2, vUv.y * .2);
        float b = random(vUv.y * .9, vUv.y * .2);

        // Scanline composition
        hologramColor += vec4(r*scanlines, b*scanlines, r, 1.0) / 84.;
        vec4 scanlineMix = mix(vec4(0.0), hologramColor, hologramColor.a);

        // Calculates fresnel
        vec3 viewDirectionW = normalize(cameraPosition - vPositionW);
        float fresnelEffect = dot(viewDirectionW, vNormalW) * (1.6 - fresnelOpacity/2.);
        fresnelEffect = clamp(fresnelAmount - fresnelEffect, 0., fresnelOpacity);

        // Blinkin effect
        //Suggested by Octano - https://x.com/OtanoDesign?s=20
        float blinkValue = enableBlinking ? 0.6 - signalSpeed : 1.0;
        float blink = flicker(blinkValue, time * signalSpeed * .02);

        // Final shader composition
        vec3 finalColor;

        if(blinkFresnelOnly){
          finalColor = scanlineMix.rgb + fresnelEffect * blink;
        }else{
          finalColor = scanlineMix.rgb * blink + fresnelEffect;
        }

        gl_FragColor = vec4( finalColor, hologramOpacity);

      }`, this.uniforms = {
      /**
       * The time uniform representing animation time.
       * @type {Uniform<number>}
       * @default 0.0
       */
      time: new Me(0),
      /**
       * The opacity for the fresnel effect.
       * @type {Uniform<number>}
       * @default 1.0
       */
      fresnelOpacity: new Me(t.fresnelOpacity !== void 0 ? t.fresnelOpacity : 1),
      /**
       * The strength of the fresnel effect.
       * @type {Uniform<number>}
       * @default 1.0
       */
      fresnelAmount: new Me(t.fresnelAmount !== void 0 ? t.fresnelAmount : 0.45),
      /**
       * The size of the scanline effect.
       * @type {Uniform<number>}
       * @default 1.0
       */
      scanlineSize: new Me(t.scanlineSize !== void 0 ? t.scanlineSize : 8),
      /**
       * The brightness of the hologram.
       * @type {Uniform<number>}
       * @default 1.0
       */
      hologramBrightness: new Me(t.hologramBrightness !== void 0 ? t.hologramBrightness : 1),
      /**
       * The speed of the signal effect.
       * @type {Uniform<number>}
       * @default 1.0
       */
      signalSpeed: new Me(t.signalSpeed !== void 0 ? t.signalSpeed : 1),
      /**
       * The color of the hologram.
       * @type {Uniform<Color>}
       * @default new Color(0xFFFFFF)
       */
      hologramColor: new Me(t.hologramColor !== void 0 ? new Pe(t.hologramColor) : new Pe("#00d5ff")),
      /**
       * Enable/disable blinking effect.
       * @type {Uniform<boolean>}
       * @default true
       */
      enableBlinking: new Me(t.enableBlinking !== void 0 ? t.enableBlinking : !0),
      /**
       * Enable blinking only on the fresnel effect.
       * @type {Uniform<boolean>}
       * @default false
       */
      blinkFresnelOnly: new Me(t.blinkFresnelOnly !== void 0 ? t.blinkFresnelOnly : !0),
      /**
       * The opacity of the hologram.
       * @type {Uniform<number>}
       * @default 1.0
       */
      hologramOpacity: new Me(t.hologramOpacity !== void 0 ? t.hologramOpacity : 1)
    }, this.clock = new Jl(), this.setValues(t), this.depthTest = t.depthTest !== void 0 ? t.depthTest : !1, this.blending = t.blendMode !== void 0 ? t.blendMode : wr, this.transparent = !0, this.side = t.side !== void 0 ? t.side : Ss;
  }
  update() {
    this.uniforms.time.value = this.clock.getElapsedTime();
  }
}
const dp = ["uniforms-fresnelAmount-value", "uniforms-enableBlinking-value", "uniforms-fresnelOpacity-value", "uniforms-hologramBrightness-value", "uniforms-scanlineSize-value", "uniforms-signalSpeed-value", "uniforms-hologramColor-value", "uniforms-hologramOpacity-value", "uniforms-blinkFresnelOnly-value", "enableAdditive", "side"], $g = /* @__PURE__ */ me({
  __name: "index",
  props: {
    fresnelAmount: { default: 0.45 },
    fresnelOpacity: { default: 1 },
    blinkFresnelOnly: { type: Boolean, default: !0 },
    enableBlinking: { type: Boolean, default: !0 },
    enableAdditive: { type: Boolean, default: !0 },
    hologramBrightness: { default: 0.7 },
    scanlineSize: { default: 8 },
    signalSpeed: { default: 0.45 },
    hologramOpacity: { default: 1 },
    hologramColor: { default: "#00d5ff" },
    side: { default: Ss }
  },
  setup(o, { expose: e }) {
    const t = o, n = ye(), { extend: s } = ve();
    s({ HolographicMaterial: Vo }), e({ root: n, constructor: Vo });
    const { onBeforeRender: i } = Ke();
    return i(({ invalidate: r }) => {
      var a;
      (a = n.value) == null || a.update(), r();
    }), (r, a) => (ue(), de("TresHolographicMaterial", {
      ref_key: "MeshHolographicMaterialClass",
      ref: n,
      "uniforms-fresnelAmount-value": t.fresnelAmount,
      "uniforms-enableBlinking-value": t.enableBlinking,
      "uniforms-fresnelOpacity-value": t.fresnelOpacity,
      "uniforms-hologramBrightness-value": t.hologramBrightness,
      "uniforms-scanlineSize-value": t.scanlineSize,
      "uniforms-signalSpeed-value": t.signalSpeed,
      "uniforms-hologramColor-value": t.hologramColor,
      "uniforms-hologramOpacity-value": t.hologramOpacity,
      "uniforms-blinkFresnelOnly-value": t.blinkFresnelOnly,
      enableAdditive: t.enableAdditive,
      side: t.side
    }, null, 8, dp));
  }
});
function wn(o, e, t) {
  return Math.max(e, Math.min(t, o));
}
function pp(o, e) {
  return (o % e + e) % e;
}
function mp(o, e, t, n, s) {
  return n + (o - e) * (s - n) / (t - e);
}
function Xi(o, e, t) {
  return (1 - t) * o + t * e;
}
const gp = "", vn = "srgb", Nr = "srgb-linear", yp = "display-p3", pl = "display-p3-linear", _r = "linear", Yo = "srgb", Xo = "rec709", Wo = "p3";
class Is {
  constructor(e, t, n, s, i, r, a, l, c) {
    Is.prototype.isMatrix3 = !0, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, n, s, i, r, a, l, c);
  }
  set(e, t, n, s, i, r, a, l, c) {
    const h = this.elements;
    return h[0] = e, h[1] = s, h[2] = a, h[3] = t, h[4] = i, h[5] = l, h[6] = n, h[7] = r, h[8] = c, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  copy(e) {
    const t = this.elements, n = e.elements;
    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this;
  }
  extractBasis(e, t, n) {
    return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[4],
      t[8],
      t[1],
      t[5],
      t[9],
      t[2],
      t[6],
      t[10]
    ), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const n = e.elements, s = t.elements, i = this.elements, r = n[0], a = n[3], l = n[6], c = n[1], h = n[4], u = n[7], p = n[2], f = n[5], g = n[8], m = s[0], y = s[3], d = s[6], w = s[1], v = s[4], E = s[7], P = s[2], T = s[5], b = s[8];
    return i[0] = r * m + a * w + l * P, i[3] = r * y + a * v + l * T, i[6] = r * d + a * E + l * b, i[1] = c * m + h * w + u * P, i[4] = c * y + h * v + u * T, i[7] = c * d + h * E + u * b, i[2] = p * m + f * w + g * P, i[5] = p * y + f * v + g * T, i[8] = p * d + f * E + g * b, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], n = e[1], s = e[2], i = e[3], r = e[4], a = e[5], l = e[6], c = e[7], h = e[8];
    return t * r * h - t * a * c - n * i * h + n * a * l + s * i * c - s * r * l;
  }
  invert() {
    const e = this.elements, t = e[0], n = e[1], s = e[2], i = e[3], r = e[4], a = e[5], l = e[6], c = e[7], h = e[8], u = h * r - a * c, p = a * l - h * i, f = c * i - r * l, g = t * u + n * p + s * f;
    if (g === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const m = 1 / g;
    return e[0] = u * m, e[1] = (s * c - h * n) * m, e[2] = (a * n - s * r) * m, e[3] = p * m, e[4] = (h * t - s * l) * m, e[5] = (s * i - a * t) * m, e[6] = f * m, e[7] = (n * l - c * t) * m, e[8] = (r * t - n * i) * m, this;
  }
  transpose() {
    let e;
    const t = this.elements;
    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
  }
  setUvTransform(e, t, n, s, i, r, a) {
    const l = Math.cos(i), c = Math.sin(i);
    return this.set(
      n * l,
      n * c,
      -n * (l * r + c * a) + r + e,
      -s * c,
      s * l,
      -s * (-c * r + l * a) + a + t,
      0,
      0,
      1
    ), this;
  }
  //
  scale(e, t) {
    return this.premultiply(Wi.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply(Wi.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply(Wi.makeTranslation(e, t)), this;
  }
  // for 2D Transforms
  makeTranslation(e, t) {
    return e.isVector2 ? this.set(
      1,
      0,
      e.x,
      0,
      1,
      e.y,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      e,
      0,
      1,
      t,
      0,
      0,
      1
    ), this;
  }
  makeRotation(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(
      t,
      -n,
      0,
      n,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, t) {
    return this.set(
      e,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  //
  equals(e) {
    const t = this.elements, n = e.elements;
    for (let s = 0; s < 9; s++)
      if (t[s] !== n[s]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 9; n++)
      this.elements[n] = e[n + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.elements;
    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const Wi = /* @__PURE__ */ new Is(), $o = /* @__PURE__ */ new Is().set(
  0.8224621,
  0.177538,
  0,
  0.0331941,
  0.9668058,
  0,
  0.0170827,
  0.0723974,
  0.9105199
), Zo = /* @__PURE__ */ new Is().set(
  1.2249401,
  -0.2249404,
  0,
  -0.0420569,
  1.0420571,
  0,
  -0.0196376,
  -0.0786361,
  1.0982735
), gs = {
  [Nr]: {
    transfer: _r,
    primaries: Xo,
    luminanceCoefficients: [0.2126, 0.7152, 0.0722],
    toReference: (o) => o,
    fromReference: (o) => o
  },
  [vn]: {
    transfer: Yo,
    primaries: Xo,
    luminanceCoefficients: [0.2126, 0.7152, 0.0722],
    toReference: (o) => o.convertSRGBToLinear(),
    fromReference: (o) => o.convertLinearToSRGB()
  },
  [pl]: {
    transfer: _r,
    primaries: Wo,
    luminanceCoefficients: [0.2289, 0.6917, 0.0793],
    toReference: (o) => o.applyMatrix3(Zo),
    fromReference: (o) => o.applyMatrix3($o)
  },
  [yp]: {
    transfer: Yo,
    primaries: Wo,
    luminanceCoefficients: [0.2289, 0.6917, 0.0793],
    toReference: (o) => o.convertSRGBToLinear().applyMatrix3(Zo),
    fromReference: (o) => o.applyMatrix3($o).convertLinearToSRGB()
  }
}, vp = /* @__PURE__ */ new Set([Nr, pl]), Ot = {
  enabled: !0,
  _workingColorSpace: Nr,
  get workingColorSpace() {
    return this._workingColorSpace;
  },
  set workingColorSpace(o) {
    if (!vp.has(o))
      throw new Error(`Unsupported working color space, "${o}".`);
    this._workingColorSpace = o;
  },
  convert: function(o, e, t) {
    if (this.enabled === !1 || e === t || !e || !t)
      return o;
    const n = gs[e].toReference, s = gs[t].fromReference;
    return s(n(o));
  },
  fromWorkingColorSpace: function(o, e) {
    return this.convert(o, this._workingColorSpace, e);
  },
  toWorkingColorSpace: function(o, e) {
    return this.convert(o, e, this._workingColorSpace);
  },
  getPrimaries: function(o) {
    return gs[o].primaries;
  },
  getTransfer: function(o) {
    return o === gp ? _r : gs[o].transfer;
  },
  getLuminanceCoefficients: function(o, e = this._workingColorSpace) {
    return o.fromArray(gs[e].luminanceCoefficients);
  }
};
function $i(o) {
  return o < 0.04045 ? o * 0.0773993808 : Math.pow(o * 0.9478672986 + 0.0521327014, 2.4);
}
function Zi(o) {
  return o < 31308e-7 ? o * 12.92 : 1.055 * Math.pow(o, 0.41666) - 0.055;
}
const ml = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, mn = { h: 0, s: 0, l: 0 }, Js = { h: 0, s: 0, l: 0 };
function Ki(o, e, t) {
  return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? o + (e - o) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? o + (e - o) * 6 * (2 / 3 - t) : o;
}
class hi {
  constructor(e, t, n) {
    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, n);
  }
  set(e, t, n) {
    if (t === void 0 && n === void 0) {
      const s = e;
      s && s.isColor ? this.copy(s) : typeof s == "number" ? this.setHex(s) : typeof s == "string" && this.setStyle(s);
    } else
      this.setRGB(e, t, n);
    return this;
  }
  setScalar(e) {
    return this.r = e, this.g = e, this.b = e, this;
  }
  setHex(e, t = vn) {
    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, Ot.toWorkingColorSpace(this, t), this;
  }
  setRGB(e, t, n, s = Ot.workingColorSpace) {
    return this.r = e, this.g = t, this.b = n, Ot.toWorkingColorSpace(this, s), this;
  }
  setHSL(e, t, n, s = Ot.workingColorSpace) {
    if (e = pp(e, 1), t = wn(t, 0, 1), n = wn(n, 0, 1), t === 0)
      this.r = this.g = this.b = n;
    else {
      const i = n <= 0.5 ? n * (1 + t) : n + t - n * t, r = 2 * n - i;
      this.r = Ki(r, i, e + 1 / 3), this.g = Ki(r, i, e), this.b = Ki(r, i, e - 1 / 3);
    }
    return Ot.toWorkingColorSpace(this, s), this;
  }
  setStyle(e, t = vn) {
    function n(i) {
      i !== void 0 && parseFloat(i) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
    }
    let s;
    if (s = /^(\w+)\(([^\)]*)\)/.exec(e)) {
      let i;
      const r = s[1], a = s[2];
      switch (r) {
        case "rgb":
        case "rgba":
          if (i = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
            return n(i[4]), this.setRGB(
              Math.min(255, parseInt(i[1], 10)) / 255,
              Math.min(255, parseInt(i[2], 10)) / 255,
              Math.min(255, parseInt(i[3], 10)) / 255,
              t
            );
          if (i = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
            return n(i[4]), this.setRGB(
              Math.min(100, parseInt(i[1], 10)) / 100,
              Math.min(100, parseInt(i[2], 10)) / 100,
              Math.min(100, parseInt(i[3], 10)) / 100,
              t
            );
          break;
        case "hsl":
        case "hsla":
          if (i = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
            return n(i[4]), this.setHSL(
              parseFloat(i[1]) / 360,
              parseFloat(i[2]) / 100,
              parseFloat(i[3]) / 100,
              t
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if (s = /^\#([A-Fa-f\d]+)$/.exec(e)) {
      const i = s[1], r = i.length;
      if (r === 3)
        return this.setRGB(
          parseInt(i.charAt(0), 16) / 15,
          parseInt(i.charAt(1), 16) / 15,
          parseInt(i.charAt(2), 16) / 15,
          t
        );
      if (r === 6)
        return this.setHex(parseInt(i, 16), t);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0)
      return this.setColorName(e, t);
    return this;
  }
  setColorName(e, t = vn) {
    const n = ml[e.toLowerCase()];
    return n !== void 0 ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  }
  copySRGBToLinear(e) {
    return this.r = $i(e.r), this.g = $i(e.g), this.b = $i(e.b), this;
  }
  copyLinearToSRGB(e) {
    return this.r = Zi(e.r), this.g = Zi(e.g), this.b = Zi(e.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = vn) {
    return Ot.fromWorkingColorSpace(ot.copy(this), e), Math.round(wn(ot.r * 255, 0, 255)) * 65536 + Math.round(wn(ot.g * 255, 0, 255)) * 256 + Math.round(wn(ot.b * 255, 0, 255));
  }
  getHexString(e = vn) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = Ot.workingColorSpace) {
    Ot.fromWorkingColorSpace(ot.copy(this), t);
    const n = ot.r, s = ot.g, i = ot.b, r = Math.max(n, s, i), a = Math.min(n, s, i);
    let l, c;
    const h = (a + r) / 2;
    if (a === r)
      l = 0, c = 0;
    else {
      const u = r - a;
      switch (c = h <= 0.5 ? u / (r + a) : u / (2 - r - a), r) {
        case n:
          l = (s - i) / u + (s < i ? 6 : 0);
          break;
        case s:
          l = (i - n) / u + 2;
          break;
        case i:
          l = (n - s) / u + 4;
          break;
      }
      l /= 6;
    }
    return e.h = l, e.s = c, e.l = h, e;
  }
  getRGB(e, t = Ot.workingColorSpace) {
    return Ot.fromWorkingColorSpace(ot.copy(this), t), e.r = ot.r, e.g = ot.g, e.b = ot.b, e;
  }
  getStyle(e = vn) {
    Ot.fromWorkingColorSpace(ot.copy(this), e);
    const t = ot.r, n = ot.g, s = ot.b;
    return e !== vn ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${s.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(n * 255)},${Math.round(s * 255)})`;
  }
  offsetHSL(e, t, n) {
    return this.getHSL(mn), this.setHSL(mn.h + e, mn.s + t, mn.l + n);
  }
  add(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this;
  }
  addColors(e, t) {
    return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
  }
  addScalar(e) {
    return this.r += e, this.g += e, this.b += e, this;
  }
  sub(e) {
    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
  }
  multiply(e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
  }
  multiplyScalar(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  }
  lerp(e, t) {
    return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this;
  }
  lerpColors(e, t, n) {
    return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this;
  }
  lerpHSL(e, t) {
    this.getHSL(mn), e.getHSL(Js);
    const n = Xi(mn.h, Js.h, t), s = Xi(mn.s, Js.s, t), i = Xi(mn.l, Js.l, t);
    return this.setHSL(n, s, i), this;
  }
  setFromVector3(e) {
    return this.r = e.x, this.g = e.y, this.b = e.z, this;
  }
  applyMatrix3(e) {
    const t = this.r, n = this.g, s = this.b, i = e.elements;
    return this.r = i[0] * t + i[3] * n + i[6] * s, this.g = i[1] * t + i[4] * n + i[7] * s, this.b = i[2] * t + i[5] * n + i[8] * s, this;
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
  }
  fromBufferAttribute(e, t) {
    return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const ot = /* @__PURE__ */ new hi();
hi.NAMES = ml;
class Ur {
  constructor(e = 0, t = 0) {
    Ur.prototype.isVector2 = !0, this.x = e, this.y = t;
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return this.x = e, this.y = t, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x, n = this.y, s = e.elements;
    return this.x = s[0] * t + s[3] * n + s[6], this.y = s[1] * t + s[4] * n + s[7], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this;
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const n = this.dot(e) / t;
    return Math.acos(wn(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, n = this.y - e.y;
    return t * t + n * n;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
  }
  lerpVectors(e, t, n) {
    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this;
  }
  rotateAround(e, t) {
    const n = Math.cos(t), s = Math.sin(t), i = this.x - e.x, r = this.y - e.y;
    return this.x = i * n - r * s + e.x, this.y = i * s + r * n + e.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class _p extends Ps {
  constructor(t = {}) {
    super();
    ce(this, "isMeshPhysicalMaterial");
    ce(this, "clearcoatMap");
    ce(this, "clearcoatRoughness");
    ce(this, "clearcoatRoughnessMap");
    ce(this, "clearcoatNormalScale");
    ce(this, "clearcoatNormalMap");
    ce(this, "ior");
    ce(this, "transmissionMap");
    ce(this, "thickness");
    ce(this, "thicknessMap");
    ce(this, "attenuationDistance");
    ce(this, "attenuationColor");
    ce(this, "specularIntensity");
    ce(this, "specularIntensityMap");
    ce(this, "specularColor");
    ce(this, "specularColorMap");
    ce(this, "_clearcoat");
    ce(this, "_transmission");
    this.isMeshPhysicalMaterial = !0, this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Ur(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
      get() {
        return wn(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
      },
      set(n) {
        this.ior = (1 + 0.4 * n) / (1 - 0.4 * n);
      }
    }), this.roughness = 0, this.transmissionMap = null, this.thickness = 0.5, this.thicknessMap = null, this.attenuationDistance = Number.POSITIVE_INFINITY, this.attenuationColor = new hi(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new hi(1, 1, 1), this.specularColorMap = null, this._clearcoat = 0.5, this._transmission = 1, this.setValues(t);
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(t) {
    this._clearcoat > 0 != t > 0 && this.version++, this._clearcoat = t;
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(t) {
    this._transmission > 0 != t > 0 && this.version++, this._transmission = t;
  }
  copy(t) {
    return super.copy(t), this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.ior = t.ior, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this.thickness = t.thickness, this.thicknessMap = t.thicknessMap, this.attenuationDistance = t.attenuationDistance, this.attenuationColor.copy(t.attenuationColor), this.specularIntensity = t.specularIntensity, this.specularIntensityMap = t.specularIntensityMap, this.specularColor.copy(t.specularColor), this.specularColorMap = t.specularColorMap, this;
  }
}
const Zg = /* @__PURE__ */ me({
  __name: "index",
  setup(o, { expose: e }) {
    const t = ye(), { extend: n } = ve();
    return n({ MeshGlassMaterial: _p }), e({ instance: t }), (s, i) => (ue(), de("TresMeshGlassMaterial", {
      ref_key: "MeshGlassMaterialClass",
      ref: t
    }, null, 512));
  }
}), xp = () => Number.parseInt(di.replace(/\D+/g, "")), wp = /* @__PURE__ */ xp();
class Tp extends Lt {
  constructor(t = new ge()) {
    super({
      uniforms: {
        inputBuffer: new Me(null),
        depthBuffer: new Me(null),
        resolution: new Me(new ge()),
        texelSize: new Me(new ge()),
        halfTexelSize: new Me(new ge()),
        kernel: new Me(0),
        scale: new Me(1),
        cameraNear: new Me(0),
        cameraFar: new Me(1),
        depthEdge0: new Me(0),
        depthEdge1: new Me(1),
        depthScale: new Me(0),
        depthBias: new Me(0.25)
      },
      fragmentShader: `#include <common>
        #include <dithering_pars_fragment>      
        uniform sampler2D inputBuffer;
        uniform sampler2D depthBuffer;
        uniform float cameraNear;
        uniform float cameraFar;
        uniform float depthEdge0;
        uniform float depthEdge1;
        uniform float depthScale;
        uniform float depthBias;
        varying vec2 vUv;
        varying vec2 vUv0;
        varying vec2 vUv1;
        varying vec2 vUv2;
        varying vec2 vUv3;

        void main() {
          float depthFactor = 0.0;
          
          #ifdef USE_DEPTH
            vec4 depth = texture2D(depthBuffer, vUv);
            depthFactor = smoothstep(
              1.0 - depthEdge1, 1.0 - depthEdge0,
              1.0 - (depth.r * depth.a) + depthBias
            );
            depthFactor = clamp(depthScale * depthFactor + 0.25, 0.0, 1.0);
          #endif

          gl_FragColor = 0.25 * (
            texture2D(inputBuffer, mix(vUv0, vUv, depthFactor))
            + texture2D(inputBuffer, mix(vUv1, vUv, depthFactor))
            + texture2D(inputBuffer, mix(vUv2, vUv, depthFactor))
            + texture2D(inputBuffer, mix(vUv3, vUv, depthFactor))
          );
          
          #include <dithering_fragment>
          #include <tonemapping_fragment>
          #include <${wp >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
        }`,
      vertexShader: `uniform vec2 texelSize;
        uniform vec2 halfTexelSize;
        uniform float kernel;
        uniform float scale;
        varying vec2 vUv;
        varying vec2 vUv0;
        varying vec2 vUv1;
        varying vec2 vUv2;
        varying vec2 vUv3;

        void main() {
          vec2 uv = position.xy * 0.5 + 0.5;
          vUv = uv;

          vec2 dUv = (texelSize * vec2(kernel) + halfTexelSize) * scale;
          vUv0 = vec2(uv.x - dUv.x, uv.y + dUv.y);
          vUv1 = vec2(uv.x + dUv.x, uv.y + dUv.y);
          vUv2 = vec2(uv.x + dUv.x, uv.y - dUv.y);
          vUv3 = vec2(uv.x - dUv.x, uv.y - dUv.y);

          gl_Position = vec4(position.xy, 1.0, 1.0);
        }`,
      blending: ec,
      depthWrite: !1,
      depthTest: !1
    });
    ce(this, "kernel");
    this.toneMapped = !1, this.setTexelSize(t.x, t.y), this.kernel = new Float32Array([0, 1, 2, 2, 3]);
  }
  setTexelSize(t, n) {
    this.uniforms.texelSize.value.set(t, n), this.uniforms.halfTexelSize.value.set(t, n).multiplyScalar(0.5);
  }
  setResolution(t) {
    this.uniforms.resolution.value.copy(t);
  }
}
class bp {
  constructor({
    resolution: e,
    width: t = 500,
    height: n = 500,
    depthEdge0: s = 0,
    depthEdge1: i = 1,
    depthScale: r = 0,
    depthBias: a = 0.25
  }) {
    ce(this, "renderTargetA");
    ce(this, "renderTargetB");
    ce(this, "convolutionMaterial");
    ce(this, "scene");
    ce(this, "camera");
    ce(this, "screen");
    ce(this, "renderToScreen", !1);
    this.renderTargetA = new jt(e, e, {
      minFilter: vt,
      magFilter: vt,
      stencilBuffer: !1,
      depthBuffer: !1,
      type: Vt
    }), this.renderTargetB = this.renderTargetA.clone(), this.convolutionMaterial = new Tp(), this.convolutionMaterial.setTexelSize(1 / t, 1 / n), this.convolutionMaterial.setResolution(new ge(t, n)), this.scene = new Ts(), this.camera = new tc(), this.convolutionMaterial.uniforms.depthEdge0.value = s, this.convolutionMaterial.uniforms.depthEdge1.value = i, this.convolutionMaterial.uniforms.depthScale.value = r, this.convolutionMaterial.uniforms.depthBias.value = a, this.convolutionMaterial.defines.USE_DEPTH = r > 0;
    const l = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]), c = new Float32Array([0, 0, 2, 0, 0, 2]), h = new pt();
    h.setAttribute("position", new mt(l, 3)), h.setAttribute("uv", new mt(c, 2)), this.screen = new he(h, this.convolutionMaterial), this.screen.frustumCulled = !1, this.scene.add(this.screen);
  }
  render(e, t, n) {
    const s = this.scene, i = this.camera, r = this.renderTargetA, a = this.renderTargetB, l = this.convolutionMaterial, c = l.uniforms;
    c.depthBuffer.value = t.depthTexture;
    const h = l.kernel;
    let u = t, p, f, g;
    for (f = 0, g = h.length - 1; f < g; ++f)
      p = f & 1 ? a : r, c.kernel.value = h[f], c.inputBuffer.value = u.texture, e.setRenderTarget(p), e.render(s, i), u = p;
    c.kernel.value = h[f], c.inputBuffer.value = u.texture, e.setRenderTarget(this.renderToScreen ? null : n), e.render(s, i);
  }
  dispose() {
    this.screen.material.dispose(), this.screen.geometry.dispose(), this.renderTargetA.dispose(), this.renderTargetB.dispose(), this.convolutionMaterial.dispose();
  }
}
class Ep extends Ps {
  constructor(t = {}) {
    super(t);
    ce(this, "_tDepth", { value: null });
    ce(this, "_distortionMap", { value: null });
    ce(this, "_tSharp", { value: null });
    ce(this, "_tBlur", { value: null });
    ce(this, "_textureMatrix", { value: null });
    ce(this, "_mix", { value: 0.5 });
    ce(this, "_sharpMix", { value: 0 });
    ce(this, "_blurMixSmooth", { value: 0 });
    ce(this, "_blurMixRough", { value: 0 });
    ce(this, "_sharpDepthEdgeMin", { value: 0.9 });
    ce(this, "_sharpDepthEdgeMax", { value: 1 });
    ce(this, "_sharpDepthScale", { value: 0 });
    ce(this, "_sharpDepthBias", { value: 0 });
    ce(this, "_distortion", { value: 1 });
    this.setValues(t);
  }
  onBeforeCompile(t) {
    var n;
    (n = t.defines) != null && n.USE_UV || (t.defines.USE_UV = "");
    for (const s of Object.keys(t.defines))
      t.defines[s.toUpperCase()] = t.defines[s];
    t.uniforms.tSharp = this._tSharp, t.uniforms.tDepth = this._tDepth, t.uniforms.tBlur = this._tBlur, t.uniforms.distortionMap = this._distortionMap, t.uniforms.textureMatrix = this._textureMatrix, t.uniforms.mixMain = this._mix, t.uniforms.sharpMix = this._sharpMix, t.uniforms.sharpDepthScale = this._sharpDepthScale, t.uniforms.sharpDepthEdgeMin = this._sharpDepthEdgeMin, t.uniforms.sharpDepthEdgeMax = this._sharpDepthEdgeMax, t.uniforms.sharpDepthBias = this._sharpDepthBias, t.uniforms.blurMixSmooth = this._blurMixSmooth, t.uniforms.blurMixRough = this._blurMixRough, t.uniforms.distortion = this._distortion, t.vertexShader = `
        uniform mat4 textureMatrix;
        varying vec4 my_vUv;
      ${t.vertexShader}`, t.vertexShader = t.vertexShader.replace(
      "#include <project_vertex>",
      `#include <project_vertex>
        my_vUv = textureMatrix * vec4( position, 1.0 );
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );`
    ), t.fragmentShader = `
        uniform sampler2D tSharp;
        uniform sampler2D tBlur;
        uniform sampler2D tDepth;
        uniform sampler2D distortionMap;
        uniform float distortion;
        uniform float cameraNear;
        uniform float cameraFar;
        uniform float mixMain;
        uniform float sharpMix;
        uniform float blurMixSmooth;
        uniform float blurMixRough;
        uniform float sharpDepthScale;
        uniform float sharpDepthBias;
        uniform float sharpDepthEdgeMin;
        uniform float sharpDepthEdgeMax;
        varying vec4 my_vUv;
        ${t.fragmentShader}`, t.fragmentShader = t.fragmentShader.replace(
      "#include <emissivemap_fragment>",
      `#include <emissivemap_fragment>

      vec4 new_vUv = my_vUv;

      #ifdef USE_DISTORTION
        float distortionFactor = (texture(distortionMap, vUv).r - 0.5) * distortion;
        new_vUv.x += distortionFactor;
        new_vUv.y += distortionFactor;
      #endif

      #ifdef USE_NORMALMAP

        vec4 normalColor = texture(normalMap, vUv * normalScale);
        vec3 my_normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );
        vec3 coord = new_vUv.xyz / new_vUv.w;
        vec2 normal_uv = coord.xy + coord.z * my_normal.xz * 0.05;

        vec4 sharp = texture(tSharp, normal_uv);

        #ifdef USE_BLUR
          vec4 blur = texture(tBlur, normal_uv);
        #endif

        #ifdef USE_DEPTH
          vec4 depth = texture(tDepth, normal_uv);
        #endif

      #else

        vec4 sharp = textureProj(tSharp, new_vUv);

        #ifdef USE_BLUR
          vec4 blur = textureProj(tBlur, new_vUv);
        #endif

        #ifdef USE_DEPTH
          vec4 depth = textureProj(tDepth, new_vUv);
        #endif

      #endif

      #ifdef USE_DEPTH
        float depthFactor = smoothstep(
          1.0 - sharpDepthEdgeMax, 1.0 - sharpDepthEdgeMin,
          1.0 - (depth.r * depth.a) + sharpDepthBias
        );
        depthFactor = clamp(sharpDepthScale * depthFactor, 0.0, 1.0);

        sharp *= depthFactor;
      #endif

      sharp *= (1.0 - roughnessFactor);
      `
    ), t.fragmentShader = t.fragmentShader.replace(
      "#include <opaque_fragment>",
      `

      #ifdef USE_BLUR
        outgoingLight += mixMain * (
          vec3(sharp) * sharpMix
          + vec3(blur) * (blurMixSmooth * (1.0 - roughnessFactor) + blurMixRough * roughnessFactor)
        );
      #else
        outgoingLight += mixMain * vec3(sharp) * sharpMix;
      #endif

      #include <opaque_fragment>
      `
    );
  }
  get tSharp() {
    return this._tSharp.value;
  }
  set tSharp(t) {
    this._tSharp.value = t;
  }
  get tDepth() {
    return this._tDepth.value;
  }
  set tDepth(t) {
    this._tDepth.value = t;
  }
  get distortionMap() {
    return this._distortionMap.value;
  }
  set distortionMap(t) {
    this._distortionMap.value = t;
  }
  get tBlur() {
    return this._tBlur.value;
  }
  set tBlur(t) {
    this._tBlur.value = t;
  }
  get textureMatrix() {
    return this._textureMatrix.value;
  }
  set textureMatrix(t) {
    this._textureMatrix.value = t;
  }
  get sharpMix() {
    return this._sharpMix.value;
  }
  set sharpMix(t) {
    this._sharpMix.value = t;
  }
  get blurMixSmooth() {
    return this._blurMixSmooth.value;
  }
  set blurMixSmooth(t) {
    this._blurMixSmooth.value = t;
  }
  get blurMixRough() {
    return this._blurMixRough.value;
  }
  set blurMixRough(t) {
    this._blurMixRough.value = t;
  }
  get mix() {
    return this._mix.value;
  }
  set mix(t) {
    this._mix.value = t;
  }
  get sharpDepthScale() {
    return this._sharpDepthScale.value;
  }
  set sharpDepthScale(t) {
    this._sharpDepthScale.value = t;
  }
  get sharpDepthBias() {
    return this._sharpDepthBias.value;
  }
  set sharpDepthBias(t) {
    this._sharpDepthBias.value = t;
  }
  get sharpDepthEdgeMin() {
    return this._sharpDepthEdgeMin.value;
  }
  set sharpDepthEdgeMin(t) {
    this._sharpDepthEdgeMin.value = t;
  }
  get sharpDepthEdgeMax() {
    return this._sharpDepthEdgeMax.value;
  }
  set sharpDepthEdgeMax(t) {
    this._sharpDepthEdgeMax.value = t;
  }
  get distortion() {
    return this._distortion.value;
  }
  set distortion(t) {
    this._distortion.value = t;
  }
}
const Mp = ["texture-matrix", "t-sharp", "t-depth", "t-blur", "defines-USE_BLUR", "defines-USE_DEPTH", "defines-USE_DISTORTION"], Kg = /* @__PURE__ */ me({
  __name: "index",
  props: {
    resolution: { default: 256 },
    mix: { default: 1 },
    sharpMix: { default: 1 },
    sharpDepthScale: { default: 1 },
    sharpDepthBias: { default: 0 },
    sharpDepthEdgeMin: { default: 0 },
    sharpDepthEdgeMax: { default: 0.2 },
    blurMixSmooth: { default: 1 },
    blurMixRough: { default: 1 },
    blurDepthScale: { default: 1 },
    blurDepthBias: { default: 0 },
    blurDepthEdgeMin: { default: 0 },
    blurDepthEdgeMax: { default: 0.2 },
    blurSize: { default: () => [0, 0] },
    distortionMap: {},
    distortion: { default: 0 },
    reflectorOffset: { default: 0 },
    color: { default: () => new Pe(3355443) },
    roughness: { default: 1 },
    metalness: { default: 0 },
    map: {},
    lightMap: {},
    lightMapIntensity: { default: 1 },
    aoMap: {},
    aoMapIntensity: { default: 1 },
    emissive: { default: () => new Pe(0) },
    emissiveIntensity: { default: 1 },
    emissiveMap: {},
    bumpMap: {},
    bumpScale: { default: 1 },
    normalMap: {},
    normalMapType: { default: nc },
    normalScale: { default: () => new ge(1, 1) },
    displacementMap: {},
    displacementScale: { default: 1 },
    displacementBias: { default: 0 },
    roughnessMap: { default: null },
    metalnessMap: {},
    alphaMap: {},
    envMap: {},
    envMapRotation: { default: () => new Tn() },
    envMapIntensity: { default: 1 },
    wireframe: { type: Boolean, default: !1 },
    wireframeLinewidth: { default: 1 },
    wireframeLinecap: { default: "round" },
    wireframeLinejoin: { default: "round" },
    flatShading: { type: Boolean, default: !1 },
    fog: { type: Boolean, default: !0 }
  },
  setup(o, { expose: e }) {
    const t = o, { extend: n, invalidate: s } = ve();
    n({ MeshReflectionMaterial: Ep });
    const i = Fe(() => 500 - (Array.isArray(t.blurSize) ? t.blurSize[0] : t.blurSize)), r = Fe(() => 500 - (Array.isArray(t.blurSize) ? t.blurSize[1] : t.blurSize)), a = Fe(() => i.value > 0 || r.value > 0), l = Fe(() => t.sharpDepthScale > 0 || t.blurDepthScale > 0), c = Fe(() => !!t.distortionMap), h = Fe(() => !!t.roughnessMap), u = ye();
    let p;
    const f = {
      reflectorPlane: new pi(),
      normal: new $(),
      reflectorWorldPosition: new $(),
      cameraWorldPosition: new $(),
      rotationMatrix: new Re(),
      lookAtPosition: new $(0, 0, -1),
      clipPlane: new it(),
      view: new $(),
      target: new $(),
      q: new it(),
      virtualCamera: new At(),
      textureMatrix: new Re()
    }, g = new jt(
      t.resolution,
      t.resolution,
      {
        minFilter: vt,
        magFilter: vt,
        type: Vt,
        depthBuffer: !0,
        depthTexture: new xa(
          t.resolution,
          t.resolution
        )
      }
    ), m = new jt(
      t.resolution,
      t.resolution,
      {
        minFilter: vt,
        magFilter: vt,
        type: Vt
      }
    );
    function y(d, w, v, E) {
      s();
      const P = d.xr.enabled, T = d.shadowMap.autoUpdate;
      if (f.reflectorWorldPosition.setFromMatrixPosition(E.matrixWorld), f.cameraWorldPosition.setFromMatrixPosition(v.matrixWorld), f.rotationMatrix.extractRotation(E.matrixWorld), f.normal.set(0, 0, 1), f.normal.applyMatrix4(f.rotationMatrix), f.reflectorWorldPosition.addScaledVector(f.normal, t.reflectorOffset), f.view.subVectors(f.reflectorWorldPosition, f.cameraWorldPosition), f.view.dot(f.normal) > 0)
        return;
      E.visible = !1, f.view.reflect(f.normal).negate(), f.view.add(f.reflectorWorldPosition), f.rotationMatrix.extractRotation(v.matrixWorld), f.lookAtPosition.set(0, 0, -1), f.lookAtPosition.applyMatrix4(f.rotationMatrix), f.lookAtPosition.add(f.cameraWorldPosition), f.target.subVectors(f.reflectorWorldPosition, f.lookAtPosition), f.target.reflect(f.normal).negate(), f.target.add(f.reflectorWorldPosition), f.virtualCamera.position.copy(f.view), f.virtualCamera.up.set(0, 1, 0), f.virtualCamera.up.applyMatrix4(f.rotationMatrix), f.virtualCamera.up.reflect(f.normal), f.virtualCamera.lookAt(f.target), f.virtualCamera.far = v.far, f.virtualCamera.updateMatrixWorld(), f.virtualCamera.projectionMatrix.copy(v.projectionMatrix), f.textureMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), f.textureMatrix.multiply(f.virtualCamera.projectionMatrix), f.textureMatrix.multiply(f.virtualCamera.matrixWorldInverse), f.textureMatrix.multiply(E.matrixWorld), f.reflectorPlane.setFromNormalAndCoplanarPoint(f.normal, f.reflectorWorldPosition), f.reflectorPlane.applyMatrix4(f.virtualCamera.matrixWorldInverse), f.clipPlane.set(
        f.reflectorPlane.normal.x,
        f.reflectorPlane.normal.y,
        f.reflectorPlane.normal.z,
        f.reflectorPlane.constant
      );
      const b = f.virtualCamera.projectionMatrix;
      f.q.x = (Math.sign(f.clipPlane.x) + b.elements[8]) / b.elements[0], f.q.y = (Math.sign(f.clipPlane.y) + b.elements[9]) / b.elements[5], f.q.z = -1, f.q.w = (1 + b.elements[10]) / b.elements[14], f.clipPlane.multiplyScalar(2 / f.clipPlane.dot(f.q)), b.elements[2] = f.clipPlane.x, b.elements[6] = f.clipPlane.y, b.elements[10] = f.clipPlane.z + 1, b.elements[14] = f.clipPlane.w, d.shadowMap.autoUpdate = !1, d.setRenderTarget(g), d.autoClear || d.clear(), d.render(w, f.virtualCamera), p.render(d, g, m), d.xr.enabled = P, d.shadowMap.autoUpdate = T, E.visible = !0, d.setRenderTarget(null);
    }
    return ee(
      () => [t.resolution],
      () => {
        g.setSize(t.resolution, t.resolution), m.setSize(t.resolution, t.resolution);
      }
    ), ee(() => [
      t.resolution,
      i.value,
      r.value,
      t.blurDepthEdgeMin,
      t.blurDepthEdgeMax,
      t.blurDepthScale,
      t.blurDepthBias
    ], () => {
      p == null || p.dispose(), p = new bp({
        resolution: t.resolution,
        width: i.value,
        height: r.value,
        depthEdge0: t.blurDepthEdgeMin,
        depthEdge1: t.blurDepthEdgeMax,
        depthScale: t.blurDepthScale,
        depthBias: t.blurDepthBias
      });
    }, { immediate: !0 }), ee(u, () => {
      u.value && (u.value.onBeforeRender = y);
    }), ee(() => [a.value], () => {
      yt().logWarning(
        "MeshReflectionMaterial: Setting blurMixRough or blurMixSmooth to 0, then non-zero triggers a recompile.The TresJS core cannot currently handle recompiled materials."
      );
    }), ee(l, () => {
      yt().logWarning(
        "MeshReflectionMaterial: Setting depthScale to 0, then non-zero triggers a recompile.The TresJS core cannot currently handle recompiled materials."
      );
    }), ee(c, () => {
      yt().logWarning(
        "MeshReflectionMaterial: Toggling distortionMap triggers a recompile.The TresJS core cannot currently handle recompiled materials."
      );
    }), ee(h, () => {
      yt().logWarning(
        "MeshReflectionMaterial: Toggling roughnessMap triggers a recompile.The TresJS core cannot currently handle recompiled materials."
      );
    }), ee(() => [t.normalMap], () => {
      yt().logWarning(
        "MeshReflectionMaterial: Toggling normalMap triggers a recompile.The TresJS core cannot currently handle recompiled materials."
      );
    }), Sr(() => {
      g.dispose(), m.dispose(), p.dispose();
    }), Ke().onBeforeRender(({ renderer: d, scene: w, camera: v, invalidate: E }) => {
      var T, b;
      const P = (b = (T = u.value) == null ? void 0 : T.__tres) == null ? void 0 : b.parent;
      P && (y(d, w, v, P), E());
    }), e({ instance: u }), (d, w) => {
      var v, E, P;
      return ue(), de("TresMeshReflectionMaterial", Xe({
        key: `key${a.value ? "0" : "1"}${l.value ? "0" : "1"}${c.value ? "0" : "1"}${h.value ? "0" : "1"}`,
        ref_key: "materialRef",
        ref: u
      }, t, {
        "texture-matrix": f.textureMatrix,
        "t-sharp": (v = U(g)) == null ? void 0 : v.texture,
        "t-depth": (E = U(g)) == null ? void 0 : E.depthTexture,
        "t-blur": (P = U(m)) == null ? void 0 : P.texture,
        "defines-USE_BLUR": a.value ? "" : void 0,
        "defines-USE_DEPTH": l.value ? "" : void 0,
        "defines-USE_DISTORTION": c.value ? "" : void 0
      }), null, 16, Mp);
    };
  }
});
class Sp extends Ps {
  constructor(t = {}) {
    super(t);
    ce(this, "_time");
    ce(this, "_factor");
    this.setValues(t), this._time = { value: 0 }, this._factor = { value: 1 };
  }
  onBeforeCompile(t) {
    t.uniforms || (t.uniforms = {}), t.uniforms.time = this._time, t.uniforms.factor = this._factor, t.vertexShader = `
        uniform float time;
        uniform float factor;
        ${t.vertexShader}
      `, t.vertexShader = t.vertexShader.replace(
      "#include <begin_vertex>",
      `float theta = sin( time + position.y ) / 2.0 * factor;
          float c = cos( theta );
          float s = sin( theta );
          mat3 m = mat3( c, 0, s, 0, 1, 0, -s, 0, c );
          vec3 transformed = vec3( position ) * m;
          vNormal = vNormal * m;`
    );
  }
  get time() {
    return this._time.value;
  }
  set time(t) {
    this._time.value = t;
  }
  get factor() {
    return this._factor.value;
  }
  set factor(t) {
    this._factor.value = t;
  }
}
const Ap = ["factor"], qg = /* @__PURE__ */ me({
  __name: "index",
  props: {
    speed: { default: 1 },
    factor: { default: 1 }
  },
  setup(o, { expose: e }) {
    const t = o, n = ye(), { extend: s, invalidate: i } = ve();
    s({ MeshWobbleMaterial: Sp }), ee(t, () => i());
    const { onBeforeRender: r } = Ke();
    return r(({ elapsed: a, invalidate: l }) => {
      n.value && (n.value.time = a * (t == null ? void 0 : t.speed), l());
    }), e({ instance: n }), (a, l) => (ue(), de("TresMeshWobbleMaterial", Xe({
      ref_key: "materialRef",
      ref: n,
      factor: a.factor
    }, a.$attrs), null, 16, Ap));
  }
}), Qg = me({
  name: "BakeShadows",
  setup() {
    const { renderer: o } = ve();
    Ft(() => {
      o.value.shadowMap.autoUpdate = !1, o.value.shadowMap.needsUpdate = !0;
    });
  }
});
var Pp = `void main() {
  gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
}`, Cp = `#include <common>

void main() {
  vec2 center = vec2(0., 1.);
  float rotation = 0.0;

  
  
  float size = 0.03;

  vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
  vec2 scale;
  scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
  scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

  bool isPerspective = isPerspectiveMatrix( projectionMatrix );
  if ( isPerspective ) scale *= - mvPosition.z;

  vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
  vec2 rotatedPosition;
  rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
  rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
  mvPosition.xy += rotatedPosition;

  gl_Position = projectionMatrix * mvPosition;
}`;
const Os = new $(0, 0, 0), zr = new $(0, 0, 0), Rp = new $(0, 0, 0);
function Ko(o, e, t) {
  const n = Os.setFromMatrixPosition(o.matrixWorld);
  n.project(e);
  const s = t.width / 2, i = t.height / 2;
  return [
    (Number.isNaN(n.x) ? 0 : n.x) * s + s,
    -(n.y * i) + i
  ];
}
function Ip(o, e) {
  const t = Os.setFromMatrixPosition(o.matrixWorld), n = zr.setFromMatrixPosition(e.matrixWorld), s = t.sub(n), i = e.getWorldDirection(Rp);
  return s.angleTo(i) > Math.PI / 2;
}
function Op(o, e, t, n) {
  const s = Os.setFromMatrixPosition(o.matrixWorld), i = s.clone();
  i.project(e), t.setFromCamera(new ge(i.x, i.y), e);
  const r = t.intersectObjects(n, !0);
  if (r.length > 0) {
    const a = r[0].distance;
    return s.distanceTo(t.ray.origin) < a;
  }
  return !0;
}
function Dp(o, e) {
  if (e instanceof en)
    return e.zoom;
  if (e instanceof At) {
    const t = Os.setFromMatrixPosition(o.matrixWorld), n = zr.setFromMatrixPosition(e.matrixWorld), s = e.fov * Math.PI / 180, i = t.distanceTo(n);
    return 1 / (2 * Math.tan(s / 2) * i);
  } else
    return 1;
}
function Lp(o, e, t) {
  if (e instanceof At || e instanceof en) {
    const n = Os.setFromMatrixPosition(o.matrixWorld), s = zr.setFromMatrixPosition(e.matrixWorld), i = n.distanceTo(s), r = (t[1] - t[0]) / (e.far - e.near), a = t[1] - r * e.far;
    return Math.round(r * i + a);
  }
}
const xr = (o) => Math.abs(o) < 1e-10 ? 0 : o;
function gl(o, e, t = "") {
  let n = "matrix3d(";
  for (let s = 0; s !== 16; s++)
    n += xr(e[s] * o.elements[s]) + (s !== 15 ? "," : ")");
  return t + n;
}
const Fp = /* @__PURE__ */ ((o) => (e) => gl(e, o))([1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1]), kp = /* @__PURE__ */ ((o) => (e, t) => gl(e, o(t), "translate(-50%,-50%)"))((o) => [1 / o, 1 / o, 1 / o, 1, -1 / o, -1 / o, -1 / o, -1, 1 / o, 1 / o, 1 / o, 1, 1, 1, 1, 1]), Bp = ["geometry", "material"], Jg = /* @__PURE__ */ me({
  __name: "HTML",
  props: {
    geometry: { default: new zt() },
    material: {},
    as: { default: "div" },
    transform: { type: Boolean, default: !1 },
    portal: {},
    wrapperClass: {},
    eps: { default: 1e-4 },
    distanceFactor: {},
    fullscreen: { type: Boolean },
    center: { type: Boolean },
    pointerEvents: { default: "auto" },
    sprite: { type: Boolean, default: !1 },
    zIndexRange: { default: () => [16777271, 0] },
    occlude: { type: [Object, null, Array, Boolean, String] }
  },
  emits: ["onOcclude"],
  setup(o, { expose: e, emit: t }) {
    const n = o, s = t, i = Ar(), r = mc(), a = fe(), l = fe(), {
      geometry: c,
      material: h,
      as: u,
      transform: p,
      portal: f,
      wrapperClass: g,
      eps: m,
      distanceFactor: y,
      fullscreen: d,
      center: w,
      pointerEvents: v,
      sprite: E,
      occlude: P,
      zIndexRange: T
    } = De(n), { renderer: b, scene: x, camera: M, raycaster: _, sizes: C } = ve(), R = Fe(() => document.createElement(u.value)), B = fe([0, 0]), N = fe(0), j = fe(), V = Fe(() => p.value ? {
      position: "absolute",
      top: 0,
      left: 0,
      width: `${C.width.value}px`,
      height: `${C.height.value}px`,
      transformStyle: "preserve-3d",
      pointerEvents: "none",
      zIndex: 2,
      willChange: "transform"
    } : {
      position: "absolute",
      transform: w.value ? "translate3d(-50%,-50%,0)" : "none",
      ...d.value && {
        top: -C.height.value / 2,
        left: -C.width.value / 2,
        width: `${C.width.value}px`,
        height: `${C.height.value}px`
      },
      zIndex: 2,
      ...Object.assign({}, r.style),
      willChange: "transform"
    }), Q = Fe(() => ({
      position: "absolute",
      pointerEvents: v.value
    })), Z = fe(null), ne = fe(!1), te = Fe(
      () => (P == null ? void 0 : P.value) && (P == null ? void 0 : P.value) !== "blending" || Array.isArray(P == null ? void 0 : P.value) && (P == null ? void 0 : P.value.length) && ai(P.value[0])
    );
    ee(
      () => P,
      ({ value: k }) => {
        k === "blending" ? (R.value.style.zIndex = `${Math.floor(T.value[0] / 2)}`, R.value.style.position = "absolute", R.value.style.pointerEvents = "none") : (R.value.style.zIndex = null, R.value.style.position = null, R.value.style.pointerEvents = null);
      }
    ), ee(
      () => {
        var k;
        return [a.value, b.value, C.width.value, C.height.value, (k = i.default) == null ? void 0 : k.call(i)];
      },
      ([k, D]) => {
        var O, z, S, A, L, X;
        if (k && D) {
          const H = (f == null ? void 0 : f.value) || D.domElement;
          if ((O = x.value) == null || O.updateMatrixWorld(), p.value)
            R.value.style.cssText = "position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";
          else {
            const G = Ko(k, M.value, {
              width: C.width.value,
              height: C.height.value
            });
            R.value.style.cssText = `position:absolute;top:0;left:0;transform:translate3d(${G[0]}px,${G[1]}px,0);transform-origin:0 0;`;
          }
          H && !R.value.parentNode && ((z = H.parentNode) == null || z.appendChild(R.value)), p.value ? j.value = zs("div", { id: "outer", style: V.value }, [
            zs("div", { id: "inner", style: Q.value }, [
              zs("div", {
                key: (S = l.value) == null ? void 0 : S.uuid,
                id: x == null ? void 0 : x.value.uuid,
                class: r.class,
                style: r.style
              }, (A = i.default) == null ? void 0 : A.call(i))
            ])
          ]) : j.value = zs("div", {
            key: (L = l.value) == null ? void 0 : L.uuid,
            id: x == null ? void 0 : x.value.uuid,
            style: V.value
          }, (X = i.default) == null ? void 0 : X.call(i)), gc(j.value, R.value);
        }
      }
    ), Ft(() => {
      g != null && g.value && (R.value.className = g.value);
    });
    const le = fe(!0), { onBeforeRender: ae } = Ke();
    ae(({ invalidate: k }) => {
      var D, O, z, S, A, L, X;
      if (k(), a.value && M.value && b.value) {
        (D = M.value) == null || D.updateMatrixWorld(), a.value.updateWorldMatrix(!0, !1);
        const H = p.value ? B.value : Ko(a.value, M.value, {
          width: C.width.value || 0,
          height: C.height.value || 0
        });
        if (p.value || Math.abs(N.value - M.value.zoom) > m.value || Math.abs(B.value[0] - H[0]) > m.value || Math.abs(B.value[1] - H[1]) > m.value) {
          const G = Ip(a.value, M.value);
          let q = !1;
          te.value && (Array.isArray(P == null ? void 0 : P.value) ? q = P == null ? void 0 : P.value : (P == null ? void 0 : P.value) !== "blending" && (q = [x.value]));
          const se = le.value;
          if (q) {
            const F = Op(
              a.value,
              M.value,
              _.value,
              q
            );
            le.value = F && !G;
          } else
            le.value = !G;
          se !== le.value && (s("onOcclude", !le.value), R.value.style.display = le.value ? "block" : "none");
          const ie = Math.floor(T.value[0] / 2), Y = P != null && P.value ? te.value ? [T.value[0], ie] : [ie - 1, 0] : T.value;
          if (R.value.style.zIndex = `${Lp(a.value, M.value, Y)}`, R.value.style.willChange = "transform", p.value) {
            const [F, oe] = [
              C.width.value / 2,
              C.height.value / 2
            ], pe = M.value.projectionMatrix.elements[5] * oe, { isOrthographicCamera: Ae, top: Ve, left: We, bottom: xt, right: Xt } = M.value, ln = Fp(M.value.matrixWorldInverse), cn = Ae ? `scale(${pe})translate(${xr(-(Xt + We) / 2)}px,${xr((Ve + xt) / 2)}px)` : `translateZ(${pe}px)`;
            let gt = a.value.matrixWorld;
            if (E.value && (gt = M.value.matrixWorldInverse.clone().transpose().copyPosition(gt).scale(a.value.scale), gt.elements[3] = gt.elements[7] = gt.elements[11] = 0, gt.elements[15] = 1), R.value.style.width = `${C.width.value}px`, R.value.style.height = `${C.height.value}px`, R.value.style.perspective = Ae ? "" : `${pe}px`, (O = j.value) != null && O.el && ((z = j.value) != null && z.children) && Array.isArray(j.value.children)) {
              j.value.el.style.willChange = "transform", j.value.el.style.transform = `${cn}${ln}translate(${F}px,${oe}px)`;
              const wt = j.value.children[0];
              wt && wt.el && (wt.el.style.willChange = "transform", wt.el.style.transform = kp(
                gt,
                1 / (((y == null ? void 0 : y.value) || 10) / 400)
              ));
            }
          } else {
            const F = (y == null ? void 0 : y.value) === void 0 ? 1 : Dp(a.value, M.value) * (y == null ? void 0 : y.value);
            R.value.style.transform = `translate3d(${H[0]}px,${H[1]}px,0) scale(${F})`;
          }
        }
        B.value = H, N.value = M.value.zoom;
      }
      if (!te.value && l.value && !ne.value)
        if (p.value) {
          if ((S = j.value) != null && S.el && ((A = j.value) != null && A.children)) {
            const H = ((L = j.value) == null ? void 0 : L.children)[0];
            if (H != null && H.clientWidth && (H != null && H.clientHeight)) {
              const { isOrthographicCamera: G } = M.value;
              if (G || c)
                r.scale && (Array.isArray(r.scale) ? r.scale instanceof $ ? l.value.scale.copy(r.scale.clone().divideScalar(1)) : l.value.scale.set(1 / r.scale[0], 1 / r.scale[1], 1 / r.scale[2]) : l.value.scale.setScalar(1 / r.scale));
              else {
                const q = ((y == null ? void 0 : y.value) || 10) / 400, se = H.clientWidth * q, ie = H.clientHeight * q;
                l.value.scale.set(se, ie, 1);
              }
              ne.value = !0;
            }
          }
        } else {
          const H = R.value.children[0];
          if (H != null && H.clientWidth && (H != null && H.clientHeight)) {
            const q = H.clientWidth * 1, se = H.clientHeight * 1;
            l.value.scale.set(q, se, 1), ne.value = !0;
          }
          Z.value.lookAt((X = M.value) == null ? void 0 : X.position);
        }
    });
    const Te = Fe(() => ({
      vertexShader: p.value ? void 0 : Cp,
      fragmentShader: Pp
    })), I = Fe(() => {
      const k = Te.value;
      return h.value || new Lt({
        vertexShader: k.vertexShader,
        fragmentShader: k.fragmentShader,
        side: tn
      });
    });
    return rt(() => {
      I.value && I.value.dispose(), R.value.remove();
    }), e({ instance: a }), (k, D) => (ue(), de("TresGroup", {
      ref_key: "groupRef",
      ref: a
    }, [
      U(P) && !te.value ? (ue(), de("TresMesh", {
        key: 0,
        ref_key: "meshRef",
        ref: l,
        geometry: U(c),
        material: I.value
      }, null, 8, Bp)) : rn("", !0)
    ], 512));
  }
});
var yl = { exports: {} };
(function(o, e) {
  (function(t, n) {
    o.exports = n();
  })(fd, function() {
    var t = function() {
      function n(f) {
        return r.appendChild(f.dom), f;
      }
      function s(f) {
        for (var g = 0; g < r.children.length; g++) r.children[g].style.display = g === f ? "block" : "none";
        i = f;
      }
      var i = 0, r = document.createElement("div");
      r.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000", r.addEventListener("click", function(f) {
        f.preventDefault(), s(++i % r.children.length);
      }, !1);
      var a = (performance || Date).now(), l = a, c = 0, h = n(new t.Panel("FPS", "#0ff", "#002")), u = n(new t.Panel("MS", "#0f0", "#020"));
      if (self.performance && self.performance.memory) var p = n(new t.Panel("MB", "#f08", "#201"));
      return s(0), { REVISION: 16, dom: r, addPanel: n, showPanel: s, begin: function() {
        a = (performance || Date).now();
      }, end: function() {
        c++;
        var f = (performance || Date).now();
        if (u.update(f - a, 200), f > l + 1e3 && (h.update(1e3 * c / (f - l), 100), l = f, c = 0, p)) {
          var g = performance.memory;
          p.update(g.usedJSHeapSize / 1048576, g.jsHeapSizeLimit / 1048576);
        }
        return f;
      }, update: function() {
        a = this.end();
      }, domElement: r, setMode: s };
    };
    return t.Panel = function(n, s, i) {
      var r = 1 / 0, a = 0, l = Math.round, c = l(window.devicePixelRatio || 1), h = 80 * c, u = 48 * c, p = 3 * c, f = 2 * c, g = 3 * c, m = 15 * c, y = 74 * c, d = 30 * c, w = document.createElement("canvas");
      w.width = h, w.height = u, w.style.cssText = "width:80px;height:48px";
      var v = w.getContext("2d");
      return v.font = "bold " + 9 * c + "px Helvetica,Arial,sans-serif", v.textBaseline = "top", v.fillStyle = i, v.fillRect(0, 0, h, u), v.fillStyle = s, v.fillText(n, p, f), v.fillRect(g, m, y, d), v.fillStyle = i, v.globalAlpha = 0.9, v.fillRect(g, m, y, d), { dom: w, update: function(E, P) {
        r = Math.min(r, E), a = Math.max(a, E), v.fillStyle = i, v.globalAlpha = 1, v.fillRect(0, 0, h, m), v.fillStyle = s, v.fillText(l(E) + " " + n + " (" + l(r) + "-" + l(a) + ")", p, f), v.drawImage(w, g + c, m, y - c, d, g, m, y - c, d), v.fillRect(g + y - c, m, c, d), v.fillStyle = i, v.globalAlpha = 0.9, v.fillRect(g + y - c, m, c, l((1 - E / P) * d));
      } };
    }, t;
  });
})(yl);
var Np = yl.exports;
const Up = /* @__PURE__ */ Rs(Np), e0 = me({
  name: "Stats",
  props: {
    showPanel: {
      type: Number,
      default: 0
    }
  },
  setup(o, { expose: e }) {
    const t = new Up();
    e({ instance: t });
    const n = document.body;
    t.showPanel(o.showPanel || 0), n == null || n.appendChild(t.dom);
    const { onBeforeRender: s, onAfterRender: i } = Ke();
    s(() => t.begin(), Number.NEGATIVE_INFINITY), i(() => t.end(), Number.POSITIVE_INFINITY), rt(() => {
      n == null || n.removeChild(t.dom);
    });
  }
});
class zp {
  constructor(e, t, n) {
    this.name = e, this.fg = t, this.bg = n, this.PR = Math.round(window.devicePixelRatio || 1), this.WIDTH = 90 * this.PR, this.HEIGHT = 48 * this.PR, this.TEXT_X = 3 * this.PR, this.TEXT_Y = 2 * this.PR, this.GRAPH_X = 3 * this.PR, this.GRAPH_Y = 15 * this.PR, this.GRAPH_WIDTH = 84 * this.PR, this.GRAPH_HEIGHT = 30 * this.PR, this.canvas = document.createElement("canvas"), this.canvas.width = 90 * this.PR, this.canvas.height = 48 * this.PR, this.canvas.style.width = "90px", this.canvas.style.position = "absolute", this.canvas.style.height = "48px", this.canvas.style.cssText = "width:90px;height:48px", this.context = this.canvas.getContext("2d"), this.context && (this.context.font = "bold " + 9 * this.PR + "px Helvetica,Arial,sans-serif", this.context.textBaseline = "top", this.context.fillStyle = this.bg, this.context.fillRect(0, 0, this.WIDTH, this.HEIGHT), this.context.fillStyle = this.fg, this.context.fillText(this.name, this.TEXT_X, this.TEXT_Y), this.context.fillRect(this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH, this.GRAPH_HEIGHT), this.context.fillStyle = this.bg, this.context.globalAlpha = 0.9, this.context.fillRect(this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH, this.GRAPH_HEIGHT));
  }
  update(e, t, n, s, i = 0) {
    let r = 1 / 0, a = 0;
    this.context && (r = Math.min(r, e), a = Math.max(n, e), s = Math.max(s, t), this.context.fillStyle = this.bg, this.context.globalAlpha = 1, this.context.fillRect(0, 0, this.WIDTH, this.GRAPH_Y), this.context.fillStyle = this.fg, this.context.fillText(e.toFixed(i) + " " + this.name + " (" + r.toFixed(i) + "-" + parseFloat(a.toFixed(i)) + ")", this.TEXT_X, this.TEXT_Y), this.context.drawImage(this.canvas, this.GRAPH_X + this.PR, this.GRAPH_Y, this.GRAPH_WIDTH - this.PR, this.GRAPH_HEIGHT, this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH - this.PR, this.GRAPH_HEIGHT), this.context.fillRect(this.GRAPH_X + this.GRAPH_WIDTH - this.PR, this.GRAPH_Y, this.PR, this.GRAPH_HEIGHT), this.context.fillStyle = this.bg, this.context.globalAlpha = 0.9, this.context.fillRect(this.GRAPH_X + this.GRAPH_WIDTH - this.PR, this.GRAPH_Y, this.PR, (1 - t / s) * this.GRAPH_HEIGHT));
  }
}
const vl = class Kn {
  constructor({ logsPerSecond: e = 20, samplesLog: t = 100, samplesGraph: n = 10, precision: s = 2, minimal: i = !1, horizontal: r = !0, mode: a = 0 } = {}) {
    this.totalCpuDuration = 0, this.totalGpuDuration = 0, this.totalGpuDurationCompute = 0, this.totalFps = 0, this.activeQuery = null, this.gpuQueries = [], this.renderCount = 0, this.mode = a, this.horizontal = r, this.dom = document.createElement("div"), this.dom.style.cssText = "position:fixed;top:0;left:0;opacity:0.9;z-index:10000;", i && (this.dom.style.cssText += "cursor:pointer"), this.gl = null, this.query = null, this.isRunningCPUProfiling = !1, this.minimal = i, this.beginTime = (performance || Date).now(), this.prevTime = this.beginTime, this.prevCpuTime = this.beginTime, this.frames = 0, this.renderCount = 0, this.threeRendererPatched = !1, this.averageCpu = {
      logs: [],
      graph: []
    }, this.averageGpu = {
      logs: [],
      graph: []
    }, this.averageGpuCompute = {
      logs: [],
      graph: []
    }, this.queryCreated = !1, this.fpsPanel = this.addPanel(new Kn.Panel("FPS", "#0ff", "#002"), 0), this.msPanel = this.addPanel(new Kn.Panel("CPU", "#0f0", "#020"), 1), this.gpuPanel = null, this.gpuPanelCompute = null, this.samplesLog = t, this.samplesGraph = n, this.precision = s, this.logsPerSecond = e, this.minimal ? (this.dom.addEventListener("click", (l) => {
      l.preventDefault(), this.showPanel(++this.mode % this.dom.children.length);
    }, !1), this.mode = a, this.showPanel(this.mode)) : window.addEventListener("resize", () => {
      this.resizePanel(this.fpsPanel, 0), this.resizePanel(this.msPanel, 1), this.gpuPanel && this.resizePanel(this.gpuPanel, 2), this.gpuPanelCompute && this.resizePanel(this.gpuPanelCompute, 3);
    });
  }
  patchThreeRenderer(e) {
    const t = e.render, n = this;
    e.render = function(s, i) {
      n.begin(), t.call(this, s, i), n.end();
    }, this.threeRendererPatched = !0;
  }
  resizePanel(e, t) {
    e.canvas.style.position = "absolute", this.minimal ? e.canvas.style.display = "none" : (e.canvas.style.display = "block", this.horizontal ? (e.canvas.style.top = "0px", e.canvas.style.left = t * e.WIDTH / e.PR + "px") : (e.canvas.style.left = "0px", e.canvas.style.top = t * e.HEIGHT / e.PR + "px"));
  }
  addPanel(e, t) {
    return e.canvas && (this.dom.appendChild(e.canvas), this.resizePanel(e, t)), e;
  }
  showPanel(e) {
    for (let t = 0; t < this.dom.children.length; t++) {
      const n = this.dom.children[t];
      n.style.display = t === e ? "block" : "none";
    }
    this.mode = e;
  }
  async init(e) {
    if (!e) {
      console.error('Stats: The "canvas" parameter is undefined.');
      return;
    }
    if (e.isWebGLRenderer && !this.threeRendererPatched) {
      const t = e;
      this.patchThreeRenderer(t), this.gl = t.getContext();
    } else !this.gl && e instanceof WebGL2RenderingContext && (this.gl = e);
    if (e.isWebGPURenderer) {
      e.backend.trackTimestamp = !0, await e.hasFeatureAsync("timestamp-query") && (this.gpuPanel = this.addPanel(new Kn.Panel("GPU", "#ff0", "#220"), 2), this.gpuPanelCompute = this.addPanel(new Kn.Panel("CPT", "#e1e1e1", "#212121"), 3), this.info = e.info);
      return;
    } else if (!this.gl && e instanceof HTMLCanvasElement || e instanceof OffscreenCanvas) {
      if (this.gl = e.getContext("webgl2"), !this.gl) {
        console.error("Stats: Unable to obtain WebGL2 context.");
        return;
      }
    } else if (!this.gl) {
      console.error("Stats: Invalid input type. Expected WebGL2RenderingContext, HTMLCanvasElement, or OffscreenCanvas.");
      return;
    }
    this.ext = this.gl.getExtension("EXT_disjoint_timer_query_webgl2"), this.ext && (this.gpuPanel = this.addPanel(new Kn.Panel("GPU", "#ff0", "#220"), 2));
  }
  begin() {
    this.isRunningCPUProfiling || this.beginProfiling("cpu-started"), !(!this.gl || !this.ext) && this.gl && this.ext && (this.activeQuery && this.gl.endQuery(this.ext.TIME_ELAPSED_EXT), this.activeQuery = this.gl.createQuery(), this.activeQuery !== null && this.gl.beginQuery(this.ext.TIME_ELAPSED_EXT, this.activeQuery));
  }
  end() {
    this.renderCount++, this.gl && this.ext && this.activeQuery && (this.gl.endQuery(this.ext.TIME_ELAPSED_EXT), this.gpuQueries.push({ query: this.activeQuery }), this.activeQuery = null);
  }
  processGpuQueries() {
    !this.gl || !this.ext || (this.totalGpuDuration = 0, this.gpuQueries.forEach((e, t) => {
      if (this.gl) {
        const n = this.gl.getQueryParameter(e.query, this.gl.QUERY_RESULT_AVAILABLE), s = this.gl.getParameter(this.ext.GPU_DISJOINT_EXT);
        if (n && !s) {
          const r = this.gl.getQueryParameter(e.query, this.gl.QUERY_RESULT) * 1e-6;
          this.totalGpuDuration += r, this.gl.deleteQuery(e.query), this.gpuQueries.splice(t, 1);
        }
      }
    }));
  }
  update() {
    this.info === void 0 ? this.processGpuQueries() : (this.totalGpuDuration = this.info.render.timestamp, this.totalGpuDurationCompute = this.info.compute.timestamp, this.addToAverage(this.totalGpuDurationCompute, this.averageGpuCompute)), this.endProfiling("cpu-started", "cpu-finished", "cpu-duration"), this.addToAverage(this.totalCpuDuration, this.averageCpu), this.addToAverage(this.totalGpuDuration, this.averageGpu), this.renderCount = 0, this.totalCpuDuration === 0 && this.beginProfiling("cpu-started"), this.totalCpuDuration = 0, this.totalFps = 0, this.beginTime = this.endInternal();
  }
  endInternal() {
    this.frames++;
    const e = (performance || Date).now();
    if (e >= this.prevCpuTime + 1e3 / this.logsPerSecond && (this.updatePanel(this.msPanel, this.averageCpu), this.updatePanel(this.gpuPanel, this.averageGpu), this.gpuPanelCompute && this.updatePanel(this.gpuPanelCompute, this.averageGpuCompute), this.prevCpuTime = e), e >= this.prevTime + 1e3) {
      const t = this.frames * 1e3 / (e - this.prevTime);
      this.fpsPanel.update(t, t, 100, 100, 0), this.prevTime = e, this.frames = 0;
    }
    return e;
  }
  addToAverage(e, t) {
    t.logs.push(e), t.logs.length > this.samplesLog && t.logs.shift(), t.graph.push(e), t.graph.length > this.samplesGraph && t.graph.shift();
  }
  beginProfiling(e) {
    window.performance && (window.performance.mark(e), this.isRunningCPUProfiling = !0);
  }
  endProfiling(e, t, n) {
    if (window.performance && t && this.isRunningCPUProfiling) {
      window.performance.mark(t);
      const s = performance.measure(n, e, t);
      this.totalCpuDuration += s.duration, this.isRunningCPUProfiling = !1;
    }
  }
  updatePanel(e, t) {
    if (t.logs.length > 0) {
      let n = 0, s = 0.01;
      for (let a = 0; a < t.logs.length; a++)
        n += t.logs[a], t.logs[a] > s && (s = t.logs[a]);
      let i = 0, r = 0.01;
      for (let a = 0; a < t.graph.length; a++)
        i += t.graph[a], t.graph[a] > r && (r = t.graph[a]);
      e && e.update(n / Math.min(t.logs.length, this.samplesLog), i / Math.min(t.graph.length, this.samplesGraph), s, r, this.precision);
    }
  }
  get domElement() {
    return this.dom;
  }
  get container() {
    return console.warn("Stats: Deprecated! this.container as been replaced to this.dom "), this.dom;
  }
};
vl.Panel = zp;
let Hp = vl;
const t0 = me({
  name: "StatsGl",
  props: [
    "logsPerSecond",
    "samplesLog",
    "samplesGraph",
    "precision",
    "horizontal",
    "minimal",
    "mode"
  ],
  setup(o, { expose: e }) {
    const t = new Hp({
      logsPerSecond: o.logsPerSecond,
      samplesLog: o.samplesLog,
      samplesGraph: o.samplesGraph,
      precision: o.precision,
      horizontal: o.horizontal,
      minimal: o.minimal,
      mode: o.mode
    });
    e({ instance: t });
    const n = document.body, s = t.dom || t.container;
    n == null || n.appendChild(s);
    const { renderer: i } = ve(), { onAfterRender: r } = Ke();
    t.init(i.value), r(() => t.update(), Number.POSITIVE_INFINITY), rt(() => {
      n == null || n.removeChild(s);
    });
  }
}), { logError: Gp } = yt();
async function n0(o, e) {
  const t = new Lr(), n = (e == null ? void 0 : e.fileName) || "scene";
  t.parse(
    o,
    (s) => {
      if (s instanceof ArrayBuffer)
        Vp(s, `${n}.glb`);
      else {
        const i = JSON.stringify(s, null, 2);
        jp(i, `${n}.gltf`);
      }
    },
    (s) => {
      Gp("An error happened while exporting the GLTF", s);
    },
    e
  );
}
function jp(o, e) {
  _l(new Blob([o], { type: "text/plain" }), e);
}
function Vp(o, e) {
  _l(new Blob([o], { type: "application/octet-stream" }), e);
}
function _l(o, e) {
  const t = document.createElement("a");
  t.style.display = "none", document.body.appendChild(t), t.href = URL.createObjectURL(o), t.download = e, t.click(), t.remove();
}
const Yp = ["args"], Xp = ["color"], s0 = /* @__PURE__ */ me({
  __name: "Box",
  props: {
    args: { default: () => [1, 1, 1] },
    color: { default: "#ffffff" }
  },
  setup(o, { expose: e }) {
    const t = o, { invalidate: n } = ve(), { args: s, color: i } = De(t);
    ee(s, () => n());
    const r = ye();
    return e({
      instance: r
    }), (a, l) => (ue(), de("TresMesh", Xe({
      ref_key: "boxRef",
      ref: r
    }, a.$attrs), [
      _e("TresBoxGeometry", { args: U(s) }, null, 8, Yp),
      je(a.$slots, "default", {}, () => [
        _e("TresMeshBasicMaterial", { color: U(i) }, null, 8, Xp)
      ])
    ], 16));
  }
}), qo = new Mt(), ei = new $();
class xl extends sc {
  constructor() {
    super(), this.isLineSegmentsGeometry = !0, this.type = "LineSegmentsGeometry";
    const e = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0], t = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2], n = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
    this.setIndex(n), this.setAttribute("position", new dt(e, 3)), this.setAttribute("uv", new dt(t, 2));
  }
  applyMatrix4(e) {
    const t = this.attributes.instanceStart, n = this.attributes.instanceEnd;
    return t !== void 0 && (t.applyMatrix4(e), n.applyMatrix4(e), t.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  setPositions(e) {
    let t;
    e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
    const n = new ur(t, 6, 1);
    return this.setAttribute("instanceStart", new Jt(n, 3, 0)), this.setAttribute("instanceEnd", new Jt(n, 3, 3)), this.computeBoundingBox(), this.computeBoundingSphere(), this;
  }
  setColors(e) {
    let t;
    e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
    const n = new ur(t, 6, 1);
    return this.setAttribute("instanceColorStart", new Jt(n, 3, 0)), this.setAttribute("instanceColorEnd", new Jt(n, 3, 3)), this;
  }
  fromWireframeGeometry(e) {
    return this.setPositions(e.attributes.position.array), this;
  }
  fromEdgesGeometry(e) {
    return this.setPositions(e.attributes.position.array), this;
  }
  fromMesh(e) {
    return this.fromWireframeGeometry(new ic(e.geometry)), this;
  }
  fromLineSegments(e) {
    const t = e.geometry;
    return this.setPositions(t.attributes.position.array), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Mt());
    const e = this.attributes.instanceStart, t = this.attributes.instanceEnd;
    e !== void 0 && t !== void 0 && (this.boundingBox.setFromBufferAttribute(e), qo.setFromBufferAttribute(t), this.boundingBox.union(qo));
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new mi()), this.boundingBox === null && this.computeBoundingBox();
    const e = this.attributes.instanceStart, t = this.attributes.instanceEnd;
    if (e !== void 0 && t !== void 0) {
      const n = this.boundingSphere.center;
      this.boundingBox.getCenter(n);
      let s = 0;
      for (let i = 0, r = e.count; i < r; i++)
        ei.fromBufferAttribute(e, i), s = Math.max(s, n.distanceToSquared(ei)), ei.fromBufferAttribute(t, i), s = Math.max(s, n.distanceToSquared(ei));
      this.boundingSphere.radius = Math.sqrt(s), isNaN(this.boundingSphere.radius) && console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this);
    }
  }
  toJSON() {
  }
  applyMatrix(e) {
    return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."), this.applyMatrix4(e);
  }
}
qn.line = {
  worldUnits: { value: 1 },
  linewidth: { value: 1 },
  resolution: { value: new ge(1, 1) },
  dashOffset: { value: 0 },
  dashScale: { value: 1 },
  dashSize: { value: 1 },
  gapSize: { value: 1 }
  // todo FIX - maybe change to totalSize
};
ii.line = {
  uniforms: ns.merge([
    qn.common,
    qn.fog,
    qn.line
  ]),
  vertexShader: (
    /* glsl */
    `
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 tmpFwd = normalize( mix( start.xyz, end.xyz, 0.5 ) );
				vec3 worldUp = normalize( cross( worldDir, tmpFwd ) );
				vec3 worldFwd = cross( worldDir, worldUp );
				worldPos = position.y < 0.5 ? start: end;

				// height offset
				float hw = linewidth * 0.5;
				worldPos.xyz += position.x < 0.0 ? hw * worldUp : - hw * worldUp;

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// cap extension
					worldPos.xyz += position.y < 0.5 ? - hw * worldDir : hw * worldDir;

					// add width to the box
					worldPos.xyz += worldFwd * hw;

					// endcaps
					if ( position.y > 1.0 || position.y < 0.0 ) {

						worldPos.xyz -= worldFwd * 2.0 * hw;

					}

				#endif

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`
  )
};
class Hr extends Lt {
  constructor(e) {
    super({
      type: "LineMaterial",
      uniforms: ns.clone(ii.line.uniforms),
      vertexShader: ii.line.vertexShader,
      fragmentShader: ii.line.fragmentShader,
      clipping: !0
      // required for clipping support
    }), this.isLineMaterial = !0, this.setValues(e);
  }
  get color() {
    return this.uniforms.diffuse.value;
  }
  set color(e) {
    this.uniforms.diffuse.value = e;
  }
  get worldUnits() {
    return "WORLD_UNITS" in this.defines;
  }
  set worldUnits(e) {
    e === !0 ? this.defines.WORLD_UNITS = "" : delete this.defines.WORLD_UNITS;
  }
  get linewidth() {
    return this.uniforms.linewidth.value;
  }
  set linewidth(e) {
    this.uniforms.linewidth && (this.uniforms.linewidth.value = e);
  }
  get dashed() {
    return "USE_DASH" in this.defines;
  }
  set dashed(e) {
    e === !0 !== this.dashed && (this.needsUpdate = !0), e === !0 ? this.defines.USE_DASH = "" : delete this.defines.USE_DASH;
  }
  get dashScale() {
    return this.uniforms.dashScale.value;
  }
  set dashScale(e) {
    this.uniforms.dashScale.value = e;
  }
  get dashSize() {
    return this.uniforms.dashSize.value;
  }
  set dashSize(e) {
    this.uniforms.dashSize.value = e;
  }
  get dashOffset() {
    return this.uniforms.dashOffset.value;
  }
  set dashOffset(e) {
    this.uniforms.dashOffset.value = e;
  }
  get gapSize() {
    return this.uniforms.gapSize.value;
  }
  set gapSize(e) {
    this.uniforms.gapSize.value = e;
  }
  get opacity() {
    return this.uniforms.opacity.value;
  }
  set opacity(e) {
    this.uniforms && (this.uniforms.opacity.value = e);
  }
  get resolution() {
    return this.uniforms.resolution.value;
  }
  set resolution(e) {
    this.uniforms.resolution.value.copy(e);
  }
  get alphaToCoverage() {
    return "USE_ALPHA_TO_COVERAGE" in this.defines;
  }
  set alphaToCoverage(e) {
    this.defines && (e === !0 !== this.alphaToCoverage && (this.needsUpdate = !0), e === !0 ? this.defines.USE_ALPHA_TO_COVERAGE = "" : delete this.defines.USE_ALPHA_TO_COVERAGE);
  }
}
const qi = new it(), Qo = new $(), Jo = new $(), tt = new it(), nt = new it(), Nt = new it(), Qi = new $(), Ji = new Re(), st = new rc(), ea = new $(), ti = new Mt(), ni = new mi(), Ut = new it();
let Gt, Fn;
function ta(o, e, t) {
  return Ut.set(0, 0, -e, 1).applyMatrix4(o.projectionMatrix), Ut.multiplyScalar(1 / Ut.w), Ut.x = Fn / t.width, Ut.y = Fn / t.height, Ut.applyMatrix4(o.projectionMatrixInverse), Ut.multiplyScalar(1 / Ut.w), Math.abs(Math.max(Ut.x, Ut.y));
}
function Wp(o, e) {
  const t = o.matrixWorld, n = o.geometry, s = n.attributes.instanceStart, i = n.attributes.instanceEnd, r = Math.min(n.instanceCount, s.count);
  for (let a = 0, l = r; a < l; a++) {
    st.start.fromBufferAttribute(s, a), st.end.fromBufferAttribute(i, a), st.applyMatrix4(t);
    const c = new $(), h = new $();
    Gt.distanceSqToSegment(st.start, st.end, h, c), h.distanceTo(c) < Fn * 0.5 && e.push({
      point: h,
      pointOnLine: c,
      distance: Gt.origin.distanceTo(h),
      object: o,
      face: null,
      faceIndex: a,
      uv: null,
      uv1: null
    });
  }
}
function $p(o, e, t) {
  const n = e.projectionMatrix, i = o.material.resolution, r = o.matrixWorld, a = o.geometry, l = a.attributes.instanceStart, c = a.attributes.instanceEnd, h = Math.min(a.instanceCount, l.count), u = -e.near;
  Gt.at(1, Nt), Nt.w = 1, Nt.applyMatrix4(e.matrixWorldInverse), Nt.applyMatrix4(n), Nt.multiplyScalar(1 / Nt.w), Nt.x *= i.x / 2, Nt.y *= i.y / 2, Nt.z = 0, Qi.copy(Nt), Ji.multiplyMatrices(e.matrixWorldInverse, r);
  for (let p = 0, f = h; p < f; p++) {
    if (tt.fromBufferAttribute(l, p), nt.fromBufferAttribute(c, p), tt.w = 1, nt.w = 1, tt.applyMatrix4(Ji), nt.applyMatrix4(Ji), tt.z > u && nt.z > u)
      continue;
    if (tt.z > u) {
      const v = tt.z - nt.z, E = (tt.z - u) / v;
      tt.lerp(nt, E);
    } else if (nt.z > u) {
      const v = nt.z - tt.z, E = (nt.z - u) / v;
      nt.lerp(tt, E);
    }
    tt.applyMatrix4(n), nt.applyMatrix4(n), tt.multiplyScalar(1 / tt.w), nt.multiplyScalar(1 / nt.w), tt.x *= i.x / 2, tt.y *= i.y / 2, nt.x *= i.x / 2, nt.y *= i.y / 2, st.start.copy(tt), st.start.z = 0, st.end.copy(nt), st.end.z = 0;
    const m = st.closestPointToPointParameter(Qi, !0);
    st.at(m, ea);
    const y = Ze.lerp(tt.z, nt.z, m), d = y >= -1 && y <= 1, w = Qi.distanceTo(ea) < Fn * 0.5;
    if (d && w) {
      st.start.fromBufferAttribute(l, p), st.end.fromBufferAttribute(c, p), st.start.applyMatrix4(r), st.end.applyMatrix4(r);
      const v = new $(), E = new $();
      Gt.distanceSqToSegment(st.start, st.end, E, v), t.push({
        point: E,
        pointOnLine: v,
        distance: Gt.origin.distanceTo(E),
        object: o,
        face: null,
        faceIndex: p,
        uv: null,
        uv1: null
      });
    }
  }
}
class Zp extends he {
  constructor(e = new xl(), t = new Hr({ color: Math.random() * 16777215 })) {
    super(e, t), this.isLineSegments2 = !0, this.type = "LineSegments2";
  }
  // for backwards-compatibility, but could be a method of LineSegmentsGeometry...
  computeLineDistances() {
    const e = this.geometry, t = e.attributes.instanceStart, n = e.attributes.instanceEnd, s = new Float32Array(2 * t.count);
    for (let r = 0, a = 0, l = t.count; r < l; r++, a += 2)
      Qo.fromBufferAttribute(t, r), Jo.fromBufferAttribute(n, r), s[a] = a === 0 ? 0 : s[a - 1], s[a + 1] = s[a] + Qo.distanceTo(Jo);
    const i = new ur(s, 2, 1);
    return e.setAttribute("instanceDistanceStart", new Jt(i, 1, 0)), e.setAttribute("instanceDistanceEnd", new Jt(i, 1, 1)), this;
  }
  raycast(e, t) {
    const n = this.material.worldUnits, s = e.camera;
    s === null && !n && console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');
    const i = e.params.Line2 !== void 0 && e.params.Line2.threshold || 0;
    Gt = e.ray;
    const r = this.matrixWorld, a = this.geometry, l = this.material;
    Fn = l.linewidth + i, a.boundingSphere === null && a.computeBoundingSphere(), ni.copy(a.boundingSphere).applyMatrix4(r);
    let c;
    if (n)
      c = Fn * 0.5;
    else {
      const u = Math.max(s.near, ni.distanceToPoint(Gt.origin));
      c = ta(s, u, l.resolution);
    }
    if (ni.radius += c, Gt.intersectsSphere(ni) === !1)
      return;
    a.boundingBox === null && a.computeBoundingBox(), ti.copy(a.boundingBox).applyMatrix4(r);
    let h;
    if (n)
      h = Fn * 0.5;
    else {
      const u = Math.max(s.near, ti.distanceToPoint(Gt.origin));
      h = ta(s, u, l.resolution);
    }
    ti.expandByScalar(h), Gt.intersectsBox(ti) !== !1 && (n ? Wp(this, t) : $p(this, s, t));
  }
  onBeforeRender(e) {
    const t = this.material.uniforms;
    t && t.resolution && (e.getViewport(qi), this.material.uniforms.resolution.value.set(qi.z, qi.w));
  }
}
class wl extends xl {
  constructor() {
    super(), this.isLineGeometry = !0, this.type = "LineGeometry";
  }
  setPositions(e) {
    const t = e.length - 3, n = new Float32Array(2 * t);
    for (let s = 0; s < t; s += 3)
      n[2 * s] = e[s], n[2 * s + 1] = e[s + 1], n[2 * s + 2] = e[s + 2], n[2 * s + 3] = e[s + 3], n[2 * s + 4] = e[s + 4], n[2 * s + 5] = e[s + 5];
    return super.setPositions(n), this;
  }
  setColors(e) {
    const t = e.length - 3, n = new Float32Array(2 * t);
    for (let s = 0; s < t; s += 3)
      n[2 * s] = e[s], n[2 * s + 1] = e[s + 1], n[2 * s + 2] = e[s + 2], n[2 * s + 3] = e[s + 3], n[2 * s + 4] = e[s + 4], n[2 * s + 5] = e[s + 5];
    return super.setColors(n), this;
  }
  fromLine(e) {
    const t = e.geometry;
    return this.setPositions(t.attributes.position.array), this;
  }
}
class Kp extends Zp {
  constructor(e = new wl(), t = new Hr({ color: Math.random() * 16777215 })) {
    super(e, t), this.isLine2 = !0, this.type = "Line2";
  }
}
const qp = ["object"], Qp = /* @__PURE__ */ me({
  __name: "Line2",
  props: {
    points: {},
    vertexColors: { default: null },
    color: { default: "white" },
    lineWidth: { default: 1 },
    worldUnits: { type: Boolean, default: !1 },
    alphaToCoverage: { type: Boolean, default: !1 },
    dashed: { type: Boolean, default: !1 },
    dashSize: { default: 1 },
    gapSize: { default: 1 },
    dashScale: { default: 1 },
    dashOffset: { default: 0 }
  },
  setup(o, { expose: e }) {
    const t = o;
    function n(f, g) {
      if (!f || f.length === 0)
        return Array.from({ length: g }).fill(xn(t.color));
      if (f.length === 1)
        return Array.from({ length: g }).fill(xn(f[0]));
      if (f.length === g)
        return f.map(xn);
      const m = g - 1, y = f.map(xn);
      closed && y.push(y[0].clone());
      const d = [y[0]], w = m / (y.length - 1);
      for (let v = 1; v < m; v++) {
        const E = v % w / w, P = Math.floor(v / w);
        d.push(y[P].clone().lerp(y[P + 1], E));
      }
      return d.push(y[y.length - 1]), d;
    }
    const s = new Hr(), i = new wl(), r = new Kp(i, s), { sizes: a, invalidate: l } = ve(), c = Fe(() => Array.isArray(t.vertexColors));
    function h(f, g) {
      f.color = xn(g.color), f.linewidth = g.lineWidth, f.alphaToCoverage = g.alphaToCoverage, f.worldUnits = g.worldUnits, f.vertexColors = Array.isArray(g.vertexColors), f.dashed = g.dashed, f.dashScale = g.dashScale, f.dashSize = g.dashSize, f.dashOffset = g.dashOffset, f.gapSize = g.gapSize, f.needsUpdate = !0;
    }
    function u(f, g, m) {
      const y = g.map((w) => w instanceof $ ? [w.x, w.y, w.z] : w instanceof ge ? [w.x, w.y, 0] : Array.isArray(w) && w.length === 2 ? [w[0], w[1], 0] : w).flat();
      f.setPositions(y.flat());
      const d = n(m, g.length).map((w) => w.toArray()).flat();
      f.setColors(d), r.computeLineDistances();
    }
    h(s, t), u(i, t.points, t.vertexColors), r.computeLineDistances(), ee(() => [
      t.color,
      t.lineWidth,
      t.alphaToCoverage,
      t.worldUnits,
      c,
      t.dashed,
      t.dashScale,
      t.dashSize,
      t.dashOffset
    ], () => {
      h(s, t), l();
    }), ee(() => [t.points, t.vertexColors], () => {
      u(i, t.points, t.vertexColors), l();
    }), ee(() => [a.height, a.width], () => {
      s.resolution = new ge(a.width.value, a.height.value), l();
    }), rt(() => {
      i.dispose(), s.dispose();
    });
    const p = ye();
    return e({ instance: p }), (f, g) => (ue(), de("primitive", {
      ref: p.value,
      object: U(r)
    }, null, 8, qp));
  }
}), i0 = /* @__PURE__ */ me({
  __name: "CatmullRomCurve3",
  props: {
    segments: { default: 20 },
    closed: { type: Boolean, default: !1 },
    curveType: { default: "centripetal" },
    tension: { default: 0.5 },
    points: {},
    vertexColors: {},
    color: {},
    lineWidth: {},
    alphaToCoverage: { type: Boolean },
    dashed: { type: Boolean },
    dashSize: {},
    dashScale: {},
    dashOffset: {},
    gapSize: {},
    worldUnits: { type: Boolean }
  },
  setup(o, { expose: e }) {
    const t = o;
    function n(l, c, h, u) {
      const p = l.map(
        (f) => f instanceof $ ? f : new $(...f)
      );
      return new oc(p, c, h, u);
    }
    function s(l, c) {
      return l.getPoints(c);
    }
    const i = Fe(() => n(t.points, t.closed, t.curveType, t.tension)), r = Fe(() => s(i.value, t.segments)), a = ye();
    return e({ instance: a }), (l, c) => (ue(), Pr(Qp, {
      ref: a.value,
      points: r.value,
      "vertex-colors": t.vertexColors,
      color: t.color,
      "line-width": t.lineWidth,
      "alpha-to-coverage": t.alphaToCoverage,
      dashed: t.dashed,
      "dash-size": t.dashSize,
      "dash-scale": t.dashScale,
      "dash-offset": t.dashOffset,
      "gap-size": t.gapSize,
      "world-units": t.worldUnits
    }, null, 8, ["points", "vertex-colors", "color", "line-width", "alpha-to-coverage", "dashed", "dash-size", "dash-scale", "dash-offset", "gap-size", "world-units"]));
  }
}), Jp = ["args"], em = ["color"], r0 = /* @__PURE__ */ me({
  __name: "Circle",
  props: {
    args: { default: () => [1, 32, 0, Math.PI * 2] },
    color: { default: "#ffffff" }
  },
  setup(o, { expose: e }) {
    const t = o, { args: n, color: s } = De(t), { invalidate: i } = ve();
    ee(n, () => i());
    const r = ye();
    return e({
      instance: r
    }), (a, l) => (ue(), de("TresMesh", Xe({
      ref_key: "circleRef",
      ref: r
    }, a.$attrs), [
      _e("TresCircleGeometry", { args: U(n) }, null, 8, Jp),
      je(a.$slots, "default", {}, () => [
        _e("TresMeshBasicMaterial", { color: U(s) }, null, 8, em)
      ])
    ], 16));
  }
}), tm = ["args"], nm = ["color"], o0 = /* @__PURE__ */ me({
  __name: "Cone",
  props: {
    args: { default: () => [1, 1, 12, 12, !1, 0, Math.PI * 2] },
    color: { default: "#ffffff" }
  },
  setup(o, { expose: e }) {
    const t = o, { args: n, color: s } = De(t), { invalidate: i } = ve();
    ee(n, () => i());
    const r = ye();
    return e({
      instance: r
    }), (a, l) => (ue(), de("TresMesh", Xe({
      ref_key: "coneRef",
      ref: r
    }, a.$attrs), [
      _e("TresConeGeometry", { args: U(n) }, null, 8, tm),
      je(a.$slots, "default", {}, () => [
        _e("TresMeshBasicMaterial", { color: U(s) }, null, 8, nm)
      ])
    ], 16));
  }
}), sm = ["args"], im = ["color"], a0 = /* @__PURE__ */ me({
  __name: "Cylinder",
  props: {
    args: { default: () => [1, 1, 1, 32, 1, !1, 0, Math.PI * 2] },
    color: { default: "#ffffff" }
  },
  setup(o, { expose: e }) {
    const t = o, { args: n, color: s } = De(t), { invalidate: i } = ve();
    ee(n, () => i());
    const r = ye();
    return e({
      instance: r
    }), (a, l) => (ue(), de("TresMesh", Xe({
      ref_key: "cylinderRef",
      ref: r
    }, a.$attrs), [
      _e("TresCylinderGeometry", { args: U(n) }, null, 8, sm),
      je(a.$slots, "default", {}, () => [
        _e("TresMeshBasicMaterial", { color: U(s) }, null, 8, im)
      ])
    ], 16));
  }
}), rm = ["args"], om = ["color"], l0 = /* @__PURE__ */ me({
  __name: "Dodecahedron",
  props: {
    args: { default: () => [1, 0] },
    color: { default: "#ffffff" }
  },
  setup(o, { expose: e }) {
    const t = o, { args: n, color: s } = De(t), i = ye(), { invalidate: r } = ve();
    return ee(n, () => r()), e({
      instance: i
    }), (a, l) => (ue(), de("TresMesh", Xe({
      ref_key: "dodecahedronRef",
      ref: i
    }, a.$attrs), [
      _e("TresDodecahedronGeometry", { args: U(n) }, null, 8, rm),
      je(a.$slots, "default", {}, () => [
        _e("TresMeshBasicMaterial", { color: U(s) }, null, 8, om)
      ])
    ], 16));
  }
}), am = ["args"], lm = ["color"], c0 = /* @__PURE__ */ me({
  __name: "Icosahedron",
  props: {
    args: { default: () => [1, 0] },
    color: { default: "#ffffff" }
  },
  setup(o, { expose: e }) {
    const t = o, { args: n, color: s } = De(t), { invalidate: i } = ve();
    ee(n, () => i());
    const r = ye();
    return e({
      instance: r
    }), (a, l) => (ue(), de("TresMesh", Xe({
      ref_key: "icosahedronRef",
      ref: r
    }, a.$attrs), [
      _e("TresIcosahedronGeometry", { args: U(n) }, null, 8, am),
      je(a.$slots, "default", {}, () => [
        _e("TresMeshBasicMaterial", { color: U(s) }, null, 8, lm)
      ])
    ], 16));
  }
}), cm = ["args"], um = ["color"], u0 = /* @__PURE__ */ me({
  __name: "Octahedron",
  props: {
    args: { default: () => [1, 0] },
    color: { default: "#ffffff" }
  },
  setup(o, { expose: e }) {
    const t = o, { args: n, color: s } = De(t), { invalidate: i } = ve();
    ee(n, () => i());
    const r = ye();
    return e({
      instance: r
    }), (a, l) => (ue(), de("TresMesh", Xe({
      ref_key: "octahedronRef",
      ref: r
    }, a.$attrs), [
      _e("TresOctahedronGeometry", { args: U(n) }, null, 8, cm),
      je(a.$slots, "default", {}, () => [
        _e("TresMeshBasicMaterial", { color: U(s) }, null, 8, um)
      ])
    ], 16));
  }
}), hm = ["rotation"], fm = ["args"], dm = ["color"], h0 = /* @__PURE__ */ me({
  __name: "Plane",
  props: {
    args: { default: () => [1, 1] },
    color: { default: "#ffffff" }
  },
  setup(o, { expose: e }) {
    const t = o, { args: n, color: s } = De(t), { invalidate: i } = ve();
    ee(n, () => i());
    const r = ye();
    return e({
      instance: r
    }), (a, l) => (ue(), de("TresMesh", Xe({
      ref_key: "planeRef",
      ref: r,
      rotation: [-Math.PI / 2, 0, 0]
    }, a.$attrs), [
      _e("TresPlaneGeometry", { args: U(n) }, null, 8, fm),
      je(a.$slots, "default", {}, () => [
        _e("TresMeshBasicMaterial", { color: U(s) }, null, 8, dm)
      ])
    ], 16, hm));
  }
}), pm = ["args"], mm = ["color"], f0 = /* @__PURE__ */ me({
  __name: "Ring",
  props: {
    args: { default: () => [0.5, 1, 32] },
    color: { default: "#ffffff" }
  },
  setup(o, { expose: e }) {
    const t = o, { args: n, color: s } = De(t), { invalidate: i } = ve();
    ee(n, () => i());
    const r = ye();
    return e({
      instance: r
    }), (a, l) => (ue(), de("TresMesh", Xe({
      ref_key: "ringRef",
      ref: r
    }, a.$attrs), [
      _e("TresRingGeometry", { args: U(n) }, null, 8, pm),
      je(a.$slots, "default", {}, () => [
        _e("TresMeshBasicMaterial", { color: U(s) }, null, 8, mm)
      ])
    ], 16));
  }
}), gm = ["args"], ym = ["color"], d0 = /* @__PURE__ */ me({
  __name: "RoundedBox",
  props: {
    args: { default: () => [1, 1, 1, 2, 0.1] },
    color: { default: "#ffffff" }
  },
  setup(o, { expose: e }) {
    const t = o, { args: n, color: s } = De(t), { invalidate: i, extend: r } = ve();
    r({ RoundedBoxGeometry: Rh }), ee(n, () => i());
    const a = ye();
    return e({ instance: a }), (l, c) => (ue(), de("TresMesh", {
      ref_key: "roundedBoxRef",
      ref: a
    }, [
      _e("TresRoundedBoxGeometry", { args: U(n) }, null, 8, gm),
      je(l.$slots, "default", {}, () => [
        _e("TresMeshBasicMaterial", { color: U(s) }, null, 8, ym)
      ])
    ], 512));
  }
}), vm = ["args"], _m = ["color"], p0 = /* @__PURE__ */ me({
  __name: "Sphere",
  props: {
    args: { default: () => [2, 32, 16] },
    color: { default: "#ffffff" }
  },
  setup(o, { expose: e }) {
    const t = o, { args: n, color: s } = De(t), { invalidate: i } = ve();
    ee(n, () => i());
    const r = ye();
    return e({
      instance: r
    }), (a, l) => (ue(), de("TresMesh", Xe({
      ref_key: "sphereRef",
      ref: r
    }, a.$attrs), [
      _e("TresSphereGeometry", { args: U(n) }, null, 8, vm),
      je(a.$slots, "default", {}, () => [
        _e("TresMeshBasicMaterial", { color: U(s) }, null, 8, _m)
      ])
    ], 16));
  }
}), xm = ["geometry"], wm = ["color"], m0 = /* @__PURE__ */ me({
  __name: "Superformula",
  props: {
    widthSegments: { default: 32 },
    heightSegments: { default: 32 },
    numArmsA: { default: 4 },
    expA: { default: () => [40, 1.3, 0.9] },
    numArmsB: { default: 4 },
    expB: { default: () => [40, 1.3, 0.9] },
    color: { default: "white" }
  },
  setup(o, { expose: e }) {
    const t = o, { invalidate: n } = ve(), { cos: s, sin: i, abs: r } = Math, a = ye(), l = ye(t.color);
    function c(f, g) {
      const m = new pt(), y = f * g, d = new Float32Array(Array.from({ length: 3 * y }).fill(0)), w = new Float32Array(Array.from({ length: 3 * y }).fill(0)), v = [];
      for (let E = 0; E < g - 1; E++) {
        for (let M = 0; M < f - 1; M++) {
          const _ = E * f + M, C = _ + 1, R = _ + f, B = C + f;
          v.push(_, R, C), v.push(R, B, C);
        }
        const P = E * f + f - 1, T = E * f, b = P + f, x = T + f;
        v.push(P, b, T), v.push(b, x, T);
      }
      return m.setIndex(v), m.setAttribute("position", new mt(d, 3)), m.setAttribute("normal", new mt(w, 3)), m;
    }
    function h(f, g, m, y, d) {
      return (r(s(g * f * 0.25)) ** y + r(i(g * f * 0.25)) ** d) ** (-1 / m);
    }
    function u(f, g, m, y, d, w, v, E, P, T, b) {
      const x = 2 * Math.PI / T, M = -Math.PI, _ = Math.PI / (b - 1), C = -0.5 * Math.PI, R = f.getAttribute("position");
      let B = 0, N = 0, j = C;
      for (let V = 0; V < b; V++) {
        N = M;
        for (let Q = 0; Q < T; Q++) {
          const Z = h(N, g, m, y, d), ne = h(j, w, v, E, P);
          R.setXYZ(
            B,
            Z * s(N) * ne * s(j),
            ne * i(j),
            Z * i(N) * ne * s(j)
          ), B++, N += x;
        }
        j += _;
      }
      R.needsUpdate = !0, f.computeVertexNormals();
    }
    ee(() => t.color, () => l.value = t.color), ee(() => [t.widthSegments, t.heightSegments], () => {
      a.value && a.value.dispose(), a.value = c(t.widthSegments, t.heightSegments), n();
    }, { immediate: !0 }), ee(() => [
      t.numArmsA,
      t.expA[0],
      t.expA[1],
      t.expA[2],
      t.numArmsB,
      t.expB[0],
      t.expB[1],
      t.expB[2]
    ], () => {
      u(a.value, t.numArmsA, t.expA[0], t.expA[1], t.expA[2], t.numArmsB, t.expB[0], t.expB[1], t.expB[2], t.widthSegments, t.heightSegments), n();
    }, { immediate: !0 }), rt(() => {
      a.value && a.value.dispose();
    });
    const p = ye();
    return e({
      instance: p
    }), (f, g) => (ue(), de("TresMesh", Xe({
      ref_key: "superformulaRef",
      ref: p
    }, f.$attrs, { geometry: a.value }), [
      je(f.$slots, "default", {}, () => [
        _e("TresMeshBasicMaterial", { color: l.value }, null, 8, wm)
      ])
    ], 16, xm));
  }
}), Tm = ["rotation"], bm = ["args"], Em = ["color"], g0 = /* @__PURE__ */ me({
  __name: "Tetrahedron",
  props: {
    args: { default: () => [1, 0] },
    color: { default: "#ffffff" }
  },
  setup(o, { expose: e }) {
    const t = o, { args: n, color: s } = De(t), i = ye();
    return e({
      instance: i
    }), (r, a) => (ue(), de("TresMesh", Xe({
      ref_key: "tetrahedronRef",
      ref: i,
      rotation: [-Math.PI / 2, 0, 0]
    }, r.$attrs), [
      _e("TresTetrahedronGeometry", { args: U(n) }, null, 8, bm),
      je(r.$slots, "default", {}, () => [
        _e("TresMeshBasicMaterial", { color: U(s) }, null, 8, Em)
      ])
    ], 16, Tm));
  }
}), Mm = ["args"], Sm = ["color"], y0 = /* @__PURE__ */ me({
  __name: "Torus",
  props: {
    args: { default: () => [1, 1, 16, 80] },
    color: { default: "#ffffff" }
  },
  setup(o, { expose: e }) {
    const t = o, { args: n, color: s } = De(t), { invalidate: i } = ve();
    ee(n, () => i());
    const r = ye();
    return e({
      instance: r
    }), (a, l) => (ue(), de("TresMesh", Xe({
      ref_key: "torusRef",
      ref: r
    }, a.$attrs), [
      _e("TresTorusGeometry", { args: U(n) }, null, 8, Mm),
      je(a.$slots, "default", {}, () => [
        _e("TresMeshBasicMaterial", { color: U(s) }, null, 8, Sm)
      ])
    ], 16));
  }
}), Am = ["args"], Pm = ["color"], v0 = /* @__PURE__ */ me({
  __name: "TorusKnot",
  props: {
    args: { default: () => [1, 0.4, 64, 8] },
    color: { default: "#ffffff" }
  },
  setup(o, { expose: e }) {
    const t = o, { args: n, color: s } = De(t), { invalidate: i } = ve();
    ee(n, () => i());
    const r = ye();
    return e({
      instance: r
    }), (a, l) => (ue(), de("TresMesh", Xe({
      ref_key: "torusKnotRef",
      ref: r
    }, a.$attrs), [
      _e("TresTorusKnotGeometry", { args: U(n) }, null, 8, Am),
      je(a.$slots, "default", {}, () => [
        _e("TresMeshBasicMaterial", { color: U(s) }, null, 8, Pm)
      ])
    ], 16));
  }
}), Cm = ["args"], Rm = ["color"], _0 = /* @__PURE__ */ me({
  __name: "Tube",
  props: {
    args: { default: () => [
      new ac(new $(-1, 0, 0), new $(0, 1, 0), new $(1, 0, 0)),
      20,
      0.2,
      8,
      !1
    ] },
    color: { default: "#ffffff" }
  },
  setup(o, { expose: e }) {
    const t = o, { args: n, color: s } = De(t), { invalidate: i } = ve();
    ee(n, () => i());
    const r = ye();
    return e({
      instance: r
    }), (a, l) => (ue(), de("TresMesh", Xe({
      ref_key: "tubeRef",
      ref: r
    }, a.$attrs), [
      _e("TresTubeGeometry", { args: U(n) }, null, 8, Cm),
      je(a.$slots, "default", {}, () => [
        _e("TresMeshBasicMaterial", { color: U(s) }, null, 8, Rm)
      ])
    ], 16));
  }
}), Im = ["receive-shadow", "rotation"], Om = ["args"], x0 = /* @__PURE__ */ me({
  __name: "Backdrop",
  props: {
    floor: { default: 0.25 },
    segments: { default: 20 },
    receiveShadow: { type: Boolean, default: !1 }
  },
  setup(o, { expose: e }) {
    const t = o, n = (c) => c === 0 ? 0 : 2 ** (10 * c - 10), { floor: s, segments: i, receiveShadow: r } = De(t), a = fe(null);
    ee(
      [i, s, a],
      ([c, h, u]) => {
        if (!u || c === null)
          return;
        let p = 0;
        const f = c / c / 2, g = u.attributes.position;
        for (let m = 0; m < c + 1; m++)
          for (let y = 0; y < c + 1; y++)
            g.setXYZ(
              p++,
              m / c - f + (m === 0 ? -h : 0),
              y / c - f,
              n(m / c)
            );
        g.needsUpdate = !0, u.computeVertexNormals();
      }
    );
    const l = ye();
    return e({ instance: l }), (c, h) => (ue(), de("TresGroup", Xe({
      ref_key: "backdropRef",
      ref: l
    }, c.$attrs), [
      _e("TresMesh", {
        "receive-shadow": U(r),
        rotation: [-Math.PI / 2, 0, Math.PI / 2]
      }, [
        _e("TresPlaneGeometry", {
          ref_key: "planeRef",
          ref: a,
          args: [1, 1, U(i), U(i)]
        }, null, 8, Om),
        je(c.$slots, "default", {}, () => [
          h[0] || (h[0] = _e("TresMeshStandardMaterial", {
            color: 8421504,
            side: 2
          }, null, -1))
        ])
      ], 8, Im)
    ], 16));
  }
}), Dm = ["object"], w0 = /* @__PURE__ */ me({
  __name: "ContactShadows",
  props: {
    opacity: { default: 1 },
    blur: { default: 1 },
    color: { default: "#000000" },
    tint: { default: void 0 },
    scale: { default: 10 },
    width: { default: 1 },
    height: { default: 1 },
    far: { default: 10 },
    smooth: { type: Boolean, default: !0 },
    resolution: { default: 512 },
    frames: { default: Number.POSITIVE_INFINITY },
    depthWrite: { type: Boolean, default: !1 }
  },
  setup(o, { expose: e }) {
    const t = o;
    function n(f, g, m) {
      m.blurPlane.visible = !0, m.blurPlane.material = m.horizontalBlurMaterial, m.horizontalBlurMaterial.uniforms.tDiffuse.value = m.renderTarget.texture, m.horizontalBlurMaterial.uniforms.h.value = f / 256, g.setRenderTarget(m.renderTargetBlur), g.render(m.blurPlane, m.shadowCamera), m.blurPlane.material = m.verticalBlurMaterial, m.verticalBlurMaterial.uniforms.tDiffuse.value = m.renderTargetBlur.texture, m.verticalBlurMaterial.uniforms.v.value = f / 256, g.setRenderTarget(m.renderTarget), g.render(m.blurPlane, m.shadowCamera), m.blurPlane.visible = !1;
    }
    function s(f, g, m, y) {
      const {
        renderTarget: d,
        shadowCamera: w,
        depthMaterial: v
      } = y, E = g.background;
      g.background = null, g.overrideMaterial = v;
      const P = m.getClearAlpha();
      m.setClearAlpha(0), m.setRenderTarget(d), m.render(g, w), g.overrideMaterial = null, n(f.blur, m, y), f.smooth && n(f.blur * 0.4, m, y), m.setRenderTarget(null), m.setClearAlpha(P), g.background = E;
    }
    function i(f) {
      const g = new Sn(), m = new jt(f.resolution, f.resolution);
      m.texture.generateMipmaps = !1;
      const y = new jt(f.resolution, f.resolution);
      y.texture.generateMipmaps = !1;
      const d = new zt(f.width, f.height).rotateX(Math.PI / 2), w = new Qt({
        map: m.texture,
        opacity: f.opacity,
        transparent: !0,
        depthWrite: f.depthWrite,
        color: new Pe(f.color ?? "black")
      }), v = new he(d, w);
      g.add(v), v.scale.y = -1;
      const E = new he(d);
      E.visible = !1, g.add(E);
      const P = new en(-f.width / 2, f.width / 2, f.height / 2, -f.height / 2, 0, 0.3);
      P.rotation.x = Math.PI / 2, g.add(P);
      const T = new $r(), b = new Lt(Ih);
      b.depthTest = !1;
      const x = new Lt(Oh);
      return x.depthTest = !1, {
        renderTarget: m,
        renderTargetBlur: y,
        shadowCamera: P,
        depthMaterial: T,
        horizontalBlurMaterial: b,
        verticalBlurMaterial: x,
        shadowGroup: g,
        plane: v,
        blurPlane: E
      };
    }
    function r(f, g) {
      const m = g.shadowCamera;
      m.left = -f.width / 2, m.right = f.width / 2, m.top = f.height / 2, m.bottom = -f.height / 2, m.far = f.far;
      const y = f.width * (Array.isArray(f.scale) ? f.scale[0] : f.scale || 1), d = f.height * (Array.isArray(f.scale) ? f.scale[1] : f.scale || 1);
      g.shadowGroup.scale.set(y, f.far, d);
    }
    function a(f, g) {
      g.renderTarget.dispose(), g.renderTargetBlur.dispose(), g.renderTarget = new jt(f, f), g.renderTarget.texture.generateMipmaps = !1, g.renderTargetBlur = new jt(f, f), g.renderTargetBlur.texture.generateMipmaps = !1, g.plane.material.map = g.renderTarget.texture;
    }
    function l(f, g) {
      g.plane.material.color = new Pe(f.color ?? "black"), g.depthMaterial.dispose(), g.depthMaterial = new $r(), g.depthMaterial.onBeforeCompile = function(m) {
        const y = f.tint ? new Pe(f.tint) : new Pe("white"), { r: d, g: w, b: v } = y;
        m.fragmentShader = /* glsl */
        `
    ${m.fragmentShader.replace(
          "gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );",
          `gl_FragColor = vec4( ${d}, ${w}, ${v}, ( 1.0 - fragCoordZ ) * opacity);`
        )}
    `;
      };
    }
    const { onBeforeRender: c } = Ke(), h = i(t);
    let u = 0;
    const p = () => u = u >= t.frames ? t.frames - 1 : u;
    return c(
      ({ renderer: f, scene: g, invalidate: m }) => {
        u < t.frames && (u++, s(t, g, f, h), m());
      }
    ), ee(() => [t.opacity, t.depthWrite, t.blur, t.smooth], () => {
      h.plane.material.opacity = t.opacity ?? 1, h.plane.material.depthWrite = t.depthWrite ?? !1, p();
    }, { immediate: !0 }), ee(() => [t.color, t.tint], () => {
      l(t, h), p();
    }, { immediate: !0 }), ee(() => [t.resolution], () => {
      a(t.resolution, h), p();
    }), ee(() => [t.width, t.height, t.scale, t.far], () => {
      r(t, h), p();
    }, { immediate: !0 }), rt(() => {
      for (const f of Object.values(h))
        f && "dispose" in f && typeof f.dispose == "function" && f.dispose();
    }), e({ instance: h.shadowGroup }), (f, g) => (ue(), de("primitive", {
      object: U(h).shadowGroup
    }, null, 8, Dm));
  }
}), T0 = /* @__PURE__ */ me({
  __name: "Fit",
  props: {
    into: { default: () => new Mt(new $(-0.5, -0.5, -0.5), new $(0.5, 0.5, 0.5)) },
    precise: { type: Boolean, default: !1 }
  },
  setup(o, { expose: e }) {
    const t = o, { invalidate: n } = ve(), s = ye(new Sn()), i = ye(new Sn());
    function r(c, h) {
      if (s.value.position.set(0, 0, 0), s.value.updateMatrixWorld(), i.value.scale.set(1, 1, 1), i.value.updateMatrixWorld(), !i.value.children.length || c === null)
        return;
      const { box3: u, use: p } = a(c, h), f = new Mt();
      i.value.children.forEach((w) => f.expandByObject(w, h));
      const g = f.getSize(new $()), m = u.getSize(new $()), y = Math.min(
        m.x / g.x,
        m.y / g.y,
        m.z / g.z
      );
      i.value.scale.setScalar(y === Number.POSITIVE_INFINITY ? 1 : y), i.value.updateMatrixWorld();
      const d = s.value.worldToLocal(f.getCenter(new $()));
      if (p.position) {
        const w = s.value.worldToLocal(u.getCenter(new $()));
        s.value.position.copy(w.sub(d.multiplyScalar(y)));
      } else
        s.value.position.copy(d.sub(d.multiplyScalar(y)));
      n();
    }
    function a(c, h) {
      return typeof c == "number" ? c = new $(c, c, c) : Array.isArray(c) && (c = new $(...c)), c && "isVector3" in c && c.isVector3 ? { box3: new Mt(new $(0, 0, 0), c), use: { position: !1 } } : c && "isBox3" in c && c.isBox3 ? { box3: c, use: { position: !0 } } : c && "isObject3D" in c && c.isObject3D ? { box3: new Mt().setFromObject(c, h ?? !1), use: { position: !0 } } : {
        box3: new Mt(new $(-0.5, -0.5, -0.5), new $(0.5, 0.5, 0.5)),
        use: { position: !0 }
      };
    }
    ee(() => [t.into, t.precise], () => r(t.into, t.precise)), Un(() => {
      r(t.into, t.precise), Mr().then(() => {
        r(t.into, t.precise);
      });
    });
    const l = ye();
    return e({
      instance: l,
      fit: (c = new Mt(new $(-0.5, -0.5, -0.5), new $(0.5, 0.5, 0.5)), h = !1) => {
        r(c, h);
      },
      update: () => r(t.into, t.precise)
    }), (c, h) => (ue(), de("TresGroup", {
      ref_key: "outer",
      ref: l
    }, [
      _e("TresGroup", {
        ref_key: "middle",
        ref: s
      }, [
        _e("TresGroup", {
          ref_key: "inner",
          ref: i
        }, [
          je(c.$slots, "default")
        ], 512)
      ], 512)
    ], 512));
  }
}), Lm = ["rotation-x", "args"], b0 = /* @__PURE__ */ me({
  __name: "Ocean",
  props: {
    textureWidth: { default: 512 },
    textureHeight: { default: 512 },
    waterNormals: { default: "https://raw.githubusercontent.com/Tresjs/assets/main/textures/water-normals/Water_1_M_Normal.jpg" },
    sunDirection: { default: () => new $() },
    sunColor: { default: 16777215 },
    waterColor: { default: 7695 },
    distortionScale: { default: 3.7 },
    size: { default: 1 },
    clipBias: { default: 0 },
    alpha: { default: 1 },
    side: { default: Ss }
  },
  async setup(o, { expose: e }) {
    let t, n;
    const s = o, { textureWidth: i, textureHeight: r, waterNormals: a, sunDirection: l, sunColor: c, waterColor: h, distortionScale: u, size: p, clipBias: f, alpha: g, side: m } = De(s), { extend: y, scene: d } = ve();
    y({ Water: fh });
    const w = ye(), v = ye(), E = d.value.fog !== void 0;
    e({
      instance: w
    }), d.value.traverse((b) => {
      Object.prototype.hasOwnProperty.call(b, "isSky") && (v.value = b);
    }), Un(async () => {
      if (await Mr(), v.value) {
        const b = v.value.material.uniforms.sunPosition.value;
        w.value.material.uniforms.sunDirection.value.copy(b);
      }
    });
    const { normalMap: P } = ([t, n] = Pn(() => li({ normalMap: a.value })), t = await t, n(), t);
    P.wrapS = P.wrapT = kn;
    const { onBeforeRender: T } = Ke();
    return T(({ delta: b, invalidate: x }) => {
      w.value.material.uniforms.time.value += b, x();
    }), (b, x) => (ue(), de("TresWater", {
      ref_key: "waterRef",
      ref: w,
      "rotation-x": -Math.PI / 2,
      args: [void 0, {
        textureWidth: U(i),
        textureHeight: U(r),
        waterNormals: U(P),
        sunDirection: U(l),
        sunColor: U(c),
        waterColor: U(h),
        distortionScale: U(u),
        fog: E,
        size: U(p),
        clipBias: U(f),
        alpha: U(g),
        side: U(m)
      }]
    }, [
      je(b.$slots, "default", {}, () => [
        x[0] || (x[0] = _e("TresPlaneGeometry", { args: [1e4, 1e4] }, null, -1))
      ])
    ], 8, Lm));
  }
}), Fm = ["size", "color", "alpha-map", "map", "opacity", "alpha-test", "depth-write", "transparent", "size-attenuation"], km = ["position", "velocity"], E0 = /* @__PURE__ */ me({
  __name: "Precipitation",
  props: {
    size: { default: 0.1 },
    area: { default: () => [10, 10, 20] },
    color: { default: 16777215 },
    map: {},
    alphaMap: {},
    alphaTest: { default: 0.01 },
    opacity: { default: 0.8 },
    count: { default: 5e3 },
    speed: { default: 0.1 },
    randomness: { default: 0.5 },
    depthWrite: { type: Boolean, default: !1 },
    transparent: { type: Boolean, default: !0 },
    sizeAttenuation: { type: Boolean, default: !0 }
  },
  setup(o, { expose: e }) {
    const t = o, {
      size: n,
      area: s,
      color: i,
      alphaMap: r,
      map: a,
      opacity: l,
      alphaTest: c,
      depthWrite: h,
      transparent: u,
      sizeAttenuation: p,
      count: f,
      speed: g,
      randomness: m
    } = De(t), y = ye();
    let d = [], w = [];
    const v = () => {
      d = new Float32Array(f.value * 3);
      for (let b = 0; b < f.value; b++) {
        const x = b * 3;
        d[x] = (Math.random() - 0.5) * s.value[0], d[x + 1] = (Math.random() - 0.5) * s.value[1], d[x + 2] = (Math.random() - 0.5) * s.value[2];
      }
    }, E = () => {
      w = new Float32Array(f.value * 2);
      for (let b = 0; b < f.value * 2; b += 2)
        w[b] = (Math.random() - 0.5) / 5 * g.value * m.value, w[b + 1] = Math.random() / 5 * g.value;
    };
    E(), v(), Ft(() => {
      E(), v();
    });
    const { onBeforeRender: P } = Ke();
    P(({ invalidate: b }) => {
      var x, M;
      if ((x = y.value) != null && x.attributes.position.array && ((M = y.value) != null && M.attributes.position.count)) {
        const _ = y.value.attributes.position.array;
        for (let C = 0; C < y.value.attributes.position.count; C++) {
          const R = w[C * 2], B = w[C * 2 + 1];
          _[C * 3] += R, _[C * 3 + 1] -= B, (_[C * 3] <= -s.value[0] / 2 || _[C * 3] >= s.value[0] / 2) && (_[C * 3] = _[C * 3] * -1), (_[C * 3 + 1] <= -s.value[1] / 2 || _[C * 3 + 1] >= s.value[1] / 2) && (_[C * 3 + 1] = _[C * 3 + 1] * -1);
        }
        y.value.attributes.position.needsUpdate = !0, b();
      }
    });
    const T = ye();
    return e({ instance: T }), (b, x) => (ue(), de("TresPoints", {
      ref_key: "pointsRef",
      ref: T
    }, [
      _e("TresPointsMaterial", {
        size: U(n),
        color: U(i),
        "alpha-map": U(r),
        map: U(a),
        opacity: U(l),
        "alpha-test": U(c),
        "depth-write": U(h),
        transparent: U(u),
        "size-attenuation": U(p)
      }, null, 8, Fm),
      _e("TresBufferGeometry", {
        ref_key: "geometryRef",
        ref: y,
        position: [U(d), 3],
        velocity: [U(w)]
      }, null, 8, km)
    ], 512));
  }
}), Bm = ["object", "material-uniforms-turbidity-value", "material-uniforms-rayleigh-value", "material-uniforms-mieCoefficient-value", "material-uniforms-mieDirectionalG-value", "material-uniforms-sunPosition-value", "scale"], M0 = /* @__PURE__ */ me({
  __name: "Sky",
  props: {
    turbidity: { default: 3.4 },
    rayleigh: { default: 3 },
    mieCoefficient: { default: 5e-3 },
    mieDirectionalG: { default: 0.7 },
    elevation: { default: 0.6 },
    azimuth: { default: 180 },
    distance: { default: 45e4 }
  },
  setup(o, { expose: e }) {
    const t = o, { invalidate: n } = ve();
    ee(t, () => n());
    const s = ye(), i = new Fr(), r = Fe(
      () => a(t.azimuth, t.elevation)
    );
    function a(l, c) {
      const h = Ze.degToRad(90 - c), u = Ze.degToRad(l);
      return new $().setFromSphericalCoords(1, h, u);
    }
    return e({
      instance: s,
      sunPosition: r.value
    }), (l, c) => (ue(), de("primitive", {
      ref_key: "skyRef",
      ref: s,
      object: U(i),
      "material-uniforms-turbidity-value": t.turbidity,
      "material-uniforms-rayleigh-value": t.rayleigh,
      "material-uniforms-mieCoefficient-value": t.mieCoefficient,
      "material-uniforms-mieDirectionalG-value": t.mieDirectionalG,
      "material-uniforms-sunPosition-value": r.value,
      scale: t.distance
    }, null, 8, Bm));
  }
}), Nm = ["position"], Um = ["position"], zm = ["scale"], Hm = ["map", "depth-test", "color-space", "color", "opacity"], S0 = /* @__PURE__ */ me({
  __name: "Smoke",
  props: {
    color: { default: "#ffffff" },
    opacity: { default: 0.5 },
    speed: { default: 0.4 },
    width: { default: 10 },
    depth: { default: 1.5 },
    segments: { default: 20 },
    texture: { default: "https://raw.githubusercontent.com/Tresjs/assets/main/textures/clouds/defaultCloud.png" },
    depthTest: { type: Boolean, default: !0 }
  },
  async setup(o, { expose: e }) {
    let t, n;
    const s = o, { width: i, depth: r, segments: a, texture: l, color: c, depthTest: h, opacity: u, speed: p } = De(s), f = ye(), g = ye();
    e({
      instance: f
    });
    const m = [a].map((T, b) => ({
      x: i.value / 2 - Math.random() * i.value,
      y: i.value / 2 - Math.random() * i.value,
      scale: 0.4 + Math.sin((b + 1) / a.value * Math.PI) * ((0.2 + Math.random()) * 10),
      density: Math.max(0.2, Math.random()),
      rotation: Math.max(2e-3, 5e-3 * Math.random()) * p.value
    })), y = (T, b) => T / 6 * b * u.value, { map: d } = ([t, n] = Pn(() => li({ map: l.value })), t = await t, n(), t), { renderer: w, camera: v } = ve(), E = Fe(() => {
      var T;
      return (T = w.value) == null ? void 0 : T.outputColorSpace;
    }), { onBeforeRender: P } = Ke();
    return P(({ invalidate: T }) => {
      var b, x;
      f.value && v.value && g.value && ((b = g.value) == null || b.children.forEach((M, _) => {
        M.rotation.z += m[_].rotation;
      }), f.value.lookAt((x = v.value) == null ? void 0 : x.position), T());
    }), (T, b) => (ue(), de("TresGroup", Xe({
      ref_key: "smokeRef",
      ref: f
    }, T.$attrs), [
      _e("TresGroup", {
        ref_key: "groupRef",
        ref: g,
        position: [0, 0, U(a) / 2 * U(r)]
      }, [
        (ue(!0), de(Sa, null, Aa(U(m), ({ scale: x, x: M, y: _, density: C }, R) => (ue(), de("TresMesh", {
          key: `${R}`,
          position: [M, _, -R * U(r)]
        }, [
          _e("TresPlaneGeometry", {
            scale: [x, x, x],
            rotation: [0, 0, 0]
          }, null, 8, zm),
          _e("TresMeshStandardMaterial", {
            map: U(d),
            "depth-test": U(h),
            "color-space": E.value,
            color: U(c),
            "depth-write": !1,
            transparent: "",
            opacity: y(x, C)
          }, null, 8, Hm)
        ], 8, Um))), 128))
      ], 8, Nm)
    ], 16));
  }
});
function Gm(o) {
  return Gr(o, {
    normalizeValue: (e) => xn(e),
    getDefaultValue: () => new Pe(0, 0, 0),
    isSingleValue: (e) => !Array.isArray(e),
    isMultipleValues: (e) => Array.isArray(e) && (e.length === 0 || !Array.isArray(e[0])),
    isMultipleValuesWithStops: (e) => Array.isArray(e) && e.length > 0 && Array.isArray(e[0]),
    isEmpty: (e) => Array.isArray(e) && e.length === 0
  });
}
function er(o) {
  return "isVector3" in o || Array.isArray(o) && o.length > 0 && o.every((e) => typeof e == "number");
}
function jm(o) {
  return Gr(o, {
    normalizeValue: (e) => Pa(e),
    getDefaultValue: () => [0, 0, 0],
    isSingleValue: (e) => er(e),
    isMultipleValues: (e) => Array.isArray(e) && e.length > 0 && er(e[0]),
    isMultipleValuesWithStops: (e) => Array.isArray(e) && e.length > 0 && Array.isArray(e[0]) && e[0].length === 2 && er(e[0][1]),
    isEmpty: (e) => Array.isArray(e) && e.length === 0
  });
}
function Vm(o) {
  return Gr(o, {
    normalizeValue: (e) => e,
    getDefaultValue: () => 1,
    isSingleValue: (e) => !Array.isArray(e) && typeof e < "u",
    isMultipleValues: (e) => Array.isArray(e) && (e.length === 0 || !Array.isArray(e[0])),
    isMultipleValuesWithStops: (e) => Array.isArray(e) && e.length > 0 && Array.isArray(e[0]),
    isEmpty: (e) => Array.isArray(e) && e.length === 0
  });
}
function Gr(o, e) {
  const { normalizeValue: t, getDefaultValue: n, isEmpty: s } = e, i = (l) => e.isSingleValue(l), r = (l) => e.isMultipleValues(l), a = (l) => e.isMultipleValuesWithStops(l);
  if (s(o))
    return [[0, n()]];
  if (i(o))
    return [[0, t(o)]];
  if (r(o)) {
    const l = o.length > 1 ? 1 / (o.length - 1) : 1;
    return o.map((c, h) => [l * h, t(c)]);
  } else if (a(o))
    return o.map(([l, c], h) => [l, t(c)]);
  return [[0, n()]];
}
class Ym {
  constructor(e, t) {
    ce(this, "entries");
    ce(this, "resolution");
    this.entries = e, this.resolution = t;
  }
  useTexture() {
    return new $m(this.entries, this.resolution).use();
  }
}
class jr {
  constructor(e, t, n, s, i, r) {
    ce(this, "data");
    ce(this, "ref");
    ce(this, "name");
    ce(this, "valueMin");
    ce(this, "valueMax");
    ce(this, "suffix");
    ce(this, "renderToCanvasGradient");
    this.data = ai(e) ? e.value : e, this.ref = ai(e) ? e : null, this.name = t, this.valueMin = n, this.valueMax = s, this.suffix = i, this.renderToCanvasGradient = r;
  }
}
class Xm extends jr {
  constructor(e, t = "color", n = 0, s = 1, i = "rgba", r = Zm) {
    super(e, t, n, s, i, r);
  }
}
class na extends jr {
  constructor(e, t = "scalar", n = 0, s = 1, i = "x", r = Km) {
    super(e, t, n, s, i, r);
  }
}
class Wm extends jr {
  constructor(e, t = "scalar3", n = 0, s = 1, i = "xyz", r = qm) {
    super(e, t, n, s, i, r);
  }
}
class $m {
  constructor(e, t) {
    ce(this, "entries");
    ce(this, "size");
    ce(this, "dirty", ye(0));
    ce(this, "context");
    this.entries = e, this.size = Math.max(t, e.length);
    const n = document.createElement("canvas");
    n.height = this.size, n.width = this.size, this.context = n.getContext("2d");
  }
  use() {
    const e = this.build(), t = ye(e);
    for (const n of this.entries)
      n.ref && ee(n.ref, () => {
        var s;
        n.data = (s = n.ref) == null ? void 0 : s.value, yc(this.dirty);
      });
    return $c(
      this.dirty,
      () => {
        this.build(e), t.value = e;
      },
      { throttle: 1e3 / 60 }
    ), {
      texture: t,
      dispose: () => e.dispose(),
      yFor: this.entries.reduce((n, s, i) => (n[s.name] = (i + 0.5) / this.size, n), {})
    };
  }
  build(e) {
    this.entries.forEach((n, s) => {
      const i = this.context.createLinearGradient(0, s, this.size, s);
      n.renderToCanvasGradient(i, n), this.context.fillStyle = i, this.context.fillRect(0, s, this.size, 1);
    }), e && (e.source.data = this.context.getImageData(
      0,
      0,
      this.size,
      this.size
    ));
    const t = e ?? new ba(
      this.context.getImageData(0, 0, this.size, this.size).data,
      this.size,
      this.size,
      oa,
      nr,
      lc,
      ts,
      ts
    );
    return t.needsUpdate = !0, t;
  }
}
function Tl(o, e, t, n, s) {
  return mp(wn(o, e, t), e, t, n, s);
}
function Zm(o, e) {
  return Gm(e.data).forEach(
    ([t, n]) => o.addColorStop(
      t,
      `rgb(${n.r * 255}, ${n.g * 255}, ${n.b * 255})`
    )
  );
}
function Km(o, e) {
  return Vm(e.data).forEach(([t, n]) => {
    o.addColorStop(
      t,
      `rgb(${Tl(
        n,
        e.valueMin,
        e.valueMax,
        0,
        255
      )}, 0, 0)`
    );
  });
}
function qm(o, e) {
  return jm(e.data).forEach(
    ([t, n]) => o.addColorStop(
      t,
      `rgb(${n.map(
        (s) => Tl(s, e.valueMin, e.valueMax, 0, 255)
      )})`
    )
  );
}
class Qm {
  constructor(e = 256) {
    ce(this, "entries");
    ce(this, "resolution");
    this.resolution = e, this.entries = [];
  }
  withResolution(e) {
    return this.resolution = e, this;
  }
  get add() {
    return new eg(
      (e) => this.onAdd(e)
    );
  }
  build() {
    return new Ym(this.entries, this.resolution);
  }
  onAdd(e) {
    return this.entries.push(e), new Jm(e, this);
  }
}
class Jm {
  constructor(e, t) {
    ce(this, "entry");
    ce(this, "parent");
    this.entry = e, this.parent = t;
  }
  id(e) {
    return this.entry.name = e, this;
  }
  range(e, t) {
    return this.entry.valueMin = e, this.entry.valueMax = t, this;
  }
  suffix(e) {
    return this.entry.suffix = e, this;
  }
  canvasGradientRenderer(e) {
    return this.entry.renderToCanvasGradient = e, this;
  }
  /**
   * Add another entry to the ShaderDataBuilder
   */
  get add() {
    return this.parent.add;
  }
  /**
   * Finalize the ShaderDataBuilder
   * @returns ShaderData
   */
  build() {
    return this.parent.build();
  }
}
class eg {
  constructor(e) {
    ce(this, "onAdd");
    this.onAdd = e;
  }
  GradientTresColor(e) {
    return this.onAdd(new Xm(e));
  }
  Gradient01(e) {
    return this.onAdd(new na(e, "zeroOne", 0, 1));
  }
  GradientScalar(e, t, n) {
    return this.onAdd(
      new na(e, "scalar", t, n)
    );
  }
  GradientXyz(e, t, n) {
    return this.onAdd(
      new Wm(e, "position", t, n)
    );
  }
}
let tr = null;
function tg() {
  return tr === null && (tr = new ba(new Uint8Array([0, 0, 0, 0]), 1, 1)), tr;
}
const ng = ["object"], A0 = /* @__PURE__ */ me({
  __name: "component",
  props: {
    map: { default: "https://raw.githubusercontent.com/Tresjs/assets/e41a93c56ec7cb5ac2d241f309e23582a5fe1fc6/textures/sparkles/particle.png" },
    geometry: { default: void 0 },
    directionalLight: { default: void 0 },
    lifetimeSec: { default: 0.4 },
    cooldownSec: { default: 2 },
    normalThreshold: { default: 0.7 },
    noiseScale: { default: 3 },
    scaleNoise: { default: 1 },
    offsetNoise: { default: 0.1 },
    lifetimeNoise: { default: 0 },
    size: { default: 1 },
    alpha: { default: 1 },
    offset: { default: 1 },
    surfaceDistance: { default: 1 },
    sequenceColor: { default: () => [[0.7, "#82dbc5"], [0.8, "#fbb03b"]] },
    sequenceAlpha: { default: () => [[0, 0], [0.1, 1], [0.5, 1], [0.9, 0]] },
    sequenceOffset: { default: () => [0, 0, 0] },
    sequenceNoise: { default: () => [0.1, 0.1, 0.1] },
    sequenceSize: { default: () => [0, 1] },
    sequenceSurfaceDistance: { default: () => [0.05, 0.08, 0.1] },
    mixColor: { default: 0.5 },
    mixAlpha: { default: 1 },
    mixOffset: { default: 1 },
    mixSize: { default: 0 },
    mixSurfaceDistance: { default: 1 },
    mixNoise: { default: 1 },
    blending: { default: wr },
    transparent: { type: Boolean, default: !0 },
    depthWrite: { type: Boolean, default: !1 }
  },
  setup(o, { expose: e }) {
    const t = o, n = Number.parseInt(di.replace(/\D+/g, "")), s = De(t), i = typeof t.map == "string" ? tg() : t.map, { texture: r, yFor: a } = new Qm(256).add.GradientTresColor(s.sequenceColor).id("sequenceColor").add.Gradient01(s.sequenceAlpha).id("sequenceAlpha").add.Gradient01(s.sequenceSurfaceDistance).id("sequenceSurfaceDistance").add.Gradient01(s.sequenceSize).id("sequenceSize").add.GradientXyz(s.sequenceOffset, -1, 1).id("sequenceOffset").add.GradientXyz(s.sequenceNoise, 0, 1).id("sequenceNoise").build().useTexture(), l = {
      blending: t.blending,
      transparent: t.transparent,
      depthWrite: t.depthWrite,
      uniforms: {
        uMap: new Me(i),
        uPixelRatio: new Me(1),
        uNormal: new Me(Pt.DEFAULT_UP),
        uNormalThreshold: new Me(t.normalThreshold),
        uTime: new Me(0),
        uCooldownRatio: new Me(1),
        uSize: new Me(t.size),
        uAlpha: new Me(t.alpha),
        uOffset: new Me(t.offset),
        uSurfaceDistance: new Me(t.surfaceDistance),
        uNoiseScale: new Me(t.noiseScale),
        uScaleNoise: new Me(t.scaleNoise),
        uOffsetNoise: new Me(t.offsetNoise),
        uLifetimeNoise: new Me(t.lifetimeNoise),
        uMixColor: new Me(t.mixColor),
        uMixAlpha: new Me(t.mixAlpha),
        uMixOffset: new Me(t.mixOffset),
        uMixSize: new Me(t.mixSize),
        uMixSurfaceDistance: new Me(t.mixSurfaceDistance),
        uMixNoise: new Me(t.mixNoise),
        uInfoTexture: new Me(r.value)
      },
      vertexShader: `
    uniform float uPixelRatio;
    uniform vec3 uNormal;
    uniform float uNormalThreshold;
    uniform float uTime;
    uniform float uCooldownRatio;
    uniform float uSize;
    uniform float uAlpha;
    uniform float uOffset;
    uniform float uSurfaceDistance;
    uniform float uNoiseScale;
    uniform float uScaleNoise;
    uniform float uOffsetNoise;
    uniform float uLifetimeNoise;
    uniform float uMixColor;
    uniform float uMixAlpha;
    uniform float uMixOffset;
    uniform float uMixSize;
    uniform float uMixSurfaceDistance;
    uniform float uMixNoise;
    uniform sampler2D uInfoTexture;

    varying vec4 vColor;

    void main() {
      float dotNormal = dot(normal, uNormal) * 0.5 + 0.5;
      float normalP = smoothstep(uNormalThreshold, 1., dotNormal);
      float lifetimeNoise = uLifetimeNoise * mix(normalP, 1.0, uMixNoise);

      float t = uTime + position.x * 1. * uNoiseScale + position.y * 10. * uNoiseScale + 
      position.z * 7.3 * uNoiseScale + sin(lifetimeNoise * (position.x + 13. * position.y)) * lifetimeNoise;

      float lifetimeP = max(-0.0001, mix(-uCooldownRatio, 1. + cos(t) * lifetimeNoise, fract(t)));
      float surfaceDistance = texture2D(uInfoTexture, vec2(
        mix(normalP, lifetimeP, uMixSurfaceDistance),
        ${a.sequenceSurfaceDistance})).x * uSurfaceDistance;

      vec4 modelPosition = modelMatrix * (vec4(position, 1.0) + vec4(normal * surfaceDistance, 0.0));
      vec3 noise = texture2D(uInfoTexture, vec2(
        mix(normalP, lifetimeP, uMixNoise),
        ${a.sequenceNoise})).xyz;
      vec3 offset = uOffset * (texture2D(uInfoTexture, vec2(
        mix(normalP, lifetimeP, uMixOffset),
        ${a.sequenceOffset})).xyz * 2.0 - vec3(1.0, 1.0, 1.0));
      modelPosition.x += cos(t * uNoiseScale * 10.0) * 0.2 * uOffsetNoise * noise.x + offset.x;
      modelPosition.y += sin(t * uNoiseScale * 10.0) * 0.2 * uOffsetNoise * noise.y + offset.y;
      modelPosition.z += cos(t * uNoiseScale * 10.0) * 0.2 * uOffsetNoise * noise.z + offset.z;

      vec4 viewPosition = viewMatrix * modelPosition;
      vec4 projectionPostion = projectionMatrix * viewPosition;
      gl_Position = projectionPostion;

      gl_PointSize = 2.
      * texture2D(uInfoTexture, vec2(mix(normalP, lifetimeP, uMixSize), ${a.sequenceSize})).x
      * mix(1., abs(sin(t * uNoiseScale + position.x * 13.9 + position.y * 73.1)), uScaleNoise)
      * uSize * (100.0 / -viewPosition.z) * uPixelRatio;

      if (gl_PointSize < 0.6 || lifetimeP < 0.0) { gl_Position = vec4(2, 2, 2, 1); }

      vColor = texture2D(uInfoTexture, vec2(mix(normalP, lifetimeP, uMixColor), ${a.sequenceColor}))
      * texture2D(uInfoTexture, vec2(mix(normalP, lifetimeP, uMixAlpha), ${a.sequenceAlpha})).x * uAlpha;
    }`,
      fragmentShader: `
    varying vec4 vColor;

    uniform sampler2D uMap;
    uniform sampler2D uInfoTexture;

    void main() {
      gl_FragColor = vColor * texture2D(uMap, gl_PointCoord);
      #include <tonemapping_fragment>
      #include <${n >= 154 ? "colorspace_fragment" : "encodings_fragment"}>
    }`
    }, c = new Lt(l), h = new Ta(void 0, c), u = c.uniforms, p = { immediate: !0 };
    [
      [u.uPixelRatio, ve().sizes.aspectRatio],
      [u.uSize, s.size],
      [u.uNormalThreshold, s.normalThreshold],
      [u.uAlpha, s.alpha],
      [u.uOffset, s.offset],
      [u.uOffsetNoise, s.offsetNoise],
      [u.uMixColor, s.mixColor],
      [u.uMixAlpha, s.mixAlpha],
      [u.uMixOffset, s.mixOffset],
      [u.uMixSize, s.mixSize],
      [u.uMixSurfaceDistance, s.mixSurfaceDistance],
      [u.uMixNoise, s.mixNoise],
      [u.uInfoTexture, r]
    ].forEach(
      ([v, E]) => ee(
        E,
        () => {
          v.value = E.value;
        },
        p
      )
    ), ee([s.noiseScale, s.lifetimeSec], () => {
      u.uNoiseScale.value = s.noiseScale.value * s.lifetimeSec.value;
    }, p), ee([s.lifetimeSec, s.cooldownSec], () => {
      u.uCooldownRatio.value = s.cooldownSec.value / s.lifetimeSec.value;
    }, p), ee(s.map, () => {
      typeof s.map.value == "string" ? li([s.map.value]).then((v) => c.uniforms.uMap.value = v) : c.uniforms.uMap.value = s.map.value;
    });
    const g = new ze(), m = new $();
    Ke().onBeforeRender(({ elapsed: v, invalidate: E }) => {
      h.getWorldQuaternion(g), m.copy(t.directionalLight ? t.directionalLight.position : Pt.DEFAULT_UP).normalize(), m.applyQuaternion(g.invert()), c.uniforms.uNormal.value = m, c.uniforms.uTime.value = v / (t.cooldownSec + t.lifetimeSec), E();
    });
    function y(v) {
      return v && "isObject3D" in v;
    }
    function d(v) {
      return v && "isBufferGeometry" in v;
    }
    Un(() => {
      t.geometry ? d(t.geometry) ? h.geometry.copy(t.geometry) : y(t.geometry) && "geometry" in t.geometry && d(t.geometry.geometry) && h.geometry.copy(t.geometry.geometry) : y(h.parent) && "geometry" in h.parent && d(h.parent.geometry) ? h.geometry.copy(h.parent.geometry) : h.geometry = new cc(1, 16), typeof t.map == "string" && li([t.map]).then((v) => c.uniforms.uMap.value = v);
    }), rt(() => {
      var v;
      (v = c.uniforms.uMap.value) == null || v.dispose(), r.value.dispose(), c.dispose();
    });
    const w = ye();
    return e({ instance: h }), (v, E) => (ue(), de("primitive", {
      ref_key: "sparkleRef",
      ref: w,
      object: U(h)
    }, null, 8, ng));
  }
}), sg = ["position", "a-scale"], ig = ["size", "size-attenuation", "transparent", "alpha-test", "alpha-map"], P0 = /* @__PURE__ */ me({
  __name: "Stars",
  props: {
    size: { default: 0.1 },
    sizeAttenuation: { type: Boolean, default: !0 },
    transparent: { type: Boolean, default: !0 },
    alphaTest: { default: 0.01 },
    count: { default: 5e3 },
    depth: { default: 50 },
    radius: { default: 100 },
    alphaMap: { default: null }
  },
  setup(o, { expose: e }) {
    const t = o, n = fe(), s = fe(), { radius: i, depth: r, count: a, size: l, sizeAttenuation: c, transparent: h, alphaMap: u, alphaTest: p } = De(t), { invalidate: f } = ve();
    ee(t, () => {
      f();
    });
    const g = () => {
      let y = i.value + r.value;
      const d = Fe(() => r.value / a.value), w = [], v = Array.from(
        { length: a.value },
        () => (0.5 + 0.5 * Math.random()) * 4
      ), E = (P) => new $().setFromSpherical(new oi(P, Math.acos(1 - Math.random() * 2), Math.random() * 2 * Math.PI)).toArray();
      for (let P = 0; P < a.value; P++)
        y -= d.value * Math.random(), w.push(...E(y));
      n.value = new Float32Array(w), s.value = new Float32Array(v);
    };
    Ft(() => {
      g();
    });
    const m = ye();
    return e({
      instance: m
    }), (y, d) => (ue(), de("TresPoints", {
      ref_key: "starsRef",
      ref: m
    }, [
      _e("TresBufferGeometry", {
        position: [n.value, 3],
        "a-scale": [s.value, 1]
      }, null, 8, sg),
      _e("TresPointsMaterial", {
        size: U(l),
        "size-attenuation": U(c),
        transparent: U(h),
        "alpha-test": U(p),
        "alpha-map": U(u)
      }, null, 8, ig)
    ], 512));
  }
});
class rg extends Pt {
  constructor() {
    super();
    ce(this, "virtualScene", null);
    this.virtualScene = new Ts();
  }
  add(...t) {
    return this.virtualScene.add(...t), this;
  }
  destructor() {
    this.virtualScene.traverse((t) => {
      t instanceof he && (t.geometry.dispose(), t.material.dispose(), t.material.map && t.material.map.dispose(), this.virtualScene.remove(t));
    }), this.virtualScene = null;
  }
}
const C0 = /* @__PURE__ */ me({
  __name: "component",
  props: {
    background: { type: [Boolean, String], default: !1 },
    blur: { default: 0 },
    files: { default: () => [] },
    path: { default: "" },
    preset: { default: void 0 },
    resolution: { default: 256 },
    near: { default: 1 },
    far: { default: 1e3 },
    frames: { default: Number.POSITIVE_INFINITY }
  },
  async setup(o, { expose: e }) {
    let t, n;
    const s = o, i = fe(null);
    e({ texture: i });
    const { extend: r, renderer: a, scene: l } = ve();
    let c = null;
    const h = fe(null);
    let u = null;
    const p = fe(null), { onBeforeRender: f } = Ke();
    let g = 1;
    f(() => {
      u && p.value && h.value && (s.frames === Number.POSITIVE_INFINITY || g < s.frames) && (u.update(a.value, vc(p.value.virtualScene)), g++);
    }, -1);
    const m = ([t, n] = Pn(() => ff(s, h)), t = await t, n(), t), y = (d) => {
      d ? (l.value.environment = d.texture, s.background && (l.value.background = d.texture)) : (l.value.environment = m.value, s.background && (l.value.background = m.value));
    };
    return ee(m, () => {
      h.value && y(h.value);
    }, { immediate: !0, deep: !0 }), ee(() => Ar().default, (d) => {
      var w, v;
      if (d && (c = d, Array.isArray(c) && c.length > 0 && typeof ((w = c[0]) == null ? void 0 : w.type) != "symbol")) {
        r({ EnvSence: rg }), h.value = new uc(s.resolution), h.value.texture.type = Vt, u = new hc(s.near, s.far, h.value), y(h.value);
        return;
      }
      (v = h.value) == null || v.dispose(), h.value = null, y();
    }, { immediate: !0, deep: !0 }), i.value = m.value, rt(() => {
      var d, w;
      (d = p.value) == null || d.destructor(), (w = h.value) == null || w.dispose();
    }), (d, w) => h.value ? (ue(), de("TresEnvSence", {
      key: 0,
      ref_key: "envSence",
      ref: p
    }, [
      je(d.$slots, "default")
    ], 512)) : rn("", !0);
  }
}), og = {
  key: 0,
  args: [0, 1, 64]
}, ag = {
  key: 1,
  args: [0.5, 1, 64]
}, lg = { key: 2 }, cg = ["tone-mapped", "map", "side", "color"], R0 = /* @__PURE__ */ me({
  __name: "index",
  props: {
    args: { default: null },
    from: { default: "rect" },
    toneMapped: { type: Boolean, default: !1 },
    map: { default: null },
    intensity: { default: 1 },
    color: { default: new Pe(16777215) }
  },
  setup(o) {
    const e = o, t = fe();
    return Ft(() => {
      t.value && (t.value.color.multiplyScalar(e.intensity), t.value.needsUpdate = !0);
    }), (n, s) => (ue(), de("TresMesh", null, [
      n.from === "circle" ? (ue(), de("TresRingGeometry", og)) : n.from === "ring" ? (ue(), de("TresRingGeometry", ag)) : n.from === "rect" ? (ue(), de("TresPlaneGeometry", lg)) : (ue(), Pr(e.from, {
        key: 3,
        args: e
      })),
      _e("TresMeshBasicMaterial", {
        ref_key: "material",
        ref: t,
        "tone-mapped": n.toneMapped,
        map: n.map,
        side: U(tn),
        color: n.color
      }, null, 8, cg)
    ]));
  }
});
function I0(o, e) {
  const t = {};
  for (const n of e)
    Object.prototype.hasOwnProperty.call(o, n) && (t[n] = o[n]);
  return t;
}
function O0(o, e) {
  const t = `set${e[0].toUpperCase()}${e.slice(1)}`;
  return o[t] !== void 0;
}
function D0(o) {
  var t, n;
  let e = o.value;
  return o.value && ((n = (t = o.value) == null ? void 0 : t.value) != null && n.isMesh) && (e = o.value.value.position), Array.isArray(o.value) && (e = new $(...e)), e;
}
export {
  mg as AnimatedSprite,
  x0 as Backdrop,
  Qg as BakeShadows,
  at as BaseCameraControls,
  s0 as Box,
  kg as CameraControls,
  i0 as CatmullRomCurve3,
  r0 as Circle,
  o0 as Cone,
  w0 as ContactShadows,
  Wg as CustomShaderMaterial,
  a0 as Cylinder,
  l0 as Dodecahedron,
  C0 as Environment,
  jg as FBXModel,
  Lg as Fbo,
  T0 as Fit,
  Vg as GLTFModel,
  gg as GlobalAudio,
  $g as HolographicMaterial,
  Jg as Html,
  c0 as Icosahedron,
  Bg as KeyboardControls,
  yg as Lensflare,
  vg as Levioso,
  R0 as Lightformer,
  Qp as Line2,
  Ng as MapControls,
  Zg as MeshGlassMaterial,
  Kg as MeshReflectionMaterial,
  qg as MeshWobbleMaterial,
  _g as MouseParallax,
  b0 as Ocean,
  u0 as Octahedron,
  Ug as OrbitControls,
  h0 as Plane,
  xf as PointerLockControls,
  xg as PositionalAudio,
  E0 as Precipitation,
  Ig as Reflector,
  f0 as Ring,
  d0 as RoundedBox,
  Gg as SVG,
  Fg as Sampler,
  zg as ScrollControls,
  M0 as Sky,
  S0 as Smoke,
  A0 as Sparkles,
  p0 as Sphere,
  P0 as Stars,
  e0 as Stats,
  t0 as StatsGl,
  m0 as Superformula,
  g0 as Tetrahedron,
  Og as Text3D,
  y0 as Torus,
  v0 as TorusKnot,
  Hg as TransformControls,
  _0 as Tube,
  D0 as extractBindingPosition,
  O0 as hasSetter,
  I0 as pick,
  Dg as useAnimations,
  ff as useEnvironment,
  cf as useFBO,
  bf as useFBX,
  ad as useGLTF,
  n0 as useGLTFExporter,
  Yg as useProgress,
  uf as useSurfaceSampler,
  Xg as useVideoTexture
};
